%!PS-Adobe-3.0
%%BoundingBox: 0 0 612 792
%%HiResBoundingBox: 0 0 612.0000 792.0000             
%%Title: GMT v6.2.0_18e79a0_2020.10.08 [64-bit] Document from psxy
%%Creator: GMT6
%%For: unknown
%%DocumentNeededResources: font Helvetica
%%CreationDate: Thu Oct  8 17:36:45 2020
%%LanguageLevel: 2
%%DocumentData: Clean7Bit
%%Orientation: Portrait
%%Pages: 1
%%EndComments

%%BeginProlog
% Begin pslib header
250 dict begin
/! {bind def} bind def
/# {load def}!
/A /setgray #
/B /setdash #
/C /setrgbcolor #
/D /rlineto #
/E {dup stringwidth pop}!
/F /fill #
/G /rmoveto #
/H /sethsbcolor #
/I /setpattern #
/K /setcmykcolor #
/L /lineto #
/M /moveto #
/N /newpath #
/P /closepath #
/R /rotate #
/S /stroke #
/T /translate #
/U /grestore #
/V /gsave #
/W /setlinewidth #
/Y {findfont exch scalefont setfont}!
/Z /show #
/FP {true charpath flattenpath}!
/MU {matrix setmatrix}!
/MS {/SMat matrix currentmatrix def}!
/MR {SMat setmatrix}!
/edef {exch def}!
% Path fill
/FS {/fc edef /fs {V fc F U} def}!
/FQ {/fs {} def}!
% Outline off or on
/O0 {/os {N} def}!
/O1 {/os {P S} def}!
% Set both fill and outline
/FO {fs os}!
% Star: radius xc yc
/Sa {M MS dup 0 exch G 0.726542528 mul -72 R dup 0 D 4 {72 R dup 0 D -144 R dup 0 D} repeat pop MR FO}!
% Box: height width xll yll
/Sb {M dup 0 D exch 0 exch D neg 0 D FO}!
% Rounded box: height width radius xll yll
/SB {MS T /BoxR edef /BoxW edef /BoxH edef BoxR 0 M
  BoxW 0 BoxW BoxH BoxR arct BoxW BoxH 0 BoxH BoxR arct 0 BoxH 0 0 BoxR arct 0 0 BoxW 0 BoxR arct MR FO}!
% Circle: radius xc yc
/Sc {N 3 -1 roll 0 360 arc FO}!
% Diamond: radius xc yc
/Sd {M 4 {dup} repeat 0 G neg dup dup D exch D D FO}!
% Ellipse: major minor angle xc yc
/Se {N MS T R scale 0 0 1 0 360 arc MR FO}!
% Octagon: radius xc yc
/Sg {M MS 22.5 R dup 0 exch G -22.5 R 0.765366865 mul dup 0 D 6 {-45 R dup 0 D} repeat pop MR FO}!
% Hexagon: radius xc yc
/Sh {M MS dup 0 G -120 R dup 0 D 4 {-60 R dup 0 D} repeat pop MR FO}!
% Inverted triangle: radius xc yc
/Si {M MS dup neg 0 exch G 60 R 1.732050808 mul dup 0 D 120 R 0 D MR FO}!
% Rotated rectangle: height width angle xc yc
/Sj {M MS R dup -2 div 2 index -2 div G dup 0 D exch 0 exch D neg 0 D MR FO}!
% Pentagon: radius xc yc
/Sn {M MS dup 0 exch G -36 R 1.175570505 mul dup 0 D 3 {-72 R dup 0 D} repeat pop MR FO}!
% Dot: radius xc yc [hardwired as circle with no outline]
/Sp {N 3 -1 roll 0 360 arc fs N}!
% Patch fill: x1 y1 ... xn yn n
/SP {M {D} repeat FO}!
% Rectangle: height width xc yc
/Sr {M dup -2 div 2 index -2 div G dup 0 D exch 0 exch D neg 0 D FO}!
% Rounded rectangle: height width radius xc yc
/SR {MS T /BoxR edef /BoxW edef /BoxH edef BoxR BoxW -2 div BoxH -2 div T BoxR 0 M
  BoxW 0 BoxW BoxH BoxR arct BoxW BoxH 0 BoxH BoxR arct 0 BoxH 0 0 BoxR arct 0 0 BoxW 0 BoxR arct MR FO}!
% Square: radius xc yc
/Ss {M 1.414213562 mul dup dup dup -2 div dup G 0 D 0 exch D neg 0 D FO}!
% Triangle: radius xc yc
/St {M MS dup 0 exch G -60 R 1.732050808 mul dup 0 D -120 R 0 D MR FO}!
% Single-headed vector
/SV {0 exch M 0 D D D D D 0 D FO}!
% Double-headed vector
/Sv {0 0 M D D 0 D D D D D 0 D D FO}!
% Pie Wedge: radius angle1 angle2 xc yc
/Sw {2 copy M 5 2 roll arc FO}!
% Cross: radius xc yc
/Sx {M 1.414213562 mul 5 {dup} repeat -2 div dup G D neg 0 G neg D S}!
% Y-dash: radius xc yc
/Sy {M dup 0 exch G dup -2 mul dup 0 exch D S}!
% Plus: radius xc yc
/S+ {M dup 0 G dup -2 mul dup 0 D exch dup G 0 exch D S}!
% X-dash: radius xc yc
/S- {M dup 0 G dup -2 mul dup 0 D S}!
% String width, height, depth and total height (height-depth)
/sw {stringwidth pop}!
/sh {V MU 0 0 M FP pathbbox N 4 1 roll pop pop pop U}!
/sd {V MU 0 0 M FP pathbbox N pop pop exch pop U}!
/sH {V MU 0 0 M FP pathbbox N exch pop exch sub exch pop U}!
/sb {E exch sh}!
% To align text {bottom,middle,top}{left,center,right}
/bl {}!
/bc {E -2 div 0 G}!
/br {E neg 0 G}!
/ml {dup 0 exch sh -2 div G}!
/mc {dup E -2 div exch sh -2 div G}!
/mr {dup E neg exch sh -2 div G}!
/tl {dup 0 exch sh neg G}!
/tc {dup E -2 div exch sh neg G}!
/tr {dup E neg exch sh neg G}!
% Maximum of two numbers
/mx {2 copy lt {exch} if pop}!
% Translate and memorize advance
/PSL_xorig 0 def /PSL_yorig 0 def
/TM {2 copy T PSL_yorig add /PSL_yorig edef PSL_xorig add /PSL_xorig edef}!
% To re-encode one font with the provided encoding vector
/PSL_reencode {findfont dup length dict begin
  {1 index /FID ne {def}{pop pop} ifelse} forall
  exch /Encoding edef currentdict end definefont pop
}!
/PSL_eps_begin {					% Marks begin of EPSF inclusion
  /PSL_eps_state save def				% Save state for cleanup
  /PSL_dict_count countdictstack def			% Count objects on dict stack
  /PSL_op_count count 1 sub def				% Count objects on operand stack
  userdict begin					% Push userdict stack
  /showpage {} def					% Deactivate showpage command
  0 setgray 0 setlinecap 1 setlinewidth			% Prepare clean graphics state
  0 setlinejoin 10 setmiterlimit [] 0 setdash newpath
  /languagelevel where	% If level != 1, set strokeadjust and overprint to their defaults
  {pop languagelevel 1 ne {false setstrokeadjust false setoverprint} if} if
}!
/PSL_eps_end {						% Marks end of EPSF inclusion
  count PSL_op_count sub {pop} repeat			% Clean up operand stack
  countdictstack PSL_dict_count sub {end} repeat	% Clean up dict stack
  PSL_eps_state restore					% Restore saved state
}!
/PSL_transp {						% Set transparency
  /.setopacityalpha where {pop .setblendmode .setopacityalpha}{		% Using ghostscript
  /pdfmark where {pop [ /BM exch /CA exch dup /ca exch /SetTransparency pdfmark}	% Or Adobe
  {pop pop} ifelse} ifelse				% Or skip if neither are supported
}!

/Standard+_Encoding [
/.notdef	/.notdef	/.notdef	/.notdef	/.notdef	/.notdef	/.notdef	/.notdef
/.notdef	/.notdef	/.notdef	/.notdef	/.notdef	/.notdef	/.notdef	/.notdef
/.notdef	/.notdef	/.notdef	/.notdef	/.notdef	/.notdef	/.notdef	/.notdef
/.notdef	/threequarters	/threesuperior	/trademark	/twosuperior	/yacute		/ydieresis	/zcaron
/space		/exclam		/quotedbl	/numbersign	/dollar		/percent	/ampersand	/quoteright
/parenleft	/parenright	/asterisk	/plus		/comma		/hyphen		/period		/slash
/zero		/one		/two		/three		/four		/five		/six		/seven
/eight		/nine		/colon		/semicolon	/less		/equal		/greater	/question
/at		/A		/B		/C		/D		/E		/F		/G
/H		/I		/J		/K		/L		/M		/N		/O
/P		/Q		/R		/S		/T		/U		/V		/W
/X		/Y		/Z		/bracketleft	/backslash	/bracketright	/asciicircum	/underscore
/quoteleft	/a		/b		/c		/d		/e		/f		/g
/h		/i		/j		/k		/l		/m		/n		/o
/p		/q		/r		/s		/t		/u		/v		/w
/x		/y		/z		/braceleft	/bar		/braceright	/asciitilde	/florin
/Atilde		/Ccedilla	/Eth		/Lslash		/Ntilde		/Otilde		/Scaron		/Thorn
/Yacute		/Ydieresis	/Zcaron		/atilde		/brokenbar	/ccedilla	/copyright	/degree
/divide		/eth		/logicalnot	/lslash		/minus		/mu		/multiply	/ntilde
/onehalf	/onequarter	/onesuperior	/otilde		/plusminus	/registered	/scaron		/thorn
/.notdef	/exclamdown	/cent		/sterling	/fraction	/yen		/florin		/section
/currency	/quotesingle	/quotedblleft	/guillemotleft	/guilsinglleft	/guilsinglright	/fi		/fl
/Aacute		/endash		/dagger		/daggerdbl	/periodcentered	/Acircumflex	/paragraph	/bullet
/quotesinglbase	/quotedblbase	/quotedblright	/guillemotright	/ellipsis	/perthousand	/Adieresis	/questiondown
/Agrave		/grave		/acute		/circumflex	/tilde		/macron		/breve		/dotaccent
/dieresis	/Eacute		/ring		/cedilla	/Ecircumflex	/hungarumlaut	/ogonek		/caron
/emdash		/Edieresis	/Egrave		/Iacute		/Icircumflex	/Idieresis	/Igrave		/Oacute
/Ocircumflex	/Odieresis	/Ograve		/Uacute		/Ucircumflex	/Udieresis	/Ugrave		/aacute
/acircumflex	/AE		/adieresis	/ordfeminine	/agrave		/eacute		/ecircumflex	/edieresis
/egrave		/Oslash		/OE		/ordmasculine	/iacute		/icircumflex	/idieresis	/igrave
/oacute		/ae		/ocircumflex	/odieresis	/ograve		/dotlessi	/uacute		/ucircumflex
/udieresis	/oslash		/oe		/germandbls	/ugrave		/Aring		/aring		/ydieresis
] def
/PSL_font_encode 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 39 array astore def	% Initially zero
/F0 {/Helvetica Y}!
/F1 {/Helvetica-Bold Y}!
/F2 {/Helvetica-Oblique Y}!
/F3 {/Helvetica-BoldOblique Y}!
/F4 {/Times-Roman Y}!
/F5 {/Times-Bold Y}!
/F6 {/Times-Italic Y}!
/F7 {/Times-BoldItalic Y}!
/F8 {/Courier Y}!
/F9 {/Courier-Bold Y}!
/F10 {/Courier-Oblique Y}!
/F11 {/Courier-BoldOblique Y}!
/F12 {/Symbol Y}!
/F13 {/AvantGarde-Book Y}!
/F14 {/AvantGarde-BookOblique Y}!
/F15 {/AvantGarde-Demi Y}!
/F16 {/AvantGarde-DemiOblique Y}!
/F17 {/Bookman-Demi Y}!
/F18 {/Bookman-DemiItalic Y}!
/F19 {/Bookman-Light Y}!
/F20 {/Bookman-LightItalic Y}!
/F21 {/Helvetica-Narrow Y}!
/F22 {/Helvetica-Narrow-Bold Y}!
/F23 {/Helvetica-Narrow-Oblique Y}!
/F24 {/Helvetica-Narrow-BoldOblique Y}!
/F25 {/NewCenturySchlbk-Roman Y}!
/F26 {/NewCenturySchlbk-Italic Y}!
/F27 {/NewCenturySchlbk-Bold Y}!
/F28 {/NewCenturySchlbk-BoldItalic Y}!
/F29 {/Palatino-Roman Y}!
/F30 {/Palatino-Italic Y}!
/F31 {/Palatino-Bold Y}!
/F32 {/Palatino-BoldItalic Y}!
/F33 {/ZapfChancery-MediumItalic Y}!
/F34 {/ZapfDingbats Y}!
/F35 {/Ryumin-Light-EUC-H Y}!
/F36 {/Ryumin-Light-EUC-V Y}!
/F37 {/GothicBBB-Medium-EUC-H Y}!
/F38 {/GothicBBB-Medium-EUC-V Y}!

/PSL_pathtextdict 26 dict def			% Local storage for the procedure PSL_pathtext.

/PSL_pathtext					% PSL_pathtext'' will place a string
  {PSL_pathtextdict begin			% of text along any path. It takes
    /ydepth exch def                            % a string and starting offset
    /textheight exch def			% distance from the beginning of
    /just exch def				% the path as its arguments. Note
    /offset exch def				% that PSL_pathtext assumes that a
    /str exch def				% path has already been defined
						% and after it places the text
						% along the path, it clears the
						% current path like the ``stroke''
						% and ``fill'' operators; it also
						% assumes that a font has been
						% set. ``pathtext'' begins placing
						% the characters along the current
						% path, starting at the offset
						% distance and continuing until
						% either the path length is
						% exhausted or the entire string
						% has been printed, whichever
						% occurs first. The results will
						% be more effective when a small
						% point size font is used with
						% sharp curves in the path.
						

    /pathdist 0 def				% Initialize the distance we have
						% travelled along the path.
    /setdist offset def				% Initialize the distance we have
						% covered by setting characters.
    /charcount 0 def				% Initialize the character count.
    /justy just 4 idiv textheight mul 2 div neg ydepth sub def % Compute the y-shift
    V flattenpath				% Reduce the path to a series of
						% straight line segments. The
						% characters will be placed along
						% the line segments in the
						% ``linetoproc.''
	{movetoproc} {linetoproc}		% The basic strategy is to process
	{curvetoproc} {closepathproc}		% the segments of the path,
	pathforall				% keeping a running total of the
						% distance we have travelled so
						% far (pathdist). We also keep
						% track of the distance taken up
						% by the characters that have been
						% set so far (setdist). When the
						% distance we have travelled along
						% the path is greater than the
						% distance taken up by the set
						% characters, we are ready to set
						% the next character (if there are
						% any left to be set). This
						% process continues until we have
						% exhausted the full length of the
						% path.
    U N						% Clear the current path.
    end
  } def

PSL_pathtextdict begin
/movetoproc					% ``movetoproc'' is executed when
  { /newy exch def /newx exch def		% a moveto component has been
						% encountered in the pathforall
						% operation.
    /firstx newx def /firsty newy def		% Remember the ``first point'' in
						% the path so that when we get a
						% ``closepath'' component we can
						% properly handle the text.
    /ovr 0 def
    newx newy transform
    /cpy exch def /cpx exch def			% Explicitly keep track of the
						% current position in device
						% space.
  } def

/linetoproc					% ``linetoproc'' is executed when
						% a lineto component has been
						% encountered in the pathforall
						% operation.
  { /oldx newx def /oldy newy def		% Update the old point.
    /newy exch def /newx exch def		% Get the new point.
    /dx newx oldx sub def
    /dy newy oldy sub def
    /dist dx dup mul dy dup mul add sqrt def	% Calculate the distance between
						% the old and the new point.
    dist 0 ne
    { /dsx dx dist div ovr mul def		% dsx and dsy are used to update
      /dsy dy dist div ovr mul def		% the current position to be just
						% beyond the width of the previous
						% character.
      oldx dsx add oldy dsy add transform
      /cpy exch def /cpx exch def		% Update the current position.
      /pathdist pathdist dist add def		% Increment the distance we have
						% travelled along the path.
      {setdist pathdist le			% Keep setting characters along
						% this path segment until we have
						% exhausted its length.
	  {charcount str length lt		% As long as there are still
	      {setchar} {exit} ifelse}		% characters left in the string,
						% set them.
	  { /ovr setdist pathdist sub def		% Keep track of how much we have
	    exit}				% overshot the path segment by
	  ifelse					% setting the previous character.
						% This enables us to position the
						% origin of the following
						% characters properly on the path.
      } loop
    } if
  } def

/curvetoproc					% ``curvetoproc'' is executed when
  { (ERROR: No curveto's after flattenpath!)	% a curveto component has been
    print					% encountered in the pathforall
  } def						% operation. It prints an error
						% message since there shouldn't be
						% any curveto's in a path after
						% the flattenpath operator has
						% been executed.

/closepathproc					% ``closepathproc'' is executed
  {firstx firsty linetoproc			% when a closepath component has
    firstx firsty movetoproc			% been encountered in the
  } def						% pathforall operation. It
						% simulates the action of the
						% operator ``closepath'' by
						% executing ``linetoproc'' with
						% the coordinates of the most
						% recent ``moveto'' and then
						% executing ``movetoproc'' to the
						% same point.

/setchar					% ``setchar'' sets the next
  { /char str charcount 1 getinterval def	% character in the string along
						% the path and then updates the
						% amount of path we have
						% exhausted.
    /charcount charcount 1 add def		% Increment the character count.
    /charwidth char stringwidth pop def		% Find the width of the character.
    V cpx cpy itransform T			% Translate to the current
						% position in user space.
      dy dx atan R				% Rotate the x-axis to coincide
						% with the current segment.
      0 justy M
      char show
      0 justy neg G
      currentpoint transform
      /cpy exch def /cpx exch def		% Update the current position
    						% before we restore ourselves to
						% the untransformed state.
    U /setdist setdist charwidth add def	% Increment the distance we have
  } def						% covered by setting characters.
end

% PSL LABEL CLIP FUNCTIONS

% Two main functions deals with label placement and clipping:
% PSL_curved_path_labels: 	handles texts that must follow curved baselines
% PSL_straight_path_labels:	handles texts that have straight baselines
%
% Both functions assume that several variables have been predefined:
%
% First we have these two constant settings for all text boxes:
%
%   PSL_setboxpen  Function that sets the text box pen attributes (width, texture, color)
%   PSL_setboxrgb  Function that sets the opaque text box color
%
% Then several arrays are placed.  Since a set of several lines segments may each
% have many labels along them, we end up with these variables:
%
%   PSL_n_paths		Total number of segments
%   PSL_path_x		x coordinates of the paths (all concatenated one after another)
%   PSL_path_y		y coordinates of the paths (all concatenated one after another)
%   PSL_path_n		Array with number of points per segment
%   PSL_label_str  	Array with all the labels for all segments
%   PSL_label_n		Array with number of labels per segment
%   PSL_angle		The annotation angle for each label
%
% PSL_curved_path_labels expects those labels to be placed along several
% lines and it needs the node numbers where to place text:
%
% PSL_node	Array with (x,y) node number of label position
%
% PSL_straight_path_labels are simpler and instead expects
%
% PSL_txt_x	(x,y) coordinates of the location of the m labels
% PSL_txt_y

/PSL_set_label_heights
{	% Create array PSL_heights with full label heights
  /PSL_n_labels_minus_1 PSL_n_labels 1 sub def	% Upper limit in loop over labels
  /PSL_heights PSL_n_labels array def		% Create array with text heights
  0 1 PSL_n_labels_minus_1			% Loop psl_k = 0 < PSL_n_labels
  { /psl_k exch def				% Current label index psl_k
    /psl_label PSL_label_str psl_k get def	% Current text label
    PSL_label_font psl_k get cvx exec		% Get and set this label's font attributes
    psl_label sH /PSL_height edef		% Compute the height of this string
    PSL_heights psl_k PSL_height put		% Store it in the array
  } for
} def

% Curved Baseline Text Placement Functions

/PSL_curved_path_labels
{ /psl_bits exch def				% 4 on/of bit settings as indicated below
  /PSL_placetext psl_bits 2 and 2 eq def		% true to place text, false to just make space
  /PSL_clippath psl_bits 4 and 4 eq def		% false inactive, true creates clippath for labels
  /PSL_strokeline false def			% true draws line, false skips
  /PSL_fillbox psl_bits 128 and 128 eq def		% true to paint box opaque before placing text, false gives transparent box
  /PSL_drawbox psl_bits 256 and 256 eq def		% true to draw box outline before placing text, false gives no outline
  /PSL_n_paths1 PSL_n_paths 1 sub def		% one less is the upper limit in for loop over the paths
  /PSL_usebox PSL_fillbox PSL_drawbox or def	% true if we need box outline for fill or stroke or both

  PSL_clippath {clipsave N clippath} if		% Bracket with clipsave/cliprestore and start clip path
  /psl_k 0 def
  /psl_p 0 def
  0 1 PSL_n_paths1
  { /psl_kk exch def						% Index into the PSL_n PSL_m arrays
    /PSL_n PSL_path_n  psl_kk get def				% Get the number of points in this line segment
    /PSL_m PSL_label_n psl_kk get def				% Get the number of labels for this line segment
    /PSL_x PSL_path_x psl_k PSL_n getinterval def		% Get the subset that is the current line segment x-coordinates
    /PSL_y PSL_path_y psl_k PSL_n getinterval def		% Get the subset that is the current line segment y-coordinates
    /PSL_node_tmp PSL_label_node psl_p PSL_m getinterval def	% Get the subset of node values for current line segment
    /PSL_angle_tmp PSL_label_angle psl_p PSL_m getinterval def	% Get the subset of angle values for current line segment
    /PSL_str_tmp PSL_label_str psl_p PSL_m getinterval def		% Get the subset of string values for current line segment
    /PSL_fnt_tmp PSL_label_font psl_p PSL_m getinterval def		% Get the subset of font settings for current line segment
    PSL_curved_path_label					% Operate on this segment only
    /psl_k psl_k PSL_n add def					% Go to next segment start index for path
    /psl_p psl_p PSL_m add def					% Go to next segment start index for nodes
  } for  % The loop over segments
  			
  PSL_clippath {PSL_eoclip} if N			% Activate clip path and return

} def

/PSL_curved_path_label
{	% Deals with a single line segment and its labels
  /PSL_n1 PSL_n 1 sub def	% one less is the upper limit in for loops
  /PSL_m1 PSL_m 1 sub def	% same

  PSL_CT_calcstringwidth	% Calculate the width of each label string
  PSL_CT_calclinedist		% Calculate along-track distances
  PSL_CT_excludelabels		% Possibly eliminate labels outside of line domain
  PSL_CT_addcutpoints		% Expand path to include the cut points

% Now we have the final xx/yy array and we are ready to simply lay down the lines
% and place the text along the line where there are labels.  We will use the
% new array PSL_xp/yp to store the final points prior to use

  /PSL_nn1 PSL_nn 1 sub def		% End index in for loop
  /n 0 def				% Toggle: 0 means line, 1 means text
  /k 0 def				% Index of the current text string
  /j 0 def				% Output point number counter
  /PSL_seg 0 def			% Line segment number
  /PSL_xp PSL_nn array def
  /PSL_yp PSL_nn array def
  PSL_xp 0 PSL_xx 0 get put		% Place first point in array
  PSL_yp 0 PSL_yy 0 get put
  1 1 PSL_nn1				% Loop over rest of points
  { /i exch def				% Index into PSL_xx/yy arrays
    /node_type PSL_kind i get def	% Check what kind of point the current point is
    /j j 1 add def			% Update point count
    PSL_xp j PSL_xx i get put		% Add this point to the path
    PSL_yp j PSL_yy i get put
    node_type 1 eq			% If this is a cut point we either stroke or place text
    {n 0 eq				% n is 0 so this is the strokable segment
      {PSL_CT_drawline}
      {	PSL_CT_reversepath		% here, n = 1 so this is the segment along which text should be placed
	PSL_CT_textline} ifelse		% Reverse path if needed to place text correctly
      /j 0 def
      PSL_xp j PSL_xx i get put		% Place new first point in array
      PSL_yp j PSL_yy i get put
    } if
  } for
  n 0 eq {PSL_CT_drawline} if	% Finish off the last line segment

} def

/PSL_CT_textline
{ PSL_fnt k get cvx exec		% Get and set this label's font attributes
  /PSL_height PSL_heights k get def	% Recall the height of this text
  PSL_placetext	{PSL_CT_placelabel} if	% If we want to place the text
  PSL_clippath {PSL_CT_clippath} if
  /n 0 def /k k 1 add def		% Set n back to 0, goto next label
} def

/PSL_CT_calcstringwidth			% Calculate the width of each label string
{ /PSL_width_tmp PSL_m array def	% Assign space for distance
  0 1 PSL_m1
  { /i exch def
    PSL_fnt_tmp i get cvx exec					% Get and set this label's font attributes
    PSL_width_tmp i PSL_str_tmp i get stringwidth pop put	% Compute width and store in the array
  } for
} def

/PSL_CT_calclinedist			% Calculate the distance along the line
{ /PSL_newx PSL_x 0 get def
  /PSL_newy PSL_y 0 get def
  /dist 0.0 def			% Cumulative distance at first point is 0
  /PSL_dist PSL_n array def	% Assign array space for distance
  PSL_dist 0 0.0 put		% Distances start at 0 and the 'th point
  1 1 PSL_n1			% Loop over the remaining points
  { /i exch def
    /PSL_oldx PSL_newx def
    /PSL_oldy PSL_newy def
    /PSL_newx PSL_x i get def
    /PSL_newy PSL_y i get def
    /dx PSL_newx PSL_oldx sub def
    /dy PSL_newy PSL_oldy sub def
    /dist dist dx dx mul dy dy mul add sqrt add def
    PSL_dist i dist put
  } for
} def

% Some labels (in particular first and last per segment) may be too long
% to actually fit inside the length of the line.  We precalculate the
% start and end distances for each label and those that exceed the length
% of the line cannot be plotted and are thus skipped.  The surviving labels
% and their information is copied to the final PSL arrays

/PSL_CT_excludelabels
{ /k 0 def				% Current cut point
  /PSL_width PSL_m array def		% New array of distances
  /PSL_angle PSL_m array def		% New array of angles
  /PSL_node PSL_m array def		% New array of nodes
  /PSL_str PSL_m array def		% New array of strings
  /PSL_fnt PSL_m array def		% New array of fonts
  /lastdist PSL_dist PSL_n1 get def	% Length of line 
  0 1 PSL_m1				% For each of the m labels
  { /i exch def						% Index for label distance
    /dist PSL_dist PSL_node_tmp i get get def		% Recall the distance to this label center
    /halfwidth PSL_width_tmp i get 2 div PSL_gap_x add def	% Set the halfwidth + gap distance
    /L_dist dist halfwidth sub def			% Distance at beginning of label gap
    /R_dist dist halfwidth add def			% Distance at the end of label gap
    L_dist 0 gt R_dist lastdist lt and		% Yes, label is inside line ends
    { % These are the labels we will use
      PSL_width k PSL_width_tmp i get put	% Copy over width
      PSL_node k PSL_node_tmp i get put		% Copy over node
      PSL_angle k PSL_angle_tmp i get put	% Copy over angle
      PSL_str k PSL_str_tmp i get put		% Copy over text
      PSL_fnt k PSL_fnt_tmp i get put		% Copy over font
      /k k 1 add def
    } if
  } for
  /PSL_m k def	% New number of labels
  /PSL_m1 PSL_m 1 sub def
} def

% Initialize an array with all the original line points plus the set of 2*m
% points at the transition from line to labelspace at each label
% At the end of this section, the PSL_xx/yy array will be the array to use.

/PSL_CT_addcutpoints
{ /k 0 def				% Current cut point
  /PSL_nc PSL_m 2 mul 1 add def		% 2*m points + one last acting as infinity
  /PSL_cuts PSL_nc array def		% The array of distances to each cut
  /PSL_nc1 PSL_nc 1 sub def		% One less to use in for loop limits
  0 1 PSL_m1				% For each of the m labels
  { /i exch def						% Index for label distance
    /dist PSL_dist PSL_node i get get def		% Recall the distance to this label center
    /halfwidth PSL_width i get 2 div PSL_gap_x add def	% Set the halfwidth + gap distance
    PSL_cuts k dist halfwidth sub put			% Distance at beginning of label gap
    /k k 1 add def					% Was at start, now go to end distance node
    PSL_cuts k dist halfwidth add put			% Distance at the end of label gap
    /k k 1 add def					% Was at end, move to next
  } for
  PSL_cuts k 100000.0 put				% Last cut has ~infinite distance

  /PSL_nn PSL_n PSL_m 2 mul add def	% The total path will be 2*m points longer
  /PSL_xx PSL_nn array def		% Assign new space for x and y
  /PSL_yy PSL_nn array def
  /PSL_kind PSL_nn array def		% 0 = ordinary point, 1 = added point for label gap
  /j 0 def				% Index for new track array
  /k 0 def				% Index for current cut distance
  /dist 0.0 def				% Current distance along track, starting at zero
  0 1 PSL_n1				% Loop over every original line point
  { /i exch def				% Index into current point on original line xy array
    /last_dist dist def			% Update distance to last point (initially zero)
    /dist PSL_dist i get def		% Distance to current point
    k 1 PSL_nc1				% Loop over remaining cuts (starting with all)
    { /kk exch def			% Index into current cut distance
      /this_cut PSL_cuts kk get def	% Distance to start of this label gap
      dist this_cut gt			% Oh, oh, we just stepped over a cut point
      { /ds dist last_dist sub def	% Change in distance
	/f ds 0.0 eq {0.0} {dist this_cut sub ds div} ifelse def	% Get fractional change in distance
	/i1 i 0 eq {0} {i 1 sub} ifelse def
	PSL_xx j PSL_x i get dup PSL_x i1 get sub f mul sub put	% Calc (x,y) at label start (or stop) point
	PSL_yy j PSL_y i get dup PSL_y i1 get sub f mul sub put
	PSL_kind j 1 put		% Set PSL_kind to 1 since it is an added cut point
	/j j 1 add def			% Go to next output point
	/k k 1 add def			% Done with this cut point
      } if
    } for
    dist PSL_cuts k get le		% Having dealt with the cut, we may add the regular point
    {PSL_xx j PSL_x i get put PSL_yy j PSL_y i get put
      PSL_kind j 0 put			% Ordinary (original) coordinates
      /j j 1 add def			% Go to next output point
    } if
  } for
} def

/PSL_CT_reversepath
{PSL_xp j get PSL_xp 0 get lt	% Path must first be reversed to avoid upside-down text
  {0 1 j 2 idiv		% Loop over half the path and swap left/right points
    { /left exch def		% Current left point
      /right j left sub def	% Matching right point
      /tmp PSL_xp left get def	% Swap left and right values for x then y
      PSL_xp left PSL_xp right get put
      PSL_xp right tmp put
      /tmp PSL_yp left get def
      PSL_yp left PSL_yp right get put
      PSL_yp right tmp put
    } for
  } if
  % Now PSL_xp/yp has the correct order to give proper text angles
} def

/PSL_CT_placelabel
{ % Places the curved text label on current segment
  /PSL_just PSL_label_justify k get def	% Get this labels justification
  /PSL_height PSL_heights k get def	% Recall the height of this string
  /psl_label PSL_str k get def		% Get the current label
  /psl_depth psl_label sd def		% Determine depth beneath baseline
  PSL_usebox		% Want to lay down box outline or fill
  {PSL_CT_clippath	% Box path now current path
    PSL_fillbox		% Want to paint box
    {V PSL_setboxrgb fill U} if
    PSL_drawbox		% Want to draw outline of box
    {V PSL_setboxpen S U} if N
  } if
  PSL_CT_placeline psl_label PSL_gap_x PSL_just PSL_height psl_depth PSL_pathtext
} def

/PSL_CT_clippath
{ % Lays down a curved clipbox for one label
  /H PSL_height 2 div PSL_gap_y add def
  /xoff j 1 add array def
  /yoff j 1 add array def
  /angle 0 def	% So it is at least a defined variable
  0 1 j {	% Loop over points along line to calculate angle and offsets
    /ii exch def	% Index
    /x PSL_xp ii get def
    /y PSL_yp ii get def
    ii 0 eq {	% Are we at the first point and hence must calculate angle using 0 and 1?
      /x1 PSL_xp 1 get def
      /y1 PSL_yp 1 get def
      /dx x1 x sub def
      /dy y1 y sub def
    }
    { /i1 ii 1 sub def	% Previous point
      /x1 PSL_xp i1 get def
      /y1 PSL_yp i1 get def
      /dx x x1 sub def
      /dy y y1 sub def
    } ifelse
    dx 0.0 eq dy 0.0 eq and not
    { /angle dy dx atan 90 add def} if	% Only calculate new angle if not duplicates
    /sina angle sin def
    /cosa angle cos def
    xoff ii H cosa mul put
    yoff ii H sina mul put
  } for

  % Lay down next clip segment

  PSL_xp 0 get xoff 0 get add PSL_yp 0 get yoff 0 get add M
  1 1 j {	% Loop over the rest of the upper line
    /ii exch def
    PSL_xp ii get xoff ii get add PSL_yp ii get yoff ii get add L
  } for
  j -1 0 {	% Loop backwards over the rest of the lower line
    /ii exch def
    PSL_xp ii get xoff ii get sub PSL_yp ii get yoff ii get sub L
  } for P
} def

/PSL_CT_drawline
{
  /str 20 string def
  % PSL_strokeline PSL_seg 0 eq and		% If we asked to draw lines...
  PSL_strokeline				% If we asked to draw lines...
  {PSL_CT_placeline S} if			% Lay down the rest of the path and stroke it
  /PSL_seg PSL_seg 1 add def			% Goto next segment number
  /n 1 def					% Set n to 1
} def

/PSL_CT_placeline
{PSL_xp 0 get PSL_yp 0 get M			% Set the anchor point of the path
  1 1 j { /ii exch def PSL_xp ii get PSL_yp ii get L} for	% Lay down the rest of the path
} def

% Draw Baseline Text Segment Lines
% PSL_draw_path_lines will draw the lines that have been stored in the concatenated
% PSL_path_x and PSL_path_y arrays using the pen attributes in the PSL_path_pen array

/PSL_draw_path_lines
{	% Draws the lines already stored in the PSL_path_x|y arrays
  /PSL_n_paths1 PSL_n_paths 1 sub def		% One less is the upper limit in for loop over the paths
  V
  /psl_start 0 def					% Start index of segment in concatenated path array
  0 1 PSL_n_paths1					% Loop over all segments
  { /psl_k exch def					% Index into the PSL arrays
    /PSL_n PSL_path_n psl_k get def			% Get the number of points in this line segment
    /PSL_n1 PSL_n 1 sub def				% One less is the upper limit in for loop over points
    PSL_path_pen psl_k get cvx exec			% Get and set this line's pen
    N							% Clean path
    PSL_path_x psl_start get PSL_path_y psl_start get M	% Place anchor point of this segment
    1 1 PSL_n1						% Loop over points in this segment
    { /psl_i exch def					% Local index of next point in segment
      /psl_kk psl_i psl_start add def			% Equivalent index in concatenated array of all segments
      PSL_path_x psl_kk get PSL_path_y psl_kk get L	% Draw to next point
    } for
    /psl_xclose PSL_path_x psl_kk get PSL_path_x psl_start get sub def	% Difference between first and last x coordinate
    /psl_yclose PSL_path_y psl_kk get PSL_path_y psl_start get sub def	% Difference between first and last y coordinate
    psl_xclose 0 eq psl_yclose 0 eq and { P } if	% Explicitly close the path
    S							% Stroke this path
    /psl_start psl_start PSL_n add def			% Go to next segment and update start index for path
  } for
  U
} def

% Straight Baseline Text Placement Functions
% PSL_straight_path_labels deals with straight text labels w/wo textboxes (rect or rounded).
% Only the (x,y) location of each label is needed.
% Use <flags> PSL_straight_path_labels to paint|draw textboxes and place text
% Use <flags> PSL_straight_path_clip to use textboxes to define and activate clipping
% Subroutines of these functions are called PSL_ST_*
% Local variables are called psl_*, global are called PSL_*

/PSL_straight_path_labels
{	% This function will lay down (a) text box paint, (b) text box outline, and (c) text labels
	% All of these are optionals specified by the bit flag.
  /psl_bits exch def				% Single bitflag argument passed
  /PSL_placetext psl_bits 2 and 2 eq def	% true to place text, false to just make space
  /PSL_rounded psl_bits 32 and 32 eq def	% true for rounded box shape, false gives rectangular box
  /PSL_fillbox psl_bits 128 and 128 eq def	% true to paint box opaque before placing text
  /PSL_drawbox psl_bits 256 and 256 eq def	% true to draw box outline before placing text
  /PSL_n_labels_minus_1 PSL_n_labels 1 sub def	% Upper limit in loop over labels
  /PSL_usebox PSL_fillbox PSL_drawbox or def	% true if we need box outline for fill or stroke or both
  0 1 PSL_n_labels_minus_1			% Loop psl_k = 0 < PSL_n_labels
  { /psl_k exch def				% Current label index psl_k
    PSL_ST_prepare_text				% Get all dimensions, coordinates, etc. for this label
    PSL_usebox					% If a text box is requested we go in here:
    {  PSL_rounded				% Place text box path, either straight or rounded, on stack
        {PSL_ST_textbox_round}
        {PSL_ST_textbox_rect}
      ifelse
      PSL_fillbox {V PSL_setboxrgb fill U} if	% Paint it, if requested
      PSL_drawbox {V PSL_setboxpen S U} if	% Outline it, if requested
      N						% Done, so remove path
    } if
    PSL_placetext {PSL_ST_place_label} if	% Show text, if requested
  } for
} def

/PSL_straight_path_clip
{	% This function will create a total clip path for all the labels in PSL_txt
  /psl_bits exch def				% Single bit flag argument passed
  /PSL_rounded psl_bits 32 and 32 eq def	% true for rounded box shape, false gives rectangular box
  /PSL_n_labels_minus_1 PSL_n_labels 1 sub def	% Upper limit in loop over labels

  N clipsave clippath				% Start clip path by selecting the entire mappable area
  0 1 PSL_n_labels_minus_1			% Loop over all labels
  { /psl_k exch def				% Current label index psl_k
    PSL_ST_prepare_text				% Get all dimensions, coordinates, etc. for this label
    PSL_rounded					% Get either straight or rounded text box path
      {PSL_ST_textbox_round}
      {PSL_ST_textbox_rect}
    ifelse
  } for
  PSL_eoclip N					% Set the new clip path, increment clip counter and clear path
} def

/PSL_ST_prepare_text		% Compute various dimensions and coordinates for one label
{ % The current label has index psl_k
  /psl_xp PSL_txt_x psl_k get def		% Get text placement x coordinate
  /psl_yp PSL_txt_y psl_k get def		% Get text placement y coordinate
  /psl_label PSL_label_str psl_k get def	% Current text label
  PSL_label_font psl_k get cvx exec		% Get and set this label's font attributes
  /PSL_height PSL_heights psl_k get def		% Recall the height of this string
  /psl_boxH PSL_height PSL_gap_y 2 mul add def	% Set height of current label including clearance
  /PSL_just PSL_label_justify psl_k get def	% Get text justification (1-11)
  /PSL_justx PSL_just 4 mod 1 sub 2 div neg def % This is 0, -0.5, or -1 for relative x-shift 
  /PSL_justy PSL_just 4 idiv 2 div neg def	% This is 0, -0.5, or -1 for relative y-shift 
  /psl_SW psl_label stringwidth pop def		% Width of current label space
  /psl_boxW psl_SW PSL_gap_x 2 mul add def	% Width of current label space including clearance
  /psl_x0 psl_SW PSL_justx mul def		% (psl_x0,psl_y0) is rotated/adjusted text LL point on inside rectangle relative to psl_xp,psl_yp
  /psl_y0 PSL_justy PSL_height mul def		%
  /psl_angle PSL_label_angle psl_k get def	% The angle of text w.r.t. baseline
} def

/PSL_ST_textbox_rect	% Compute and place rectangular path for current label
{
  psl_xp psl_yp T psl_angle R psl_x0 psl_y0 T	% Rotate the coordinate system to follow baseline text and make (psl_x0,psl_y0) the new origin
  PSL_gap_x neg PSL_gap_y neg M			% Set LL anchor point for rectangular box
  0 psl_boxH D psl_boxW 0 D 0 psl_boxH neg D P	% Draw text box going CW
  psl_x0 neg psl_y0 neg T psl_angle neg R psl_xp neg psl_yp neg T	% Unto trans/rot above
} def

/PSL_ST_textbox_round	% Compute and place rounded rectangular path for current label
{
  /psl_BoxR PSL_gap_x PSL_gap_y lt {PSL_gap_x} {PSL_gap_y} ifelse def	% Smallest gap distance is our corner radius
  /psl_xd PSL_gap_x psl_BoxR sub def 			% When x_gap exceeds y_gap there will be an adjustment in x, else 0
  /psl_yd PSL_gap_y psl_BoxR sub def 			% When y_gap exceeds x_gap there will be an adjustment in y, else 0
  /psl_xL PSL_gap_x neg def				% Left-most x coordinate of text box
  /psl_yB PSL_gap_y neg def				% Bottom y coordinate of text box
  /psl_yT psl_boxH psl_yB add def			% Top y coordinate of text box
  /psl_H2 PSL_height psl_yd 2 mul add def		% Inner height when adjusting for any psl_yd offset
  /psl_W2 psl_SW psl_xd 2 mul add def			% Inner width when adjusting for any psl_xd offset
  /psl_xR psl_xL psl_boxW add def			% Right-most x coordinate of text box
  /psl_x0 psl_SW PSL_justx mul def			% (psl_x0,psl_y0) is rotated/adjusted text LL point on inside rectangle relative to psl_xp,psl_yp
  psl_xp psl_yp T psl_angle R psl_x0 psl_y0 T		% Rotate the coordinate system to follow baseline text and make (psl_x0,psl_y0) the new origin
  psl_xL psl_yd M					% LL anchor point for rounded box is on lower left side just before rounded corner
  psl_xL psl_yT psl_xR psl_yT psl_BoxR arct psl_W2 0 D	% Draw UL rounded corner and line to start of UR rounded corner
  psl_xR psl_yT psl_xR psl_yB psl_BoxR arct 0 psl_H2 neg D	% Draw UR rounded corner and line to LR rounded corner
  psl_xR psl_yB psl_xL psl_yB psl_BoxR arct psl_W2 neg 0 D	% Draw LR rounded corner and line to LL rounded corner
  psl_xL psl_yB psl_xL psl_yd psl_BoxR arct P			% Draw LL rounded corner and close the clippath segment
  psl_x0 neg psl_y0 neg T psl_angle neg R psl_xp neg psl_yp neg T	% Unto trans/rot above
} def

/PSL_ST_place_label	% Just place the current label
{
    V psl_xp psl_yp T psl_angle R	% Set origin at text point and rotate the coordinate system to follow baseline text
    psl_SW PSL_justx mul psl_y0 M	% Goto LL point on label
    psl_label dup sd neg 0 exch G show	% Place the text, adjust vertically for any depth below baseline
    U					% Undo damage to coordinate system
} def

/PSL_nclip 0 def							% The depth of clipping in effect
/PSL_clip {clip /PSL_nclip PSL_nclip 1 add def} def			% Clip and update PSL_nclip
/PSL_eoclip {eoclip /PSL_nclip PSL_nclip 1 add def} def			% Even-odd clip and update PSL_nclip
/PSL_cliprestore {cliprestore /PSL_nclip PSL_nclip 1 sub def} def	% Cliprestore and update PSL_nclip

%%EndProlog

%%BeginSetup
/PSLevel /languagelevel where {pop languagelevel} {1} ifelse def
PSLevel 1 gt { << /WhiteIsOpaque true >> setpagedevice } if
PSLevel 1 gt { << /PageSize [612 792] /ImagingBBox null >> setpagedevice } if
%%EndSetup

%%Page: 1 1

%%BeginPageSetup
%
% Init coordinate system and scales
%
%
% Scale initialized to 0.06, so 1 inch equals 1200 Postscript units
%
V 0.06 0.06 scale
%%EndPageSetup

%
% End of PSL header
%
/PSL_page_xsize 10200 def
/PSL_page_ysize 13200 def
/PSL_plot_completion {} def
/PSL_movie_label_completion {} def
/PSL_movie_prog_indicator_completion {} def
%PSL_End_Header
gsave
0 A
FQ
O0
% Set plot origin:
1200 1200 TM

% PostScript produced by:
%@GMT: gmt psxy -R-5/185/-1/6 -JX6i/9i -P -B0 -W1p,red -Sqn2:+v+f12p+Lh+p0.25p,blue data.txt --PS_COMMENTS=true
%@PROJ: xy -5.00000000 185.00000000 -1.00000000 6.00000000 -5.000 185.000 -1.000 6.000 +xy
%GMTBoundingBox: 72 72 432 648
%%BeginObject PSL_Layer_1
0 setlinecap
0 setlinejoin
3.32550952342 setmiterlimit
25 W
%
% Start of basemap
%
%
% Map boundaries
%
/PSL_slant_y 0 def
2 setlinecap
%
% Start of left y-axis
%
%
% Axis tick marks and annotations
%
N 0 10800 M 0 -10800 D S
/PSL_A0_y 0 def
/PSL_A1_y 0 def
/PSL_LH 0 def /PSL_L_y PSL_A0_y PSL_A1_y mx def
%
% End of left y-axis
%
%
% Start of right y-axis
%
7200 0 T
%
% Axis tick marks and annotations
%
N 0 10800 M 0 -10800 D S
/PSL_A0_y 0 def
/PSL_A1_y 0 def
/PSL_LH 0 def /PSL_L_y PSL_A0_y PSL_A1_y mx def
%
% End of right y-axis
%
-7200 0 T
%
% Start of lower x-axis
%
%
% Axis tick marks and annotations
%
N 0 0 M 7200 0 D S
/PSL_A0_y 0 def
/PSL_A1_y 0 def
/PSL_LH 0 def /PSL_L_y PSL_A0_y PSL_A1_y mx def
%
% End of lower x-axis
%
%
% Start of upper x-axis
%
0 10800 T
%
% Axis tick marks and annotations
%
N 0 0 M 7200 0 D S
/PSL_A0_y 0 def
/PSL_A1_y 0 def
/PSL_LH 0 def /PSL_L_y PSL_A0_y PSL_A1_y mx def
%
% End of upper x-axis
%
0 -10800 T
0 setlinecap
%
% End of basemap
%
%
% Activate Map clip path
%
%
% Start of polygon clip path
%
clipsave
0 0 M
7200 0 D
0 10800 D
-7200 0 D
P
PSL_clip N
%
% End of polygon clip path.  Polygon clipping is currently ON
%
%
% Segment header: -L"The first curve"
%
%
% Segment header: -L"The second curve"
%
%
% Segment header: -L"The third curve"
%
%
% Deactivate Map clip path
%
PSL_cliprestore
%
% Clipping reduced by 1 level
%
V
%
% Store path and label attributes:
%
%
% Pen and fill for text boxes (if enabled):
%
/PSL_setboxpen {4 W 0 0 1 C [] 0 B} def
/PSL_setboxrgb {1 A} def
%
% Store pens used for each line segment:
%
/PSL_path_pen [
PSL_font_encode 0 get 0 eq {Standard+_Encoding /Helvetica /Helvetica PSL_reencode PSL_font_encode 0 1 put} if	% Set this font
	(17 W 1 0 0 C \[\] 0 B)
	(17 W 1 0 0 C \[\] 0 B)
	(17 W 1 0 0 C \[\] 0 B)
] def
%
% Store text justification for each text label:
%
/PSL_label_justify [ 6 6 6 6 6 6 ] def
%
% Store font setting for each text label:
%
/PSL_label_font [
	(0 A 200 F0)
	(0 A 200 F0)
	(0 A 200 F0)
	(0 A 200 F0)
	(0 A 200 F0)
	(0 A 200 F0)
] def
%
% Set constants for textbox clearance:
%
/PSL_gap_x 30 def
/PSL_gap_y 30 def
%
% Set concatenated coordinate arrays for line segments:
%
/PSL_path_x [ 189.5 227.4 265.3 303.2 341.1 378.9 416.8 454.7 492.6 530.5 
	568.4 606.3 644.2 682.1 720 757.9 795.8 833.7 871.6 909.5 
	947.4 985.3 1023.2 1061.1 1098.9 1136.8 1174.7 1212.6 1250.5 1288.4 
	1326.3 1364.2 1402.1 1440 1477.9 1515.8 1553.7 1591.6 1629.5 1667.4 
	1705.3 1743.2 1781.1 1818.9 1856.8 1894.7 1932.6 1970.5 2008.4 2046.3 
	2084.2 2122.1 2160 2197.9 2235.8 2273.7 2311.6 2349.5 2362 2387.4 
	2425.3 2463.2 2501.1 2538.9 2576.8 2614.7 2652.6 2690.5 2728.4 2766.3 
	2804.2 2842.1 2880 2917.9 2955.8 2993.7 3031.6 3069.5 3107.4 3145.3 
	3183.2 3221.1 3258.9 3296.8 3334.7 3372.6 3410.5 3448.4 3486.3 3524.2 
	3562.1 3600 3637.9 3675.8 3713.7 3751.6 3789.5 3827.4 3865.3 3903.2 
	3941.1 3978.9 4016.8 4054.7 4092.6 4130.5 4168.4 4206.3 4244.2 4282.1 
	4320 4357.9 4395.8 4433.7 4471.6 4509.5 4547.4 4585.3 4623.2 4661.1 
	4698.9 4736.8 4774.7 4812.6 4838 4850.5 4888.4 4926.3 4964.2 5002.1 
	5040 5077.9 5115.8 5153.7 5191.6 5229.5 5267.4 5305.3 5343.2 5381.1 
	5418.9 5456.8 5494.7 5532.6 5570.5 5608.4 5646.3 5684.2 5722.1 5760 
	5797.9 5835.8 5873.7 5911.6 5949.5 5987.4 6025.3 6063.2 6101.1 6138.9 
	6176.8 6214.7 6252.6 6290.5 6328.4 6366.3 6404.2 6442.1 6480 6517.9 
	6555.8 6593.7 6631.6 6669.5 6707.4 6745.3 6783.2 6821.1 6858.9 6896.8 
	6934.7 6972.6 7010.5 189.5 227.4 265.3 303.2 341.1 378.9 416.8 
	454.7 492.6 530.5 568.4 606.3 644.2 682.1 720 757.9 795.8 
	833.7 871.6 909.5 947.4 985.3 1023.2 1061.1 1098.9 1136.8 1174.7 
	1212.6 1250.5 1288.4 1326.3 1364.2 1402.1 1440 1477.9 1515.8 1553.7 
	1591.6 1629.5 1667.4 1705.3 1743.2 1781.1 1818.9 1856.8 1894.7 1932.6 
	1970.5 2008.4 2046.3 2084.2 2122.1 2160 2197.9 2235.8 2273.7 2311.6 
	2349.5 2362 2387.4 2425.3 2463.2 2501.1 2538.9 2576.8 2614.7 2652.6 
	2690.5 2728.4 2766.3 2804.2 2842.1 2880 2917.9 2955.8 2993.7 3031.6 
	3069.5 3107.4 3145.3 3183.2 3221.1 3258.9 3296.8 3334.7 3372.6 3410.5 
	3448.4 3486.3 3524.2 3562.1 3600 3637.9 3675.8 3713.7 3751.6 3789.5 
	3827.4 3865.3 3903.2 3941.1 3978.9 4016.8 4054.7 4092.6 4130.5 4168.4 
	4206.3 4244.2 4282.1 4320 4357.9 4395.8 4433.7 4471.6 4509.5 4547.4 
	4585.3 4623.2 4661.1 4698.9 4736.8 4774.7 4812.6 4838 4850.5 4888.4 
	4926.3 4964.2 5002.1 5040 5077.9 5115.8 5153.7 5191.6 5229.5 5267.4 
	5305.3 5343.2 5381.1 5418.9 5456.8 5494.7 5532.6 5570.5 5608.4 5646.3 
	5684.2 5722.1 5760 5797.9 5835.8 5873.7 5911.6 5949.5 5987.4 6025.3 
	6063.2 6101.1 6138.9 6176.8 6214.7 6252.6 6290.5 6328.4 6366.3 6404.2 
	6442.1 6480 6517.9 6555.8 6593.7 6631.6 6669.5 6707.4 6745.3 6783.2 
	6821.1 6858.9 6896.8 6934.7 6972.6 7010.5 189.5 227.4 265.3 303.2 
	341.1 378.9 416.8 454.7 492.6 530.5 568.4 606.3 644.2 682.1 
	720 757.9 795.8 833.7 871.6 909.5 947.4 985.3 1023.2 1061.1 
	1098.9 1136.8 1174.7 1212.6 1250.5 1288.4 1326.3 1364.2 1402.1 1440 
	1477.9 1515.8 1553.7 1591.6 1629.5 1667.4 1705.3 1743.2 1781.1 1818.9 
	1856.8 1894.7 1932.6 1970.5 2008.4 2046.3 2084.2 2122.1 2160 2197.9 
	2235.8 2273.7 2311.6 2349.5 2362 2387.4 2425.3 2463.2 2501.1 2538.9 
	2576.8 2614.7 2652.6 2690.5 2728.4 2766.3 2804.2 2842.1 2880 2917.9 
	2955.8 2993.7 3031.6 3069.5 3107.4 3145.3 3183.2 3221.1 3258.9 3296.8 
	3334.7 3372.6 3410.5 3448.4 3486.3 3524.2 3562.1 3600 3637.9 3675.8 
	3713.7 3751.6 3789.5 3827.4 3865.3 3903.2 3941.1 3978.9 4016.8 4054.7 
	4092.6 4130.5 4168.4 4206.3 4244.2 4282.1 4320 4357.9 4395.8 4433.7 
	4471.6 4509.5 4547.4 4585.3 4623.2 4661.1 4698.9 4736.8 4774.7 4812.6 
	4838 4850.5 4888.4 4926.3 4964.2 5002.1 5040 5077.9 5115.8 5153.7 
	5191.6 5229.5 5267.4 5305.3 5343.2 5381.1 5418.9 5456.8 5494.7 5532.6 
	5570.5 5608.4 5646.3 5684.2 5722.1 5760 5797.9 5835.8 5873.7 5911.6 
	5949.5 5987.4 6025.3 6063.2 6101.1 6138.9 6176.8 6214.7 6252.6 6290.5 
	6328.4 6366.3 6404.2 6442.1 6480 6517.9 6555.8 6593.7 6631.6 6669.5 
	6707.4 6745.3 6783.2 6821.1 6858.9 6896.8 6934.7 6972.6 7010.5 ] def
/PSL_path_y [ 1542.9 1569.8 1596.7 1623.6 1650.5 1677.3 1704.1 1730.9 1757.6 1784.2 
	1810.8 1837.2 1863.6 1889.9 1916.1 1942.2 1968.1 1993.9 2019.6 2045.2 
	2070.5 2095.8 2120.8 2145.7 2170.4 2194.9 2219.2 2243.3 2267.2 2290.8 
	2314.3 2337.5 2360.4 2383.2 2405.6 2427.8 2449.7 2471.4 2492.7 2513.8 
	2534.6 2555.1 2575.2 2595.1 2614.6 2633.8 2652.7 2671.2 2689.4 2707.3 
	2724.8 2741.9 2758.6 2775 2791.1 2806.7 2821.9 2836.8 2841.6 2851.3 
	2865.3 2879 2892.3 2905.1 2917.6 2929.6 2941.2 2952.3 2963.1 2973.4 
	2983.2 2992.7 3001.7 3010.2 3018.3 3025.9 3033.1 3039.9 3046.2 3052 
	3057.4 3062.3 3066.7 3070.7 3074.2 3077.3 3079.8 3082 3083.6 3084.8 
	3085.5 3085.7 3085.5 3084.8 3083.6 3082 3079.8 3077.3 3074.2 3070.7 
	3066.7 3062.3 3057.4 3052 3046.2 3039.9 3033.1 3025.9 3018.3 3010.2 
	3001.7 2992.7 2983.2 2973.4 2963.1 2952.3 2941.2 2929.6 2917.6 2905.1 
	2892.3 2879 2865.3 2851.3 2841.6 2836.8 2821.9 2806.7 2791.1 2775 
	2758.6 2741.9 2724.8 2707.3 2689.4 2671.2 2652.7 2633.8 2614.6 2595.1 
	2575.2 2555.1 2534.6 2513.8 2492.7 2471.4 2449.7 2427.8 2405.6 2383.2 
	2360.4 2337.5 2314.3 2290.8 2267.2 2243.3 2219.2 2194.9 2170.4 2145.7 
	2120.8 2095.8 2070.5 2045.2 2019.6 1993.9 1968.1 1942.2 1916.1 1889.9 
	1863.6 1837.2 1810.8 1784.2 1757.6 1730.9 1704.1 1677.3 1650.5 1623.6 
	1596.7 1569.8 1542.9 4628.6 4655.5 4682.4 4709.3 4736.2 4763 4789.8 
	4816.6 4843.3 4869.9 4896.5 4923 4949.3 4975.6 5001.8 5027.9 5053.8 
	5079.7 5105.3 5130.9 5156.3 5181.5 5206.5 5231.4 5256.1 5280.6 5304.9 
	5329 5352.9 5376.6 5400 5423.2 5446.2 5468.9 5491.3 5513.5 5535.4 
	5557.1 5578.4 5599.5 5620.3 5640.8 5660.9 5680.8 5700.3 5719.5 5738.4 
	5756.9 5775.1 5793 5810.5 5827.6 5844.4 5860.8 5876.8 5892.4 5907.7 
	5922.5 5927.3 5937 5951.1 5964.7 5978 5990.8 6003.3 6015.3 6026.9 
	6038 6048.8 6059.1 6069 6078.4 6087.4 6095.9 6104 6111.7 6118.9 
	6125.6 6131.9 6137.7 6143.1 6148 6152.4 6156.4 6159.9 6163 6165.6 
	6167.7 6169.3 6170.5 6171.2 6171.4 6171.2 6170.5 6169.3 6167.7 6165.6 
	6163 6159.9 6156.4 6152.4 6148 6143.1 6137.7 6131.9 6125.6 6118.9 
	6111.7 6104 6095.9 6087.4 6078.4 6069 6059.1 6048.8 6038 6026.9 
	6015.3 6003.3 5990.8 5978 5964.7 5951.1 5937 5927.3 5922.5 5907.7 
	5892.4 5876.8 5860.8 5844.4 5827.6 5810.5 5793 5775.1 5756.9 5738.4 
	5719.5 5700.3 5680.8 5660.9 5640.8 5620.3 5599.5 5578.4 5557.1 5535.4 
	5513.5 5491.3 5468.9 5446.2 5423.2 5400 5376.6 5352.9 5329 5304.9 
	5280.6 5256.1 5231.4 5206.5 5181.5 5156.3 5130.9 5105.3 5079.7 5053.8 
	5027.9 5001.8 4975.6 4949.3 4923 4896.5 4869.9 4843.3 4816.6 4789.8 
	4763 4736.2 4709.3 4682.4 4655.5 4628.6 7714.3 7741.2 7768.1 7795 
	7821.9 7848.8 7875.6 7902.3 7929 7955.6 7982.2 8008.7 8035.1 8061.4 
	8087.5 8113.6 8139.6 8165.4 8191.1 8216.6 8242 8267.2 8292.3 8317.1 
	8341.8 8366.3 8390.6 8414.7 8438.6 8462.3 8485.7 8508.9 8531.9 8554.6 
	8577 8599.2 8621.2 8642.8 8664.2 8685.2 8706 8726.5 8746.7 8766.5 
	8786 8805.3 8824.1 8842.7 8860.9 8878.7 8896.2 8913.3 8930.1 8946.5 
	8962.5 8978.1 8993.4 9008.2 9013 9022.7 9036.8 9050.4 9063.7 9076.5 
	9089 9101 9112.6 9123.8 9134.5 9144.8 9154.7 9164.1 9173.1 9181.6 
	9189.7 9197.4 9204.6 9211.3 9217.6 9223.4 9228.8 9233.7 9238.1 9242.1 
	9245.6 9248.7 9251.3 9253.4 9255 9256.2 9256.9 9257.1 9256.9 9256.2 
	9255 9253.4 9251.3 9248.7 9245.6 9242.1 9238.1 9233.7 9228.8 9223.4 
	9217.6 9211.3 9204.6 9197.4 9189.7 9181.6 9173.1 9164.1 9154.7 9144.8 
	9134.5 9123.8 9112.6 9101 9089 9076.5 9063.7 9050.4 9036.8 9022.7 
	9013 9008.2 8993.4 8978.1 8962.5 8946.5 8930.1 8913.3 8896.2 8878.7 
	8860.9 8842.7 8824.1 8805.3 8786 8766.5 8746.7 8726.5 8706 8685.2 
	8664.2 8642.8 8621.2 8599.2 8577 8554.6 8531.9 8508.9 8485.7 8462.3 
	8438.6 8414.7 8390.6 8366.3 8341.8 8317.1 8292.3 8267.2 8242 8216.6 
	8191.1 8165.4 8139.6 8113.6 8087.5 8061.4 8035.1 8008.7 7982.2 7955.6 
	7929 7902.3 7875.6 7848.8 7821.9 7795 7768.1 7741.2 7714.3 ] def
%
% Set array with number of points per line segments:
%
/PSL_path_n [ 183 183 183 ] def
%
% Set array with nodes of PSL_path_x|y for text placement:
%
/PSL_label_node [ 58 124 58 124 58 124 ] def
%
% Set array with number of labels per line segment:
%
/PSL_label_n [ 2 2 2 ] def
%
% Set array with baseline angle for each text label:
%
/PSL_label_angle [ 20.84 339.16 20.84 339.16 20.84 339.16 ] def
%
% Set array with the text labels:
%
/PSL_label_str [
	(The first curve)
	(The first curve)
	(The second curve)
	(The second curve)
	(The third curve)
	(The third curve)
] def
/PSL_label_n [ 2 2 2 ] def
/PSL_n_paths 3 def
/PSL_n_labels 6 def
%
% Estimate text heights:
%
PSL_set_label_heights
%
% Display the texts:
%
258 PSL_curved_path_labels
%
% Set up text clippath and turn clipping ON:
%
V
260 PSL_curved_path_labels
%
% Draw the text line segments:
%
PSL_draw_path_lines N
%
% Turn label clipping OFF:
%
PSL_cliprestore
%
% Clipping reduced by 1 level
%
U
[] 0 B
U
%%EndObject

grestore
%
% Run PSL movie label completion function, if defined
%
PSL_movie_label_completion /PSL_movie_label_completion {} def
%
% Run PSL movie progress indicator completion function, if defined
%
PSL_movie_prog_indicator_completion /PSL_movie_prog_indicator_completion {} def
%PSL_Begin_Trailer
%%PageTrailer
%
% Reset transformations and call showpage
%
U
showpage

%%Trailer

end
%%EOF
