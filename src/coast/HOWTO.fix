	$Id: HOWTO.fix,v 1.1 2004-09-05 04:19:26 pwessel Exp $
	
How to fix mistakes in the GSHHS database

This section describes the specific actions taken to fix portions of the
Puget Sound, including islands, lakes, and coastline.
This brought the polygon database from v3.3_final_dbase.b to the latest
v3.4_final_dbase.b.  herein I call the old dbase for OLD.B and the final
new one for NEW.b.

Background: Steve Malone, UWash, provided updated files for a portion of
the coastline near Tacoma, as well as polygons for several islands and
lakes in the region that were either completely in error (islands appearing
as lakes because coastline was wrong) or of very poor quality (Mercer Isl).

Steps taken:

1. Prepare the new polygons so that there are no headers.  Then, plot with the
   arrow.sh script (e.g. arrow.sh polygon.d n (n may be 3-9 range) and determine
   if the handedness is correct.  Looking down arrow, land must be on the left
   side.  If it is not, run reverse.sh polygon.d
2. Identify the IDs of the polygons in the binary database (OLD.b) using
   polygon_id OLD.b lon lat  where lon lat is a point on or very close to the
   polygon boundary of a polygon to identify.  Place the IDs of polygons that
   you want to replace in the file del.lis.  Polygons that you will edit and
   update (in this case the North America coastline polygon, ID = 1): place
   their IDs in the file fix.lis.
3. Identify the starting point on the line segment you want to insert into the
   coastline (note it must also be oriented correctly first; see step 1) and
   write down the lon, lat.  Now find the line number in the coastline that is
   closest to that point using
   
   mapproject polygon.1 -G237.59/47.6745 | awk '{if ($3 < 200) print NR, $0}'

   This will echo out all points within 200 m of the given coordinate in -G.
   Edit polygon.1, goto the line in question.  Then, use zoom.sh to make a
   plot of the area that shows each point as a dot.  Visually identify which
   points to replace and where to insert the new segment, and then identify
   those points in the polygon.1 file.  Remove & insert accordingly, and save
   polygon.1.  Now move polygon.1 to the sub-directory pol.
4. Run polygon_update OLD.b del.lis fix.lis UPDATED.b
   This will be an intermediate database which lacks the deleted features.
   We need to replace those with the new polygon lakes and islands.
5. Call all the polygon files for new lakes Lakes_#.d (# = increasing number)
   and the same thing for Island_#.d.  Convert to a single binary segment file:
   	polygon_restore -L1 Islands_*.d > new_island_seg.b
   	polygon_restore -L2 Lakes_*.d > new_lakes_seg.b
   then add them into one file:
   	cat new_island_seg.b new_lakes_seg.b > new_segments.b
6. Convert from segment format to polygon format:
	segment_final_dump new_egments.b new_polygons.b
7. Combine UPDATED.b with these new polygons, sorting them according to size:
	polygon_sort UPDATED.b new_polygons.b NEW.b
   This is the final, corrected polygon database.
   
UPDATE: Old email suggested there are still crossovers in the full polygon file.
I wrote polygon_consistency.c to check for that and for lack of closure.  Found
40 polygons with crossings and ~50 with no closure.  Used polygon_extract to
pull out those polygons with xings into pol/, and then used the view.sh script
there to aid in finding the problems.  cross.lis has cross list and close.lis
had all those that did not close. With cat close.lis cross.lis > fix.lis, we now
must again run 
polygon_update NEW.b /dev/null fix.lis FINAL.b

8. Now you must calculate new node levels [this takes 30-45 min at home]:
	polygon_setnodes FINAL.b 1 newnodes.grd
	(see nodes_job.csh)
9. Do the binning:
	polygon_to_bins FINAL.b newnodes.grd binned_GSHHS_f
10. and reformat to netcdf:
	shoremaker binned_GSHHS_f
	(see bin_job.csh)
For the lower resolutions you need to use the DP algorithm to get decimated
databases (see shrink_job.csh) and then repeat steps 8-10.
	
   
