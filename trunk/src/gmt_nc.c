/*--------------------------------------------------------------------
 *	$Id$
 *
 *	Copyright (c) 1991-2012 by P. Wessel, W. H. F. Smith, R. Scharroo, J. Luis and F. Wobbe
 *	See LICENSE.TXT file for copying and redistribution conditions.
 *
 *	This program is free software; you can redistribute it and/or modify
 *	it under the terms of the GNU Lesser General Public License as published by
 *	the Free Software Foundation; version 3 or any later version.
 *
 *	This program is distributed in the hope that it will be useful,
 *	but WITHOUT ANY WARRANTY; without even the implied warranty of
 *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *	GNU Lesser General Public License for more details.
 *
 *	Contact info: gmt.soest.hawaii.edu
 *--------------------------------------------------------------------*/
/*
 *
 *	G M T _ N C . C   R O U T I N E S
 *
 * Takes care of all grd input/output built on NCAR's NetCDF routines.
 * This version is intended to provide more general support for reading
 * NetCDF files that were not generated by GMT. At the same time, the grids
 * written by these routines are intended to be more conform COARDS conventions.
 * These routines are to eventually replace the older gmt_cdf_ routines.
 *
 * Most functions will return with error message if an internal error is returned.
 * There functions are only called indirectly via the GMT_* grdio functions.
 *
 * Author:  Remko Scharroo
 * Date:    04-AUG-2005
 * Version: 1
 *
 * Added support for chunked I/O, Florian Wobbe, June 2012.
 *
 * Functions include:
 *
 *  GMT_nc_read_grd_info:   Read header from file
 *  GMT_nc_read_grd:        Read data set from file
 *  GMT_nc_update_grd_info: Update header in existing file
 *  GMT_nc_write_grd_info:  Write header to new file
 *  GMT_nc_write_grd:       Write header and data set to new file
 *
 * Private functions:
 *  setup_chunk_cache:      Change the default HDF5 chunk cache settings
 *  pad_grid:               Add padding to a grid
 *  unpad_grid:             Remove padding from a grid
 *  padding_copy:           Fill padding by replicating the border cells
 *  padding_zero:           Fill padding with zeros
 *  grid_flip_vertical      Reverses the grid vertically
 *  n_chunked_rows_in_cache Determines how many chunks to read at once
 *  io_nc_grid              Does the actual netcdf I/O
 *
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

#define GMT_WITH_NO_PS
#include "gmt.h"
#include "gmt_internals.h"

/* HDF5 chunk cache: reasonable defaults assuming min. chunk size of 128x128 and type byte */
#define NC_CACHE_SIZE       33554432 /* 32MiB */
#define NC_CACHE_NELEMS     2053     /* prime > NC_CACHE_SIZE / (128*128*1byte) */
#define NC_CACHE_PREEMPTION 0.75

int gmt_cdf_grd_info (struct GMT_CTRL *C, int ncid, struct GRD_HEADER *header, char job);
int GMT_cdf_read_grd (struct GMT_CTRL *C, struct GRD_HEADER *header, float *grid, double wesn[], unsigned int *pad, unsigned int complex_mode);

int GMT_is_nc_grid (struct GMT_CTRL *C, struct GRD_HEADER *header)
{	/* Returns type GMT_GRD_IS_N? (=n?) for new NetCDF grid,
	   type GMT_GRD_IS_C? (=c?) for old NetCDF grids and -1 upon error */
	int ncid, z_id = -1, j = 0, nvars, ndims, err, old = false;
	nc_type z_type;
	char varname[GRD_VARNAME_LEN80];

	/* Extract levels name from variable name */
	strcpy (varname, header->varname);
	if (varname[0]) {
		j = 0;
		while (varname[j] && varname[j] != '[' && varname[j] != '(') j++;
		if (varname[j]) varname[j] = '\0';
	}
	if (!strcmp (header->name, "=")) return (GMT_GRDIO_NC_NO_PIPE);

	/* Open the file and look for the required variable */
	if (GMT_access (C, header->name, F_OK)) return (GMT_GRDIO_FILE_NOT_FOUND);
	if (nc_open (header->name, NC_NOWRITE, &ncid)) return (GMT_GRDIO_OPEN_FAILED);
	if (!nc_inq_dimid (ncid, "xysize", &z_id)) {	/* Old style GMT netCDF grid */
		old = true;
		if (nc_inq_varid (ncid, "z", &z_id)) return (GMT_GRDIO_NO_VAR);
	}
	else if (varname[0]) {	/* ?<varname> used */
		if (nc_inq_varid (ncid, varname, &z_id)) return (GMT_GRDIO_NO_VAR);
	}
	else {			/* Look for first 2D grid */
		nc_inq_nvars (ncid, &nvars);
		for (j = 0; j < nvars && z_id < 0; j++) {
			GMT_err_trap (nc_inq_varndims (ncid, j, &ndims));
			if (ndims == 2) z_id = j;
		}
		if (z_id < 0) return (GMT_GRDIO_NO_2DVAR);
	}

	GMT_err_trap (nc_inq_vartype (ncid, z_id, &z_type));
	switch (z_type) {
		case NC_BYTE:	header->type = old ? GMT_GRD_IS_CB : GMT_GRD_IS_NB; break;
		case NC_SHORT:	header->type = old ? GMT_GRD_IS_CS : GMT_GRD_IS_NS; break;
		case NC_INT:	header->type = old ? GMT_GRD_IS_CI : GMT_GRD_IS_NI; break;
		case NC_FLOAT:	header->type = old ? GMT_GRD_IS_CF : GMT_GRD_IS_NF; break;
		case NC_DOUBLE:	header->type = old ? GMT_GRD_IS_CD : GMT_GRD_IS_ND; break;
		default:		header->type = GMT_GRDIO_UNKNOWN_TYPE; break;
	}
	nc_close (ncid);
	return (header->type);
}

void gmt_nc_get_units (struct GMT_CTRL *C, int ncid, int varid, char *name_units)
{	/* Get attributes long_name and units for given variable ID
	 * and assign variable name if attributes are not available.
	 * ncid, varid		: as in nc_get_att_text
	 * nameunit		: long_name and units in form "long_name [units]"
	 */
	char name[GRD_UNIT_LEN80], units[GRD_UNIT_LEN80];
	if (GMT_nc_get_att_text (C, ncid, varid, "long_name", name, GRD_UNIT_LEN80))
		nc_inq_varname (ncid, varid, name);
	if (!GMT_nc_get_att_text (C, ncid, varid, "units", units, GRD_UNIT_LEN80) && units[0])
		sprintf (name_units, "%s [%s]", name, units);
	else
		strcpy (name_units, name);
}

void gmt_nc_put_units (int ncid, int varid, char *name_units)
{	/* Put attributes long_name and units for given variable ID based on
	 * string name_unit in the form "long_name [units]".
	 * ncid, varid		: as is nc_put_att_text
	 * name_units		: string in form "long_name [units]"
	 */
	int i = 0;
	char name[GRD_UNIT_LEN80], units[GRD_UNIT_LEN80];

	strcpy (name, name_units);
	units[0] = '\0';
	while (name[i] && name[i] != '[') i++;
	if (name[i]) {
		strcpy (units, &name[i+1]);
		name[i] = '\0';
		if (name[i-1] == ' ') name[i-1] = '\0';
	}
	i = 0;
	while (units[i] && units[i] != ']') i++;
	if (units[i]) units[i] = '\0';
	if (name[0]) nc_put_att_text (ncid, varid, "long_name", strlen(name), name);
	if (units[0]) nc_put_att_text (ncid, varid, "units", strlen(units), units);
}

void gmt_nc_check_step (struct GMT_CTRL *C, int n, double *x, char *varname, char *file)
{	/* Check if all steps in range are the same (within 2%) */
	double step, step_min, step_max;
	int i;
	if (n < 2) return;
	step_min = step_max = x[1]-x[0];
	for (i = 2; i < n; i++) {
		step = x[i]-x[i-1];
		if (step < step_min) step_min = step;
		if (step > step_max) step_max = step;
	}
	if (fabs (step_min-step_max)/(fabs (step_min)+fabs (step_max)) > 0.05) {
		GMT_report (C, GMT_MSG_FATAL, "Warning: The step size of coordinate (%s) in grid %s is not constant.\n", varname, file);
		GMT_report (C, GMT_MSG_FATAL, "Warning: GMT will use a constant step size of %g; the original ranges from %g to %g.\n", (x[n-1]-x[0])/(n-1), step_min, step_max);
	}
}

int gmt_nc_grd_info (struct GMT_CTRL *C, struct GRD_HEADER *header, char job)
{
	int j, err;
	int old_fill_mode;
	double dummy[2], *xy = NULL;
	char dimname[GRD_UNIT_LEN80], coord[8];
	nc_type z_type;
	double t_value[3];

	/* Dimension ids, variable ids, etc.. */
	int i, ncid, z_id = -1, ids[5] = {-1,-1,-1,-1,-1}, dims[5], nvars, ndims = 0;
	size_t lens[5], item[2];

	for (i = 0; i < 3; i++) t_value[i] = C->session.d_NaN;

	/* If not yet determined, attempt to get the layer IDs from the variable name */

	if (header->t_index[0] >= 0) { /* Do nothing: already determined */ }
	else if (!header->varname[0])
		header->t_index[0] = 0;	/* No varname: use first layer */
	else {
		i = 0;
		while (header->varname[i] && header->varname[i] != '(' && header->varname[i] != '[') i++;
		if (header->varname[i] == '(') {
			sscanf (&header->varname[i+1], "%lf,%lf,%lf)", &t_value[0], &t_value[1], &t_value[2]);
			header->varname[i] = '\0';
		}
		else if (header->varname[i] == '[') {
			sscanf (&header->varname[i+1], "%d,%d,%d]", &header->t_index[0], &header->t_index[1], &header->t_index[2]);
			header->varname[i] = '\0';
		}
	}

	/* Open NetCDF file */

	if (!strcmp (header->name,"=")) return (GMT_GRDIO_NC_NO_PIPE);
	switch (job) {
		case 'r':
			GMT_err_trap (nc_open (header->name, NC_NOWRITE, &ncid));
			break;
		case 'u':
			GMT_err_trap (nc_open (header->name, NC_WRITE, &ncid));
			GMT_err_trap (nc_set_fill (ncid, NC_NOFILL, &old_fill_mode));
			break;
		default:
			if (C->current.setting.io_nc4_chunksize[0] != 0 &&
					C->current.setting.io_nc4_chunksize[1] != 0 &&
					header->ny >= C->current.setting.io_nc4_chunksize[0] &&
					header->nx >= C->current.setting.io_nc4_chunksize[1]) {
				GMT_err_trap (nc_create (header->name, NC_NETCDF4, &ncid));
			}
			else {
				GMT_err_trap (nc_create (header->name, NC_CLOBBER, &ncid));
			}
			GMT_err_trap (nc_set_fill (ncid, NC_NOFILL, &old_fill_mode));
			break;
	}

	/* Retrieve or define dimensions and variables */

	if (job == 'r' || job == 'u') {
		/* First see if this is an old NetCDF formatted file */
		if (!nc_inq_dimid (ncid, "xysize", &i)) return (gmt_cdf_grd_info (C, ncid, header, job));

		/* Find first 2-dimensional (z) variable or specified variable */
		if (!header->varname[0]) {
			GMT_err_trap (nc_inq_nvars (ncid, &nvars));
			i = 0;
			while (i < nvars && z_id < 0) {
				GMT_err_trap (nc_inq_varndims (ncid, i, &ndims));
				if (ndims == 2) z_id = i;
				i++;
			}
		}
		else if (nc_inq_varid (ncid, header->varname, &z_id) == NC_NOERR) {
			GMT_err_trap (nc_inq_varndims (ncid, z_id, &ndims));
			if (ndims < 2 || ndims > 5) return (GMT_GRDIO_BAD_DIM);
		}
		else
			return (GMT_GRDIO_NO_VAR);
		if (z_id < 0) return (GMT_GRDIO_NO_2DVAR);

		/* Get the z data type and determine its dimensions */
		GMT_err_trap (nc_inq_vartype (ncid, z_id, &z_type));
		GMT_err_trap (nc_inq_vardimid (ncid, z_id, dims));
		switch (z_type) {
			case NC_BYTE:	header->type = GMT_GRD_IS_NB; break;
			case NC_SHORT:	header->type = GMT_GRD_IS_NS; break;
			case NC_INT:	header->type = GMT_GRD_IS_NI; break;
			case NC_FLOAT:	header->type = GMT_GRD_IS_NF; break;
			case NC_DOUBLE:	header->type = GMT_GRD_IS_ND; break;
			default:		header->type = GMT_GRDIO_UNKNOWN_TYPE; break;
		}

		/* Get the ids of the x and y (and depth and time) coordinate variables */
		for (i = 0; i < ndims; i++) {
			GMT_err_trap (nc_inq_dim (ncid, dims[i], dimname, &lens[i]));
			if (nc_inq_varid (ncid, dimname, &ids[i])) ids[i] = -1;
		}
		header->xy_dim[0] = ndims-1;
		header->xy_dim[1] = ndims-2;

		/* Check if LatLon variable exists, then we may need to flip x and y */
		if (nc_inq_varid (ncid, "LatLon", &i) == NC_NOERR) nc_get_var_int (ncid, i, header->xy_dim);
		header->nx = (int) lens[header->xy_dim[0]];
		header->ny = (int) lens[header->xy_dim[1]];
	}
	else {
		/* Define dimensions of z variable */
		ndims = 2;
		header->xy_dim[0] = 1;
		header->xy_dim[1] = 0;

		strcpy (coord, (GMT_x_is_lon (C, GMT_OUT)) ? "lon" : (C->current.io.col_type[GMT_OUT][GMT_X] & GMT_IS_RATIME) ? "time" : "x");
		GMT_err_trap (nc_def_dim (ncid, coord, (size_t) header->nx, &dims[1]));
		GMT_err_trap (nc_def_var (ncid, coord, NC_DOUBLE, 1, &dims[1], &ids[1]));

		strcpy (coord, (GMT_y_is_lat (C, GMT_OUT)) ? "lat" : (C->current.io.col_type[GMT_OUT][GMT_Y] & GMT_IS_RATIME) ? "time" : "y");
		GMT_err_trap (nc_def_dim (ncid, coord, (size_t) header->ny, &dims[0]));
		GMT_err_trap (nc_def_var (ncid, coord, NC_DOUBLE, 1, &dims[0], &ids[0]));

		switch (header->type) {
			case GMT_GRD_IS_NB: z_type = NC_BYTE; break;
			case GMT_GRD_IS_NS: z_type = NC_SHORT; break;
			case GMT_GRD_IS_NI: z_type = NC_INT; break;
			case GMT_GRD_IS_NF: z_type = NC_FLOAT; break;
			case GMT_GRD_IS_ND: z_type = NC_DOUBLE; break;
			default: z_type = NC_NAT;
		}

		/* Variable name is given, or defaults to "z" */
		if (!header->varname[0]) strcpy (header->varname, "z");
		GMT_err_trap (nc_def_var (ncid, header->varname, z_type, 2, dims, &z_id));

		/* set deflation and chunking */
		if (C->current.setting.io_nc4_chunksize[0] != 0 &&
				C->current.setting.io_nc4_chunksize[1] != 0 &&
				header->ny >= C->current.setting.io_nc4_chunksize[0] &&
				header->nx >= C->current.setting.io_nc4_chunksize[1]) {
			/* set chunk size */
			GMT_err_trap (nc_def_var_chunking (ncid, z_id, NC_CHUNKED, C->current.setting.io_nc4_chunksize));
			/* set deflation level for z variable */
			if (C->current.setting.io_nc4_deflation_level)
				GMT_err_trap (nc_def_var_deflate (ncid, z_id, true, true, C->current.setting.io_nc4_deflation_level));
		}
	}
	header->z_id = z_id;
	header->ncid = ncid;

	/* Query or assign attributes */

	if (job == 'u') GMT_err_trap (nc_redef (ncid));

	if (job == 'r') {
		/* Get global information */
		if (GMT_nc_get_att_text (C, ncid, NC_GLOBAL, "title", header->title, GRD_TITLE_LEN80))
		    GMT_nc_get_att_text (C, ncid, z_id, "long_name", header->title, GRD_TITLE_LEN80);
		if (GMT_nc_get_att_text (C, ncid, NC_GLOBAL, "history", header->command, GRD_COMMAND_LEN320))
		    GMT_nc_get_att_text (C, ncid, NC_GLOBAL, "source", header->command, GRD_COMMAND_LEN320);
		GMT_nc_get_att_text (C, ncid, NC_GLOBAL, "description", header->remark, GRD_REMARK_LEN160);

		/* Create enough memory to store the x- and y-coordinate values */
		xy = GMT_memory (C, NULL, MAX(header->nx,header->ny), double);

		/* Get information about x variable */
		gmt_nc_get_units (C, ncid, ids[header->xy_dim[0]], header->x_units);
		if (!(j = nc_get_var_double (ncid, ids[header->xy_dim[0]], xy))) gmt_nc_check_step (C, header->nx, xy, header->x_units, header->name);
		if (!nc_get_att_double (ncid, ids[header->xy_dim[0]], "actual_range", dummy)) {
			header->wesn[XLO] = dummy[0], header->wesn[XHI] = dummy[1];
			header->registration = (!j && 1.0 - (xy[header->nx-1] - xy[0]) / (dummy[1] - dummy[0]) > 0.5 / header->nx) ?  GMT_PIXEL_REG : GMT_GRIDLINE_REG;
		}
		else if (!j) {
			header->wesn[XLO] = xy[0], header->wesn[XHI] = xy[header->nx-1];
			header->registration = GMT_GRIDLINE_REG;
		}
		else {
			header->wesn[XLO] = 0.0, header->wesn[XHI] = (double) header->nx-1;
			header->registration = GMT_GRIDLINE_REG;
		}
		header->inc[GMT_X] = GMT_get_inc (C, header->wesn[XLO], header->wesn[XHI], header->nx, header->registration);
		if (GMT_is_dnan(header->inc[GMT_X])) header->inc[GMT_X] = 1.0;

		/* Get information about y variable */
		gmt_nc_get_units (C, ncid, ids[header->xy_dim[1]], header->y_units);
		if (!(j = nc_get_var_double (ncid, ids[header->xy_dim[1]], xy))) gmt_nc_check_step (C, header->ny, xy, header->y_units, header->name);
		if (!nc_get_att_double (ncid, ids[header->xy_dim[1]], "actual_range", dummy))
			header->wesn[YLO] = dummy[0], header->wesn[YHI] = dummy[1];
		else if (!j)
			header->wesn[YLO] = xy[0], header->wesn[YHI] = xy[header->ny-1];
		else
			header->wesn[YLO] = 0.0, header->wesn[YHI] = (double) header->ny-1;
		/* Check for reverse order of y-coordinate */
		if (header->wesn[YLO] > header->wesn[YHI]) {
			header->y_order = k_nc_start_north;
			dummy[0] = header->wesn[YHI], dummy[1] = header->wesn[YLO];
			header->wesn[YLO] = dummy[0], header->wesn[YHI] = dummy[1];
		}
		else
			header->y_order = k_nc_start_south;
		header->inc[GMT_Y] = GMT_get_inc (C, header->wesn[YLO], header->wesn[YHI], header->ny, header->registration);
		if (GMT_is_dnan(header->inc[GMT_Y])) header->inc[GMT_Y] = 1.0;

		GMT_free (C, xy);

		/* Get information about z variable */
		gmt_nc_get_units (C, ncid, z_id, header->z_units);
		if (nc_get_att_double (ncid, z_id, "scale_factor", &header->z_scale_factor)) header->z_scale_factor = 1.0;
		if (nc_get_att_double (ncid, z_id, "add_offset", &header->z_add_offset)) header->z_add_offset = 0.0;
		if (nc_get_att_double (ncid, z_id, "_FillValue", &header->nan_value))
		    nc_get_att_double (ncid, z_id, "missing_value", &header->nan_value);
		if (!nc_get_att_double (ncid, z_id, "actual_range", dummy)) {
			/* z-limits need to be converted from actual to internal grid units. */
			header->z_min = (dummy[0] - header->z_add_offset) / header->z_scale_factor;
			header->z_max = (dummy[1] - header->z_add_offset) / header->z_scale_factor;
		}
		else if (!nc_get_att_double (ncid, z_id, "valid_range", dummy)) {
			/* Valid range is already in packed units, so do not convert */
			header->z_min = dummy[0], header->z_max = dummy[1];
		}
		{
			/* get deflation and chunking info */
			int storage_mode, shuffle, deflate, deflate_level;
			size_t chunksize[5]; /* chunksize of z */
			GMT_err_trap (nc_inq_var_chunking (ncid, z_id, &storage_mode, chunksize));
			if (storage_mode == NC_CHUNKED) {
				header->z_chunksize[0] = chunksize[dims[0]]; /* chunk size of lat */
				header->z_chunksize[1] = chunksize[dims[1]]; /* chunk size of lon */
			}
			else { /* NC_CONTIGUOUS */
				header->z_chunksize[0] = header->z_chunksize[1] = 0;
			}
			GMT_err_trap (nc_inq_var_deflate (ncid, z_id, &shuffle, &deflate, &deflate_level));
			header->z_shuffle = shuffle ? true : false; /* if shuffle filter is turned on */
			header->z_deflate_level = deflate ? deflate_level : 0; /* if deflate filter is in use */
		}

		/* Get grid buffer */
		item[0] = 0;
		for (i = 0; i < ndims-2; i++) {
			if (header->t_index[i] > -1) { /* Do nothing */ }
			else if (GMT_is_dnan(t_value[i]))
				header->t_index[i] = 0;
			else {
				item[1] = lens[i]-1;
				if (nc_get_att_double (ncid, ids[i], "actual_range", dummy)) {
					GMT_err_trap (nc_get_var1_double (ncid, ids[i], &item[0], &dummy[0]));
					GMT_err_trap (nc_get_var1_double (ncid, ids[i], &item[1], &dummy[1]));
				}
				header->t_index[i] = lrint((t_value[i] - dummy[0]) / (dummy[1] - dummy[0]) * item[1]);
			}
		}
	}
	else {
		/* Store global attributes */
		unsigned int row, col;
		int reg;
		GMT_err_trap (nc_put_att_text (ncid, NC_GLOBAL, "Conventions", strlen(GMT_NC_CONVENTION), (const char *) GMT_NC_CONVENTION));
		if (header->title[0]) {
			GMT_err_trap (nc_put_att_text (ncid, NC_GLOBAL, "title", strlen(header->title), header->title));
		}
		else {
			GMT_err_trap (nc_put_att_text (ncid, NC_GLOBAL, "title", strlen(header->name), header->name));
		}
		if (header->command[0]) GMT_err_trap (nc_put_att_text (ncid, NC_GLOBAL, "history", strlen(header->command), header->command));
		if (header->remark[0]) GMT_err_trap (nc_put_att_text (ncid, NC_GLOBAL, "description", strlen(header->remark), header->remark));
		GMT_err_trap (nc_put_att_text (ncid, NC_GLOBAL, "GMT_version", strlen(GMT_VERSION), (const char *) GMT_VERSION));
		if (header->registration == GMT_PIXEL_REG) {
			reg = header->registration;
			GMT_err_trap (nc_put_att_int (ncid, NC_GLOBAL, "node_offset", NC_LONG, 1U, &reg));
		}
		else
			nc_del_att (ncid, NC_GLOBAL, "node_offset");

		/* Define x variable */
		gmt_nc_put_units (ncid, ids[header->xy_dim[0]], header->x_units);
		dummy[0] = header->wesn[XLO], dummy[1] = header->wesn[XHI];
		GMT_err_trap (nc_put_att_double (ncid, ids[header->xy_dim[0]], "actual_range", NC_DOUBLE, 2U, dummy));

		/* Define y variable */
		gmt_nc_put_units (ncid, ids[header->xy_dim[1]], header->y_units);
		header->y_order = k_nc_start_south;
		dummy[(1-header->y_order)/2] = header->wesn[YLO], dummy[(1+header->y_order)/2] = header->wesn[YHI];
		GMT_err_trap (nc_put_att_double (ncid, ids[header->xy_dim[1]], "actual_range", NC_DOUBLE, 2U, dummy));

		/* When varname is given, and z_units is default, overrule z_units with varname */
		if (header->varname[0] && !strcmp (header->z_units, "z")) strcpy (header->z_units, header->varname);

		/* Define z variable. Attempt to remove "scale_factor" or "add_offset" when no longer needed */
		gmt_nc_put_units (ncid, z_id, header->z_units);
		if (header->z_scale_factor != 1.0) {
			GMT_err_trap (nc_put_att_double (ncid, z_id, "scale_factor", NC_DOUBLE, 1U, &header->z_scale_factor));
		}
		else if (job == 'u')
			nc_del_att (ncid, z_id, "scale_factor");
		if (header->z_add_offset != 0.0) {
			GMT_err_trap (nc_put_att_double (ncid, z_id, "add_offset", NC_DOUBLE, 1U, &header->z_add_offset));
		}
		else if (job == 'u')
			nc_del_att (ncid, z_id, "add_offset");
		if (z_type == NC_FLOAT || z_type == NC_DOUBLE) {
			GMT_err_trap (nc_put_att_double (ncid, z_id, "_FillValue", z_type, 1U, &header->nan_value));
		}
		else {
			i = lrint (header->nan_value);
			GMT_err_trap (nc_put_att_int (ncid, z_id, "_FillValue", z_type, 1U, &i));
		}

		/* Limits need to be stored in actual, not internal grid, units */
		if (header->z_min <= header->z_max) {
			dummy[0] = header->z_min * header->z_scale_factor + header->z_add_offset;
			dummy[1] = header->z_max * header->z_scale_factor + header->z_add_offset;
		}
		else
			dummy[0] = 0.0, dummy[1] = 0.0;
		GMT_err_trap (nc_put_att_double (ncid, z_id, "actual_range", NC_DOUBLE, 2U, dummy));

		/* Store values along x and y axes */
		GMT_err_trap (nc_enddef (ncid));
		xy = GMT_memory (C, NULL,  MAX (header->nx,header->ny), double);
		for (col = 0; col < header->nx; col++) xy[col] = GMT_grd_col_to_x (C, col, header);
		GMT_err_trap (nc_put_var_double (ncid, ids[header->xy_dim[0]], xy));
		if (header->y_order == k_nc_start_south) {
			for (row = 0; row < header->ny; row++) xy[row] = (double) GMT_col_to_x (C, row, header->wesn[YLO], header->wesn[YHI], header->inc[GMT_Y], 0.5 * header->registration, header->ny);
		}
		else {
			for (row = 0; row < header->ny; row++) xy[row] = (double) GMT_row_to_y (C, row, header->wesn[YLO], header->wesn[YHI], header->inc[GMT_Y], 0.5 * header->registration, header->ny);
		}
		GMT_err_trap (nc_put_var_double (ncid, ids[header->xy_dim[1]], xy));
		GMT_free (C, xy);
	}

	/* Close NetCDF file, unless job == 'W' */

	if (job != 'W') GMT_err_trap (nc_close (ncid));
	return (GMT_NOERROR);
}

int GMT_nc_read_grd_info (struct GMT_CTRL *C, struct GRD_HEADER *header)
{
	return (gmt_nc_grd_info (C, header, 'r'));
}

int GMT_nc_update_grd_info (struct GMT_CTRL *C, struct GRD_HEADER *header)
{
	return (gmt_nc_grd_info (C, header, 'u'));
}

int GMT_nc_write_grd_info (struct GMT_CTRL *C, struct GRD_HEADER *header)
{
	return (gmt_nc_grd_info (C, header, 'w'));
}

/* Fill padding by replicating the border cells */
void padding_copy(void *gridp, const unsigned n_cols, const unsigned n_rows,
		const unsigned *n_pad, size_t cell_size) {
	/* n_cols and n_rows are dimensions of the padded grid */
	char *grid = (char*)gridp;
	unsigned row, cell;

	assert (n_cols > n_pad[XLO] + n_pad[XHI] && n_rows > n_pad[YLO] + n_pad[YHI] &&
		n_pad[XLO] + n_pad[XHI] + n_pad[YLO] + n_pad[YHI] > 0 && cell_size > 0);

	for (row = n_pad[YHI]; row + n_pad[YLO] < n_rows; ++row) {
		/* Iterate over rows that contain data */
		for (cell = 0; cell < n_pad[XLO]; ++cell) {
			/* Duplicate first n_pad[XLO] columns in this row */
			memcpy (grid + (row * n_cols + cell) * cell_size,
							grid + (row * n_cols + n_pad[XLO]) * cell_size,
							cell_size);
		}
		for (cell = 0; cell < n_pad[XHI]; ++cell) {
			/* Duplicate last n_pad[XHI] columns in this row */
			memcpy (grid + (row * n_cols + n_cols - cell - 1) * cell_size,
							grid + (row * n_cols + n_cols - n_pad[XHI] - 1) * cell_size,
							cell_size);
		}
	}

	for (cell = 0; cell < n_pad[YHI]; ++cell) {
		/* Duplicate n_pad[YHI] rows in the beginning */
		memcpy(grid + cell * n_cols * cell_size,
					 grid + n_pad[YHI] * n_cols * cell_size,
					 n_cols * cell_size);
	}
	for (cell = 0; cell < n_pad[YLO]; ++cell) {
		/* Duplicate last n_pad[YLO] rows */
		memcpy(grid + (n_rows - cell - 1) * n_cols * cell_size,
					 grid + (n_rows - n_pad[YLO] - 1) * n_cols * cell_size,
					 n_cols * cell_size);
	}
}

/* Fill padding with zeros */
void padding_zero(void *gridp, const unsigned n_cols, const unsigned n_rows,
		const unsigned *n_pad, size_t cell_size) {
	/* n_cols and n_rows are dimensions of the padded grid */
	char *grid = (char*)gridp;
	unsigned row;

	assert (n_cols > n_pad[XLO] + n_pad[XHI] && n_rows > n_pad[YLO] + n_pad[YHI] &&
		n_pad[XLO] + n_pad[XHI] + n_pad[YLO] + n_pad[YHI] > 0 && cell_size > 0);

	/* Iterate over rows that contain data */
	for (row = n_pad[YHI]; row + n_pad[YLO] < n_rows; ++row) {
		/* Zero n cells at beginning of row */
		memset (grid + row * n_cols * cell_size, 0, n_pad[XLO] * cell_size);
		/* Zero n cells at end of row */
		memset (grid + (row * n_cols + n_cols - n_pad[XHI]) * cell_size, 0, n_pad[XHI] * cell_size);
	}
	/* Zero n_pad[YHI] rows in the beginning */
	memset(grid, 0, n_pad[YHI] * n_cols * cell_size);
	/* Zero last n_pad[YLO] rows */
	memset(grid + (n_rows-n_pad[YLO]) * n_cols * cell_size, 0, n_pad[YLO] * n_cols * cell_size);
}

/* Fill mode for grid padding */
enum {
	k_pad_fill_none = 0, /* Leave padded cells untouched */
	k_pad_fill_zero,     /* Fill padded grid cells with zeros */
	k_pad_fill_copy      /* Padded cells get the value of their nearest neighbor */
};

/* Add padding to a matrix/grid and reshape data */
void pad_grid(void *gridp, const unsigned n_old_cols, const unsigned n_old_rows,
		const unsigned *n_pad, size_t cell_size, unsigned filltype) {
	/* n_cols and n_rows are dimensions of the grid without padding
	 * cell_size is the size in bytes of each element in grid
	 * n_pad[4] contains the number of cols/rows to pad on each side {W,E,S,N} */
	char *grid = (char*)gridp;
	unsigned new_row;
	unsigned old_row = n_old_rows-1;
	unsigned n_new_cols = n_old_cols + n_pad[XLO] + n_pad[XHI];
	unsigned n_new_rows = n_old_rows + n_pad[YLO] + n_pad[YHI];

#ifdef DEBUG
	fprintf (stderr, "pad grid w:%u e:%u s:%u n:%u\n",
			n_pad[XLO], n_pad[XHI], n_pad[YLO], n_pad[YHI]);
#endif
	if (n_pad[XLO] + n_pad[XHI] + n_pad[YLO] + n_pad[YHI] == 0)
		return; /* nothing to pad */

	assert (n_old_cols > 0 && n_old_rows > 0 && cell_size > 0);

	/* Reshape matrix */
	for (new_row = n_new_rows - n_pad[YLO] - 1; new_row + 1 > n_pad[YHI]; --new_row, --old_row) {
		/* Copy original row to new row */
		if ( n_pad[YHI] == 0 && n_pad[YLO] == 0 ) /* rows overlap! */
			memmove(grid + (new_row * n_new_cols + n_pad[XLO]) * cell_size,
							grid + old_row * n_old_cols * cell_size,
							n_old_cols * cell_size);
		else /* no overlap, memcpy is safe */
			memcpy(grid + (new_row * n_new_cols + n_pad[XLO]) * cell_size,
						 grid + old_row * n_old_cols * cell_size,
						 n_old_cols * cell_size);
	}

	/* Fill padded grid cells */
	switch (filltype) {
		case k_pad_fill_zero:
			padding_zero (grid, n_new_cols, n_new_rows, n_pad, cell_size);
			break;
		case k_pad_fill_copy:
			padding_copy (grid, n_new_cols, n_new_rows, n_pad, cell_size);
			break;
	}
}

/* Remove padding from a matrix/grid and reshape data */
void unpad_grid(void *gridp, const unsigned n_cols, const unsigned n_rows,
		const unsigned *n_pad, size_t cell_size) {
	/* n_cols and n_rows are dimensions of the grid without padding
	 * cell_size is the size in bytes of each element in grid
	 * n_pad[4] contains the number of cols/rows to pad on each side {W,E,S,N} */
	char *grid = (char*)gridp;
	unsigned n_old_cols = n_cols + n_pad[XLO] + n_pad[XHI];
	unsigned row;

#ifdef DEBUG
	fprintf (stderr, "unpad grid w:%u e:%u s:%u n:%u\n",
			n_pad[XLO], n_pad[XHI], n_pad[YLO], n_pad[YHI]);
#endif
	if (n_pad[XLO] + n_pad[XHI] + n_pad[YLO] + n_pad[YHI] == 0)
		return; /* nothing to unpad */

	assert (n_cols > 0 && n_rows > 0 && cell_size > 0);

	/* Reshape matrix */
	for (row = 0; row < n_rows; ++row) {
		unsigned old_row = row + n_pad[YHI];
		/* Copy original row to new row */
		if (n_pad[YHI] == 0) /* rows overlap! */
			memmove(grid + row * n_cols * cell_size,
							grid + (old_row * n_old_cols + n_pad[XLO]) * cell_size,
							n_cols * cell_size);
		else /* no overlap, memcpy is safe */
			memcpy(grid + row * n_cols * cell_size,
						 grid + (old_row * n_old_cols + n_pad[XLO]) * cell_size,
						 n_cols * cell_size);
	}
}
/* Reverses the grid vertically, that is, from north up to south up or vice versa. */
void grid_flip_vertical (float *grid, const unsigned height, const unsigned width) {
	unsigned height_over_2 = (unsigned) floor (height / 2.0);
	unsigned row;
	float *tmp = malloc (width * sizeof (float));
	float *top, *bottom;
	for (row = 0; row < height_over_2; ++row) {
		top = grid + row * width;                       /* points to top row */
		bottom = grid + (height - row) * width - width; /* points to bottom row */
		memcpy (tmp, top, width * sizeof (float));    /* save top row */
		memcpy (top, bottom, width * sizeof (float)); /* copy bottom to top */
		memcpy (bottom, tmp, width * sizeof (float)); /* copy tmp to bottom */
	}
	free (tmp);
}

/* Change the default chunk cache settings in the HDF5 library for all variables
 * in the nc-file. The settings apply for subsequent file opens/creates. */
static inline void setup_chunk_cache (void) {
	static bool already_setup = false;
	if (!already_setup) {
		nc_set_chunk_cache(NC_CACHE_SIZE, NC_CACHE_NELEMS, NC_CACHE_PREEMPTION);
		already_setup = true;
	}
}

/* Get number of chunked rows that fit into cache (32MiB) */
int n_chunked_rows_in_cache (struct GMT_CTRL *C, struct GRD_HEADER *header, unsigned width, unsigned height, size_t *n_contiguous_chunk_rows, size_t *chunksize) {
	nc_type z_type;      /* type of z variable */
	size_t z_size;       /* size of z variable */
	unsigned yx_dim[2] = {header->xy_dim[1], header->xy_dim[0]}; /* because xy_dim not row major */
	int err, storage_in;

	GMT_err_trap (nc_inq_vartype(header->ncid, header->z_id, &z_type)); /* type of z */
	GMT_err_trap (nc_inq_type(header->ncid, z_type, NULL, &z_size)); /* size of z elements in bytes */
	GMT_err_trap (nc_inq_var_chunking (header->ncid, header->z_id, &storage_in, chunksize));
	if (storage_in != NC_CHUNKED)
		chunksize[yx_dim[0]] = 128; /* default if NC_CONTIGUOUS */

	if (height * width * z_size > NC_CACHE_SIZE) {
		/* memory needed for subset exceeds the cache size */
		*n_contiguous_chunk_rows = (size_t) floor ( NC_CACHE_SIZE / (width * z_size) / chunksize[0] );
#ifdef DEBUG
		GMT_report (C, GMT_MSG_FATAL, "processing %zu contiguous chunked rows (%.1f MiB)\n",
						 *n_contiguous_chunk_rows,
						 *n_contiguous_chunk_rows * z_size * width * chunksize[yx_dim[0]] / 1048576.0f);
	}
	else
		*n_contiguous_chunk_rows = 0; /* all chunks fit into cache */
#endif
	return GMT_NOERROR;
}

/* netcdf I/O mode */
enum {
	k_put_netcdf = 0,
	k_get_netcdf
};

/* Wrapper around nc_put_vara_float and nc_get_vara_float */
static inline int io_nc_vara_float (int ncid, int varid, const size_t *startp,
	 const size_t *countp, float *ip, unsigned io_mode) {
	if (io_mode == k_put_netcdf)
		/* write netcdf */
		return nc_put_vara_float (ncid, varid, startp, countp, ip);
	/* read netcdf */
	return nc_get_vara_float (ncid, varid, startp, countp, ip);
}

/* Wrapper around nc_put_varm_float and nc_get_varm_float */
static inline int io_nc_varm_float (int ncid, int varid, const size_t *startp,
	 const size_t *countp, const ptrdiff_t *stridep,
	 const ptrdiff_t *imapp, float *ip, unsigned io_mode) {
	if (io_mode == k_put_netcdf)
		/* write netcdf */
		return nc_put_varm_float (ncid, varid, startp, countp, stridep, imapp, ip);
	/* read netcdf */
	return nc_get_varm_float (ncid, varid, startp, countp, stridep, imapp, ip);
}

/* Read and write classic or chunked netcdf files */
int io_nc_grid (struct GMT_CTRL *C, struct GRD_HEADER *header, unsigned dim[], unsigned origin[], unsigned offset, unsigned increment, unsigned io_mode, float* grid) {
	/* io_mode = k_get_netcdf: read a netcdf file to grid
	 * io_mode = k_put_netcdf: write a grid to netcdf */
	int status = NC_NOERR;
	unsigned first_col = origin[1], first_row = origin [0];
	unsigned width = dim[1], height = dim[0];
	unsigned yx_dim[2];  /* because xy_dim is not row major! */
	size_t chunksize[5]; /* chunksize of z */
	size_t start[5] = {0,0,0,0,0}, count[5] = {1,1,1,1,1};
	size_t n_contiguous_chunk_rows;  /* that are processed at once, 0 = all */
	ptrdiff_t imap[5] = {1,1,1,1,1}; /* mapping between dims of netCDF and in-memory grid */
	float *p_grid = grid + offset;   /* points to beginning of grid */

	/* catch illegal io_mode in debug */
	assert (io_mode == k_put_netcdf || io_mode == k_get_netcdf);

#ifdef DEBUG
	GMT_report (C, GMT_MSG_FATAL, "%s nx:%u ny:%u x0:%u y0:%u y-order:%s\n",
			io_mode == k_put_netcdf ? "writing," : "reading,",
			width, height, first_col, first_row,
			header->y_order == k_nc_start_south ? "S->N" : "N->S");
#endif

	/* set index of input origin */
	yx_dim[0] = header->xy_dim[1], yx_dim[1] = header->xy_dim[0]; /* xy_dim not row major */
	start[yx_dim[0]] = first_row;
	start[yx_dim[1]] = first_col;

	/* set mapping of complex grids */
	imap[yx_dim[0]] = width * increment; /* distance between each row */
	imap[yx_dim[1]] = increment;         /* distance between values in a row */

	/* determine how many chunks to process at once */
	n_chunked_rows_in_cache (C, header, width, height, &n_contiguous_chunk_rows, chunksize);

	if (n_contiguous_chunk_rows) {
		/* read/write grid in chunks to keep memory footprint low */
		unsigned remainder;

		/* adjust row count, so that it ends on the bottom of a chunk */
		count[yx_dim[0]] = chunksize[yx_dim[0]] * n_contiguous_chunk_rows;
		remainder = start[yx_dim[0]] % chunksize[yx_dim[0]];
		count[yx_dim[0]] -= remainder;

		count[yx_dim[1]] = width;
		while ( start[yx_dim[0]] + count[yx_dim[0]] <= height && status == NC_NOERR) {
			/* get/put chunked rows */
			if (increment)
				status = io_nc_varm_float (header->ncid, header->z_id, start, count, NULL, imap, p_grid, io_mode);
			else
				status = io_nc_vara_float (header->ncid, header->z_id, start, count, p_grid, io_mode);
			p_grid += count[yx_dim[0]] * width;   /* advance grid location */
			start[yx_dim[0]] += count[yx_dim[0]]; /* set new origin */
			if (remainder) {
				/* reset count to full chunk height */
				count[yx_dim[0]] += remainder;
				remainder = 0;
			}
		}
		if ( start[yx_dim[0]] != height && status == NC_NOERR ) {
			/* get/put last chunked row */
			count[yx_dim[0]] = height - start[yx_dim[0]] + first_row;
			if (increment)
				status = io_nc_varm_float (header->ncid, header->z_id, start, count, NULL, imap, p_grid, io_mode);
			else
				status = io_nc_vara_float (header->ncid, header->z_id, start, count, p_grid, io_mode);
		}
	}
	else {
		/* get/put whole grid contiguous */
		count[yx_dim[0]] = height;
		count[yx_dim[1]] = width;
		if (increment)
			status = io_nc_varm_float (header->ncid, header->z_id, start, count, NULL, imap, p_grid, io_mode);
		else
			status = io_nc_vara_float (header->ncid, header->z_id, start, count, p_grid, io_mode);
	}
	return status;
}

int GMT_nc_read_grd (struct GMT_CTRL *C, struct GRD_HEADER *header, float *grid, double wesn[], unsigned int *pad, unsigned int complex_mode)
{ /* header:       grid structure header
	 * grid:         array with final grid
	 * wesn:         Sub-region to extract  [Use entire file if 0,0,0,0]
	 * padding:      # of empty rows/columns to add on w, e, s, n of grid, respectively
	 * complex_mode: 1|2 if complex array is to hold real (1) or imaginary (2) part (0 = read as real only)
	 * Note: The file has only real values, we simply allow space in the complex array
	 * for real and imaginary parts when processed by grdfft etc.
	 *
	 * Reads a subset of a grdfile and optionally pads the array with extra rows and columns
	 * header values for nx and ny are reset to reflect the dimensions of the logical array,
	 * not the physical size (i.e., the padding is not counted in nx and ny)
	 */

	bool adj_nan_value; /* if we need to change the fill value */
	int err;            /* netcdf errors */
	int first_col, last_col, first_row, last_row;
	unsigned *actual_col = NULL;
	unsigned dim[2], origin[2]; /* dimension and origin {y,x} of subset to read from netcdf */
	unsigned width, height, inc, off, n;

	/* Check type: is file in old NetCDF format or not at all? */
	if (C->session.grdformat[header->type][0] == 'c')
		return (GMT_cdf_read_grd (C, header, grid, wesn, pad, complex_mode));
	else if (C->session.grdformat[header->type][0] != 'n')
		return (NC_ENOTNC);

	GMT_err_pass (C, GMT_grd_prep_io (C, header, wesn, &width, &height, &first_col, &last_col, &first_row, &last_row, &actual_col), header->name);
	GMT_free (C, actual_col);
#ifdef DEBUG
	GMT_report (C, GMT_MSG_FATAL, "width:   %d   height:%d\n", width, height);
	GMT_report (C, GMT_MSG_FATAL, "head->nx:%d head->ny:%d\n", header->nx, header->ny);
	GMT_report (C, GMT_MSG_FATAL, "first_col:%d last_col:%d first_row:%d last_row:%d\n", first_col, last_col, first_row, last_row);
	GMT_report (C, GMT_MSG_FATAL, "head->t-index x0:%d y0:%d\n", header->t_index[1], header->t_index[0]);
	GMT_report (C, GMT_MSG_FATAL, "head->pad xlo:%u xhi:%u\n", header->pad[XLO], header->pad[XHI]);
#endif

	/* Adjust first_row */
	if (header->y_order == k_nc_start_south)
		first_row = header->ny - 1 - last_row;

	/* Set stride and offset if complex */
	(void)GMT_init_complex (complex_mode, &inc, &off);

	/* Open the NetCDF file */
	if (!strcmp (header->name,"="))
		return (GMT_GRDIO_NC_NO_PIPE);
	setup_chunk_cache();
	GMT_err_trap (nc_open (header->name, NC_NOWRITE, &header->ncid));

	/* read grid */
	if (header->t_index[1] < 0)
		header->t_index[1] = 0;
	dim[0]    = height; //,    dim[1]    = width;
	// the statement before is supposed to work but doesn't if width > header->nx, so:
	dim[1] = width > header->nx ? header->nx : width;
	origin[0] = first_row, origin[1] = header->t_index[1]; // t_index[1] was first_col
	io_nc_grid (C, header, dim, origin, off, inc, k_get_netcdf, grid);

	/* TODO: Fix this ugly hack
	 * If grid is global, then width > dim[1] in netcdf variable
	 * so we need to padd the right margin */
	if (width > header->nx) {
		unsigned fix_pad[4] = {0,0,0,0};
		fix_pad[XHI] = width - header->nx;
		pad_grid(grid, width, height, fix_pad, sizeof(grid[0]), k_pad_fill_zero);
	}

	/* Adjust width if complex */
	width *= inc;

	/* get stats */
	header->z_min = DBL_MAX;
	header->z_max = -DBL_MAX;
	adj_nan_value = !isnan (header->nan_value);
	for (n = 0 + off; n < width * height; complex_mode ? n += inc : ++n) {
		if (adj_nan_value && grid[n] == header->nan_value) {
			grid[n] = C->session.f_NaN;
			continue;
		}
		else if (!isnan (grid[n])) {
			header->z_min = MIN (header->z_min, grid[n]);
			header->z_max = MAX (header->z_max, grid[n]);
		}
	}
#ifdef DEBUG
	GMT_report (C, GMT_MSG_FATAL, "minmax: %f %f\n", header->z_min, header->z_max);
#endif

	/* flip grid upside down */
	if (header->y_order == k_nc_start_south)
		grid_flip_vertical (grid, height, width);

	/* Add padding with border replication / zero-fill complex grids */
	pad_grid(grid, width, height, pad, sizeof(grid[0]), complex_mode ? k_pad_fill_zero : k_pad_fill_copy);

	/* Adjust header */
	GMT_memcpy (header->wesn, wesn, 4, double);
	header->nx = width;
	header->ny = height;

	GMT_err_trap (nc_close (header->ncid));

	return GMT_NOERROR;
}

int GMT_nc_write_grd (struct GMT_CTRL *C, struct GRD_HEADER *header, float *grid, double wesn[], unsigned int *pad, unsigned int complex_mode)
{ /* header:       grid structure header
	 * grid:         array with final grid
	 * wesn:         Sub-region to write out  [Use entire file if 0,0,0,0]
	 * padding:      # of empty rows/columns to add on w, e, s, n of grid, respectively
	 * complex_mode: 1|2 if complex array is to hold real (1) or imaginary (2) part (0 = read as real only)
	 * Note: The file has only real values, we simply allow space in the complex array
	 * for real and imaginary parts when processed by grdfft etc.
	 */

	int status = NC_NOERR;
	bool adj_nan_value;   /* if we need to change the fill value */
	bool do_round = true; /* if we need to round to integral */
	unsigned n, width, width_real, height, inc, off, *actual_col = NULL;
	unsigned dim[2], origin[2]; /* dimension and origin {y,x} of subset to write to netcdf */
	int first_col, last_col, first_row, last_row;
	double limit[2];      /* minmax of z variable */

	/* Determine the value to be assigned to missing data, if not already done so */
	switch (header->type) {
		case GMT_GRD_IS_NB:
			if (isnan (header->nan_value))
				header->nan_value = NC_MIN_BYTE;
			break;
		case GMT_GRD_IS_NS:
			if (isnan (header->nan_value))
				header->nan_value = NC_MIN_SHORT;
			break;
		case GMT_GRD_IS_NI:
			if (isnan (header->nan_value))
				header->nan_value = NC_MIN_INT;
			break;
		case GMT_GRD_IS_ND:
			GMT_report (C, GMT_MSG_FATAL, "Warning: Precision loss! GMT's internal grid representation is 32-bit float.\n");
			/* no break! */
		default: /* don't round float */
			do_round = false;
	}

	GMT_err_pass (C, GMT_grd_prep_io (C, header, wesn, &width, &height, &first_col, &last_col, &first_row, &last_row, &actual_col), header->name);
	GMT_free (C, actual_col);

	/* Adjust header */
	GMT_memcpy (header->wesn, wesn, 4, double);
	header->nx = width;
	header->ny = height;

	/* Adjust first_row */
	if (header->y_order == k_nc_start_south)
		first_row = header->ny - 1 - last_row;

	/* Write grid header without closing file afterwards */
	setup_chunk_cache();
	status = gmt_nc_grd_info (C, header, 'W');
	if (status != NC_NOERR)
		goto nc_err;

	/* Set stride and offset if complex */
	(void)GMT_init_complex (complex_mode, &inc, &off);

	/* Remove padding from grid */
	width_real = width * inc;
	unpad_grid(grid, width_real, height, pad, sizeof(grid[0]));

	/* flip grid upside down */
	if (header->y_order == k_nc_start_south)
		grid_flip_vertical (grid, height, width_real);

	/* get stats */
	header->z_min = DBL_MAX;
	header->z_max = -DBL_MAX;
	adj_nan_value = !isnan (header->nan_value);
	n = 0;
	while (n < width_real * height) {
		if (adj_nan_value && isnan (grid[n]))
			grid[n] = header->nan_value;
		else if (!isnan (grid[n])) {
			if (do_round)
				grid[n] = rint (grid[n]); /* round to int */
			header->z_min = MIN (header->z_min, grid[n]);
			header->z_max = MAX (header->z_max, grid[n]);
		}
		++n;
	}

#ifdef DEBUG
	GMT_report (C, GMT_MSG_FATAL, "minmax: %f %f\n", header->z_min, header->z_max);
#endif

	/* write grid */
	dim[0]    = height,    dim[1]    = width;
	origin[0] = first_row, origin[1] = first_col;
	status = io_nc_grid (C, header, dim, origin, off, inc, k_put_netcdf, grid);
	if (status != NC_NOERR)
		goto nc_err;

	/* Limits need to be written in actual, not internal grid, units */
	if (header->z_min <= header->z_max) {
		limit[0] = header->z_min * header->z_scale_factor + header->z_add_offset;
		limit[1] = header->z_max * header->z_scale_factor + header->z_add_offset;
	}
	else {
		GMT_report (C, GMT_MSG_FATAL, "Warning: No valid values in grid [%s]\n", header->name);
		limit[0] = limit[1] = NAN; /* set limit to NaN */
	}
	status = nc_put_att_double (header->ncid, header->z_id, "actual_range", NC_DOUBLE, 2, limit);
	if (status != NC_NOERR)
		goto nc_err;

	/* Close grid */
	status = nc_close (header->ncid);
	if (status != NC_NOERR)
		goto nc_err;

	return GMT_NOERROR;

nc_err:
	/* exit gracefully */
	nc_close(header->ncid); /* close nc-file */
	unlink (header->name);  /* remove nc-file */
	if (status == NC_ERANGE) {
		/* report out of range z variable */
		GMT_report (C, GMT_MSG_FATAL, "Cannot write format %s.\n", C->session.grdformat[header->type]);
		GMT_report (C, GMT_MSG_FATAL, "The scaled z-range, [%g,%g], exceeds the maximum representable size. Adjust scale and offset parameters or remove out-of-range values.\n", header->z_min, header->z_max);
	}
	return status;
}
