Creating GMT Graphics
=====================

[ch:7]

In this section we will be giving numerous examples of typical usage of
*GMT* programs. In general, we will start with a raw data set,
manipulate the numbers in various ways, then display the results in
diagram or map view. The resulting plots will have in common that they
are all made up of simpler plots that have been overlaid to create a
complex illustration. We will mostly follow the following format:

#. We explain what we want to achieve in plain language.

#. We present an annotated Bourne shell script that contains all
   commands used to generate the illustration.

#. We explain the rationale behind the commands.

#. We present the illustration, 50% reduced in size, and without the timestamp (**-U**).

A detailed discussion of each command is not given; we refer you to the
manual pages for command line syntax, etc. We encourage you to run these
scripts for yourself. See Appendix [app:D] if you would like an
electronic version of all the shell-scripts (both **sh** and **csh**
scripts are available, as or DOS batch files; only the **sh**-scripts
are discussed here) and support data used below. Note that all examples
explicitly specifies the measurement units, so although we use inches
you should be able to run these scripts and get the same plots even if
you have cm as the default measure unit. The examples are all written to
be "quiet", that is no information is echoed to the screen. Thus, these
scripts are well suited for background execution.

Note that we also end each script by cleaning up after ourselves.
Because there are several **AWK** implementations such as **gawk**
and **nawk**, which are not available everywhere, we refer to
**$AWK** in the scripts below. This variable must be set prior to
running the example scripts.

Finally, be aware that for practical purposes the output
*PostScript* file name is stored as the variable ``ps``.

The making of contour maps
--------------------------

We want to create two contour maps of the low order geoid using the
Hammer equal area projection. Our gridded data file is called ``osu91a1f_16.nc`` and
contains a global 1 by 1 gridded geoid (we will see how to make gridded
files later). We would like to show one map centered on Greenwich and
one centered on the dateline. Positive contours should be drawn with a
solid pen and negative contours with a dashed pen. Annotations should
occur for every 50 m contour level, and both contour maps should show
the continents in light brown in the background. Finally, we want a
rectangular frame surrounding the two maps. This is how it is done:

   ::

    #!/bin/bash
    # GMT EXAMPLE 01
    #
    # Purpose: Make two contour maps based on the data in the file osu91a1f_16.nc
    # GMT progs: gmtset, grdcontour, psbasemap, pscoast
    # Unix progs: rm
    #
    ps=../example_01.ps
    gmt set MAP_GRID_CROSS_SIZE_PRIMARY 0 FONT_ANNOT_PRIMARY 10p
    gmt psbasemap -R0/6.5/0/9 -Jx1i -B0 -P -K -U"Example 1 in Cookbook" > $ps
    gmt pscoast -Rg -JH0/6i -X0.25i -Y0.5i -O -K -Bg30 -Dc -Glightbrown -Slightblue >> $ps
    gmt grdcontour osu91a1f_16.nc -J -C10 -A50+f7p -Gd4i -L-1000/-1 -Wcthinnest,- -Wathin,- \
                   -O -K -T0.1i/0.02i >> $ps
    gmt grdcontour osu91a1f_16.nc -J -C10 -A50+f7p -Gd4i -L-1/1000 -O -K -T0.1i/0.02i >> $ps
    gmt pscoast -Rg -JH6i -Y4i -O -K -Bg30 -B+t"Low Order Geoid" -Dc -Glightbrown -Slightblue >> $ps
    gmt grdcontour osu91a1f_16.nc -J -C10 -A50+f7p -Gd4i -L-1000/-1 -Wcthinnest,- -Wathin,- \
                   -O -K -T0.1i/0.02i:-+ >> $ps
    gmt grdcontour osu91a1f_16.nc -J -C10 -A50+f7p -Gd4i -L-1/1000 -O -T0.1i/0.02i:-+ >> $ps

The first command draws a box surrounding the maps. This is followed by
two sequences of `pscoast <pscoast.html>`_, `grdcontour <grdcontour.html>`_,
`grdcontour <grdcontour.html>`_. They differ in that the
first is centered on Greenwich; the second on the dateline. We use the
limit option (**-L**) in `grdcontour <grdcontour.html>`_
to select negative contours only and plot those with a dashed pen, then
positive contours only and draw with a solid pen [Default]. The **-T**
option causes tick marks pointing in the downhill direction to be drawn
on the innermost, closed contours. For the upper panel we also added -
and + to the local lows and highs. You can find this illustration as

.. include:: fig_includes/fig_example_01.rst_

Image presentations
-------------------

[sec:example:sub:`0`\ 2]

As our second example we will demonstrate how to make color images from
gridded data sets (again, we will defer the actual making of grid files
to later examples). We will use `grdraster <grdraster.html>`__ to extract 2-D grid files
of bathymetry and Geosat geoid heights and put the two images on the
same page. The region of interest is the Hawaiian islands, and due to
the oblique trend of the island chain we prefer to rotate our
geographical data sets using an oblique Mercator projection defined by
the hotspot pole at (68W, 69N). We choose the point (190, 25.5) to be
the center of our projection (e.g., the local origin), and we want to
image a rectangular region defined by the longitudes and latitudes of
the lower left and upper right corner of region. In our case we choose
(160, 20) and (220, 30) as the corners. We use
`grdimage <grdimage.html>`_ to make the illustration:

   ::

    #!/bin/bash
    # GMT EXAMPLE 02
    #
    # Purpose: Make two color images based gridded data
    # GMT progs: gmtset, grd2cpt, grdgradient, grdimage, makecpt, psscale, pstext
    # Unix progs: rm
    #
    ps=../example_02.ps
    gmt set FONT_TITLE 30p MAP_ANNOT_OBLIQUE 0
    gmt makecpt -Crainbow -T-2/14/2 > g.cpt
    gmt grdimage HI_geoid2.nc -R160/20/220/30r -JOc190/25.5/292/69/4.5i -E50 -K -P \
                 -U/-1.25i/-1i/"Example 2 in Cookbook" -B10 -Cg.cpt -X1.5i -Y1.25i > $ps
    gmt psscale -Cg.cpt -D5.1i/1.35i/2.88i/0.4i -O -K -Ac -Bx2+lGEOID -By+lm -E >> $ps
    gmt grd2cpt HI_topo2.nc -Crelief -Z > t.cpt
    gmt grdgradient HI_topo2.nc -A0 -Nt -GHI_topo2_int.nc
    gmt grdimage HI_topo2.nc -IHI_topo2_int.nc -R -J -E50 -B+t"H@#awaiian@# T@#opo and @#G@#eoid" \
                 -B10 -O -K -Ct.cpt -Y4.5i --MAP_TITLE_OFFSET=0.5i >> $ps
    gmt psscale -Ct.cpt -D5.1i/1.35i/2.88i/0.4i -O -K -I0.3 -Ac -Bx2+lTOPO -By+lkm >> $ps
    gmt pstext -R0/8.5/0/11 -Jx1i -F+f30p,Helvetica-Bold+jCB -O -N -Y-4.5i >> $ps << END
    -0.4 7.5 a)
    -0.4 3.0 b)
    END
    rm -f HI_topo2_int.nc ?.cpt

The first step extracts the 2-D data sets from the local data base using
`grdraster <grdraster.html>`__ that may be adapted to reflect
the nature of your data base format. It automatically figures out the
required extent of the region given the two corners points and the
projection. The extreme meridians and parallels enclosing the oblique
region is **-R**\ 159:50/220:10/3:10/47:35. This is the area extracted
by `grdraster <grdraster.html>`__. For your convenience
we have commented out those lines and provided the two extracted files
so you do not need `grdraster <grdraster.html>`__ to try
this example. By using the embedded grid file format mechanism we saved
the topography using kilometers as the data unit. We now have two grid
files with bathymetry and geoid heights, respectively. We use
`makecpt <makecpt.html>`_ to generate a linear color
palette file ``geoid.cpt`` for the geoid and use
`grd2cpt <grd2cpt.html>`_ to get a histogram-equalized
cpt file ``topo.cpt`` for the topography data. To emphasize the structures in the
data we calculate the slopes in the north-south direction using
`grdgradient <grdgradient.html>`_; these will be used to
modulate the color image. Next we run
`grdimage <grdimage.html>`_ to create a color-code image
of the Geosat geoid heights, and draw a color legend to the right of the
image with `psscale <psscale.html>`_. Similarly, we run
`grdimage <grdimage.html>`_ but specify **-Y**\ 4.5i to
plot above the previous image. Adding scale and label the two plots a)
and b) completes the illustration.

.. include:: fig_includes/fig_example_02.rst_

Spectral estimation and xy-plots
--------------------------------

In this example we will show how to use the *GMT* programs
`fitcircle <fitcircle.html>`_, `project <project.html>`_,
`sample1d <sample1d.html>`_, `spectrum1d <spectrum1d.html>`_,
`psxy <psxy.html>`_, and
`pstext <pstext.html>`_. Suppose you have (lon, lat,
gravity) along a satellite track in a file called ``sat.xyg``, and (lon, lat,
gravity) along a ship track in a file called ``ship.xyg``. You want to make a
cross-spectral analysis of these data. First, you will have to get the
two data sets into equidistantly sampled time-series form. To do this,
it will be convenient to project these along the great circle that best
fits the sat track. We must use
`fitcircle <fitcircle.html>`_ to find this great circle
and choose the L\ :math:`_2` estimates of best pole. We project the data
using `project <project.html>`_ to find out what their
ranges are in the projected coordinate. The
`minmax <minmax.html>`_ utility will report the minimum
and maximum values for multi-column ASCII tables. Use this information
to select the range of the projected distance coordinate they have in
common. The script prompts you for that information after reporting the
values. We decide to make a file of equidistant sampling points spaced 1
km apart from -1167 to +1169, and use the *UNIX* utility **awk** to
accomplish this step. We can then resample the projected data, and carry
out the cross-spectral calculations, assuming that the ship is the input
and the satellite is the output data. There are several intermediate
steps that produce helpful plots showing the effect of the various
processing steps (``example_03[a-f].ps``), while the final plot ``example_03.ps`` shows the ship and sat power
in one diagram and the coherency on another diagram, both on the same
page. Note the extended use of `pstext <pstext.html>`_
and `psxy <psxy.html>`_ to put labels and legends
directly on the plots. For that purpose we often use **-Jx**\ 1i and
specify positions in inches directly. Thus, the complete automated script reads:

   ::

    #!/bin/bash
    # GMT EXAMPLE 03
    #
    # Purpose: Resample track data, do spectral analysis, and plot
    # GMT progs: filter1d, fitcircle, minmax, project, sample1d
    # GMT progs: spectrum1d, trend1d, pshistogram, psxy, pstext
    # Unix progs: awk, cat, echo, head, paste, rm, tail
    #
    # This example begins with data files "ship.xyg" and "sat.xyg" which
    # are measurements of a quantity "g" (a "gravity anomaly" which is an
    # anomalous increase or decrease in the magnitude of the acceleration
    # of gravity at sea level). g is measured at a sequence of points "x,y"
    # which in this case are "longitude,latitude". The "sat.xyg" data were
    # obtained by a satellite and the sequence of points lies almost along
    # a great circle. The "ship.xyg" data were obtained by a ship which
    # tried to follow the satellite's path but deviated from it in places.
    # Thus the two data sets are not measured at the same of points,
    # and we use various GMT tools to facilitate their comparison.
    # The main illustration (example_03.ps) are accompanied with 5 support
    # plots (03a-f) showing data distributions and various intermediate steps.
    #
    # First, we use "fitcircle" to find the parameters of a great circle
    # most closely fitting the x,y points in "sat.xyg":
    #
    ps=../example_03.ps
    fitcircle sat.xyg -L2 > report
    cposx=`grep "L2 Average Position" report | cut -f1`
    cposy=`grep "L2 Average Position" report | cut -f2`
    pposx=`grep "L2 N Hemisphere" report | cut -f1`
    pposy=`grep "L2 N Hemisphere" report | cut -f2`
    #
    # Now we use "project" to project the data in both sat.xyg and ship.xyg
    # into data.pg, where g is the same and p is the oblique longitude around
    # the great circle. We use -Q to get the p distance in kilometers, and -S
    # to sort the output into increasing p values.
    #
    gmt project sat.xyg -C$cposx/$cposy -T$pposx/$pposy -S -Fpz -Q > sat.pg
    gmt project ship.xyg -C$cposx/$cposy -T$pposx/$pposy -S -Fpz -Q > ship.pg
    #
    # The minmax utility will report the minimum and maximum values for all columns.
    # We use this information first with a large -I value to find the appropriate -R
    # to use to plot the .pg data.
    #
    R=`cat sat.pg ship.pg | minmax -I100/25`
    gmt psxy $R -U/-1.75i/-1.25i/"Example 3a in Cookbook" \
             -Bxa500f100+l"Distance along great circle" -Bya100f25+l"Gravity anomaly (mGal)" \
             -BWeSn -JX8i/5i -X2i -Y1.5i -K -Wthick sat.pg > ../example_03a.ps
    gmt psxy -R -JX -O -Sp0.03i ship.pg >> ../example_03a.ps
    #
    # From this plot we see that the ship data have some "spikes" and also greatly
    # differ from the satellite data at a point about p ~= +250 km, where both of
    # them show a very large anomaly.
    #
    # To facilitate comparison of the two with a cross-spectral analysis using "spectrum1d",
    # we resample both data sets at intervals of 1 km. First we find out how the data are
    # typically spaced using awk to get the delta-p between points and view it with
    # "pshistogram".
    #
    awk '{ if (NR > 1) print $1 - last1; last1=$1; }' ship.pg | gmt pshistogram -W0.1 -Gblack -JX3i \
         -K -X2i -Y1.5i -B+t"Ship" -U/-1.75i/-1.25i/"Example 3b in Cookbook" > ../example_03b.ps
    awk '{ if (NR > 1) print $1 - last1; last1=$1; }' sat.pg | gmt pshistogram -W0.1 -Gblack -JX3i \
         -O -X5i -B+t"Sat" >> ../example_03b.ps
    #
    # This experience shows that the satellite values are spaced fairly evenly, with
    # delta-p between 3.222 and 3.418. The ship values are spaced quite unevelnly, with
    # delta-p between 0.095 and 9.017. This means that when we want 1 km even sampling,
    # we can use "sample1d" to interpolate the sat data, but the same procedure applied
    # to the ship data could alias information at shorter wavelengths. So we have to use
    # "filter1d" to resample the ship data. Also, since we observed spikes in the ship
    # data, we use a median filter to clean up the ship values. We will want to use "paste"
    # to put the two sampled data sets together, so they must start and end at the same
    # point, without NaNs. So we want to get a starting and ending point which works for
    # both of them. This is a job for gmtmath UPPER/LOWER.
    #
    head -1 ship.pg > tmp
    head -1 sat.pg >> tmp
    sampr1=‘gmt gmtmath tmp -Ca -Sf -o0 UPPER CEIL =‘
    tail -1 ship.pg > tmp
    tail -1 sat.pg >> tmp
    sampr2=‘gmt gmtmath tmp -Ca -Sf -o0 LOWER FLOOR =‘
    #
    # Now we can use sampr1|2 in gmtmath to make a sampling points file for sample1d:
    gmt gmtmath -T$sampr1/$sampr2/1 -N1/0 T = samp.x
    #
    # Now we can resample the projected satellite data:
    #
    gmt sample1d sat.pg -Nsamp.x > samp_sat.pg
    #
    # For reasons above, we use filter1d to pre-treat the ship data. We also need to sample it
    # because of the gaps > 1 km we found. So we use filter1d | sample1d. We also use the -E
    # on filter1d to use the data all the way out to sampr1/sampr2 :
    #
    gmt filter1d ship.pg -Fm1 -T$sampr1/$sampr2/1 -E | sample1d -Nsamp.x > samp_ship.pg
    #
    # Now we plot them again to see if we have done the right thing:
    #
    gmt psxy $R -JX8i/5i -X2i -Y1.5i -K -Wthick samp_sat.pg \
             -Bxa500f100+l"Distance along great circle" -Bya100f25+l"Gravity anomaly (mGal)" \
             -BWeSn -U/-1.75i/-1.25i/"Example 3c in Cookbook" > ../example_03c.ps
    gmt psxy -R -JX -O -Sp0.03i samp_ship.pg >> ../example_03c.ps
    #
    # Now to do the cross-spectra, assuming that the ship is the input and the sat is the output
    # data, we do this:
    #
    gmt gmtconvert -A samp_ship.pg samp_sat.pg -o1,3 | spectrum1d -S256 -D1 -W -C > /dev/null
    #
    # Now we want to plot the spectra. The following commands will plot the ship and sat
    # power in one diagram and the coherency on another diagram, both on the same page.
    # Note the extended use of pstext and psxy to put labels and legends directly on the plots.
    # For that purpose we often use -Jx1i and specify positions in inches directly:
    #
    psxy spectrum.coh -Bxa1f3p+l"Wavelength (km)" -Bya0.25f0.05+l"Coherency@+2@+" -BWeSn+g240/255/240 \
         -JX-4il/3.75i -R1/1000/0/1 -U/-2.25i/-1.25i/"Example 3 in Cookbook" -P -K -X2.5i -Sc0.07i \
         -Gmagenta -Ey/0.5p -Y1.5i > $ps
    echo "3.85 3.6 Coherency@+2@+" | pstext -R0/4/0/3.75 -Jx1i -F+f18p,Helvetica-Bold+jTR -O -K >> $ps
    psxy -Bxa1f3p -Bya1f3p+l"Power (mGal@+2@+km)" -BWeSn+t"Ship and Satellite Gravity" spectrum.xpower \
         -Gred -ST0.07i -O -R1/1000/0.1/10000 -JX-4il/3.75il -Y4.2i -K -Ey/0.5p >> $ps
    psxy spectrum.ypower -R -JX -O -K -Gblue -Sc0.07i -Ey/0.5p >> $ps
    echo "3.9 3.6 Input Power" | pstext -R0/4/0/3.75 -Jx -F+f18p,Helvetica-Bold+jTR -O -K >> $ps
    psxy -R -Jx -O -K -Gwhite -L -Wthicker >> $ps << END
    0.25 0.25
    1.4 0.25
    1.4 0.9
    0.25 0.9
    END
    echo "0.4 0.7" | psxy -R -Jx -O -K -ST0.07i -Gblack >> $ps
    echo "0.5 0.7 Ship" | pstext -R -Jx -F+f14p,Helvetica-Bold+jLM -O -K >> $ps
    echo "0.4 0.4" | psxy -R -Jx -O -K -Sc0.07i -Gblack >> $ps
    echo "0.5 0.4 Satellite" | pstext -R -Jx -F+f14p,Helvetica-Bold+jLM -O >> $ps
    #
    # Now we wonder if removing that large feature at 250 km would make any difference.
    # We could throw away a section of data with awk or sed or head and tail, but we
    # demonstrate the use of "trend1d" to identify outliers instead. We will fit a
    # straight line to the samp_ship.pg data by an iteratively-reweighted method and
    # save the weights on output. Then we will plot the weights and see how things
    # look:
    #
    trend1d -Fxw -N2r samp_ship.pg > samp_ship.xw
    psxy $R -JX8i/4i -X2i -Y1.5i -K -Sp0.03i \
         -Bxa500f100+l"Distance along great circle" -Bya100f25+l"Gravity anomaly (mGal)" -BWeSn \
         -U/-1.75i/-1.25i/"Example 3d in Cookbook" samp_ship.pg > ../example_03d.ps
    R=‘minmax samp_ship.xw -I100/1.1‘
    psxy $R -JX8i/1.1i -O -Y4.25i -Bxf100 -Bya0.5f0.1+l"Weight" -BWesn -Sp0.03i samp_ship.xw \
         >> ../example_03d.ps
    #
    # From this we see that we might want to throw away values where w < 0.6. So we try that,
    # and this time we also use trend1d to return the residual from the model fit (the
    # de-trended data):
    trend1d -Fxrw -N2r samp_ship.pg | awk '{ if ($3 > 0.6) print $1, $2 }' \
         | sample1d -Nsamp.x > samp2_ship.pg
    trend1d -Fxrw -N2r samp_sat.pg | awk '{ if ($3 > 0.6) print $1, $2 }' \
         | sample1d -Nsamp.x > samp2_sat.pg
    #
    # We plot these to see how they look:
    #
    R=‘cat samp2_sat.pg samp2_ship.pg | minmax -I100/25‘
    psxy $R -JX8i/5i -X2i -Y1.5i -K -Wthick \
         -Bxa500f100:+l"Distance along great circle" -Bya50f25+l"Gravity anomaly (mGal)" -BWeSn \
         -U/-1.75i/-1.25i/"Example 3e in Cookbook" samp2_sat.pg > ../example_03e.ps
    psxy -R -JX -O -Sp0.03i samp2_ship.pg >> ../example_03e.ps
    #
    # Now we do the cross-spectral analysis again. Comparing this plot (example_03e.ps) with
    # the previous one (example_03d.ps) we see that throwing out the large feature has reduced
    # the power in both data sets and reduced the coherency at wavelengths between 20--60 km.
    #
    gmtconvert -A samp2_ship.pg samp2_sat.pg -o1,3 | spectrum1d -S256 -D1 -W -C > /dev/null
    #
    psxy spectrum.coh -Bxa1f3p+l"Wavelength (km)" -Bya0.25f0.05+l"Coherency@+2@+" -BWeSn -JX-4il/3.75i \
         -R1/1000/0/1 -U/-2.25i/-1.25i/"Example 3f in Cookbook" -P -K -X2.5i -Sc0.07i -Gblack \
         -Ey/0.5p -Y1.5i > ../example_03f.ps
    echo "3.85 3.6 Coherency@+2@+" | pstext -R0/4/0/3.75 -Jx -F+f18p,Helvetica-Bold+jTR -O \
         -K >> ../example_03f.ps
    cat > box.d << END
    2.375 3.75
    2.375 3.25
    4 3.25
    END
    psxy -R -Jx -O -K -Wthicker box.d >> ../example_03f.ps
    psxy -Bxa1f3p -Bya1f3p+l"Power (mGal@+2@+km)" -BWeSn+t"Ship and Satellite Gravity" spectrum.xpower \
    -ST0.07i -O -R1/1000/0.1/10000 -JX-4il/3.75il -Y4.2i -K -Ey/0.5p >> ../example_03f.ps
    psxy spectrum.ypower -R -JX -O -K -Gblack -Sc0.07i -Ey/0.5p >> ../example_03f.ps
    echo "3.9 3.6 Input Power" | pstext -R0/4/0/3.75 -Jx -F+f18p,Helvetica-Bold+jTR -O \
         -K >> ../example_03f.ps
    psxy -R -Jx -O -K -Wthicker box.d >> ../example_03f.ps
    psxy -R -Jx -O -K -Glightgray -L -Wthicker >> ../example_03f.ps << END
    0.25 0.25
    1.4 0.25
    1.4 0.9
    0.25 0.9
    END
    echo "0.4 0.7" | psxy -R -Jx -O -K -ST0.07i -Gblack >> ../example_03f.ps
    echo "0.5 0.7 Ship" | pstext -R -Jx -F+f14p,Helvetica-Bold+jLM -O -K >> ../example_03f.ps
    echo "0.4 0.4" | psxy -R -Jx -O -K -Sc0.07i -Gblack >> ../example_03f.ps
    echo "0.5 0.4 Satellite" | pstext -R -Jx -F+f14p,Helvetica-Bold+jLM -O >> ../example_03f.ps
    #
    rm -f box.d report tmp samp* *.pg *.extr spectrum.*

The final illustration (Figure [fig:example:sub:`0`\ 3]) shows that the
ship gravity anomalies have more power than altimetry derived gravity
for short wavelengths and that the coherency between the two signals
improves dramatically for wavelengths > 20 km.

.. include:: fig_includes/fig_example_03.rst_

A 3-D perspective mesh plot
---------------------------

This example will illustrate how to make a fairly complicated composite
figure. We need a subset of the ETOPO5 bathymetry [24]_ and Geosat geoid
data sets which we will extract from the local data bases using
`grdraster <grdraster.html>`__. We would like to show a
2-layer perspective plot where layer one shows a contour map of the
marine geoid with the location of the Hawaiian islands superposed, and a
second layer showing the 3-D mesh plot of the topography. We also add an
arrow pointing north and some text. The first part of this script shows
how to do it:

   ::

    #!/bin/bash
    #		GMT EXAMPLE 04
    #		$Id: example_04.sh 11031 2013-03-02 01:27:34Z pwessel $
    #
    # Purpose:	3-D mesh and color plot of Hawaiian topography and geoid
    # GMT progs:	grdcontour, grdgradient, grdimage, grdview, psbasemap, pscoast, pstext
    # Unix progs:	echo, rm
    #
    ps=example_04.ps
    echo '-10  255   0  255' > zero.cpt
    echo '  0  100  10  100' >> zero.cpt
    grdcontour HI_geoid4.nc -R195/210/18/25 -Jm0.45i -p60/30 -C1 -A5+o -Gd4i -K -P \
    	-X1.25i -Y1.25i -UL/-0.5i/-1i/"Example 4 in Cookbook" > $ps
    pscoast -R -J -p -B2 -WNEsw -Gblack -O -K -T209/19.5/1i >> $ps
    grdview HI_topo4.nc -R195/210/18/25/-6/4 -J -Jz0.34i -p -Czero.cpt -O -K \
    	-N-6/lightgray -Qsm -B2 -Bz2+l"Topo (km)" -BneswZ -Y2.2i >> $ps
    echo '3.25 5.75 H@#awaiian@# R@#idge' | pstext -R0/10/0/10 -Jx1i \
    	-F+f60p,ZapfChancery-MediumItalic+jCB -O >> $ps
    rm -f zero.cpt
    #
    ps=example_04c.ps
    grdgradient HI_geoid4.nc -A0 -Gg_intens.nc -Nt0.75 -fg
    grdgradient HI_topo4.nc -A0 -Gt_intens.nc -Nt0.75 -fg
    grdimage HI_geoid4.nc -Ig_intens.nc -R195/210/18/25 -JM6.75i -p60/30 -Cgeoid.cpt -E100 -K -P \
    	-X1.25i -Y1.25i -UL/-0.5i/-1i/"Example 4c in Cookbook" > $ps
    pscoast -R -J -p -B2 -BNEsw -Gblack -O -K >> $ps
    psbasemap -R -J -p -O -K -T209/19.5/1i --COLOR_BACKGROUND=red --FONT=red \
    	--MAP_TICK_PEN_PRIMARY=thinner,red >> $ps
    psscale -R -J -p240/30 -D3.375i/-0.5i/5i/0.3ih -Cgeoid.cpt -I -O -K -Bx2+lGeoid (m)" >> $ps
    grdview HI_topo4.nc -It_intens.nc -R195/210/18/25/-6/4 -J -JZ3.4i -p60/30 -Ctopo.cpt -O -K \
    	-N-6/lightgray -Qc100 -B2 -Bz2+l"Topo (km)" -BneswZ -Y2.2i >> $ps
    echo '3.25 5.75 H@#awaiian@# R@#idge' | pstext -R0/10/0/10 -Jx1i \
    	-F+f60p,ZapfChancery-MediumItalic+jCB -O >> $ps
    rm -f *_intens.nc

The purpose of the color palette file ``zero.cpt`` is to have the positive topography
mesh painted light gray (the remainder is white). The left side of
Figure shows the complete illustration.

.. include:: fig_includes/fig_example_04.rst_

The second part of the script shows how to make the color version of
this figure that was printed in our first article in *EOS Trans. AGU* (8
October 1991). Using `grdview <grdview.html>`_ one can
choose to either plot a mesh surface (left) or a color-coded surface
(right). We have also added artificial illumination from a light-source
due north, which is simulated by computing the gradient of the surface
grid in that direction though the
`grdgradient <grdgradient.html>`_ program. We choose to
use the **-Qc** option in `grdview <grdview.html>`_ to
achieve a high degree of smoothness. Here, we select 100 dpi since that
will be the resolution of our final raster (The EOS raster was 300 dpi).
Note that the size of the resulting output file is directly dependent on
the square of the dpi chosen for the scanline conversion and how well
the resulting image compresses. A higher value for dpi in **-Qc** would
have resulted in a much larger output file. The CPT files were taken
from Section [sec:example\ :sub:`0`\ 2].

A 3-D illuminated surface in black and white
--------------------------------------------

Instead of a mesh plot we may choose to show 3-D surfaces using
artificial illumination. For this example we will use
`grdmath <grdmath.html>`_ to make a grid file that
contains the surface given by the function
:math:`z(x, y) = \cos (2\pi r/8)\cdot e^{-r/10}`, where
:math:`r^2 = (x^2 + y^2)`. The illumination is obtained by passing two
grid files to `grdview <grdview.html>`_: One with the
*z*-values (the surface) and another with intensity values (which should
be in the 1 range). We use
`grdgradient <grdgradient.html>`_ to compute the
horizontal gradients in the direction of the artificial light source.
The ``gray.cpt`` file only has one line that states that all *z* values should have
the gray level 128. Thus, variations in shade are entirely due to
variations in gradients, or illuminations. We choose to illuminate from
the SW and view the surface from SE:

   ::

    #!/bin/bash
    #		GMT EXAMPLE 05
    #
    # Purpose:	Generate grid and show monochrome 3-D perspective
    # GMT progs:	grdgradient, grdmath, grdview, pstext
    # Unix progs:	echo, rm
    #
    ps=example_05.ps
    grdmath -R-15/15/-15/15 -I0.3 X Y HYPOT DUP 2 MUL PI MUL 8 DIV COS EXCH NEG 10 DIV \
    	EXP MUL = sombrero.nc
    echo '-5 128 5 128' > gray.cpt
    grdgradient sombrero.nc -A225 -Gintensity.nc -Nt0.75
    grdview sombrero.nc -JX6i -JZ2i -B5 -B0.5 -BSEwnZ -N-1/white -Qs -Iintensity.nc -X1.5i \
    	-Cgray.cpt -R-15/15/-15/15/-1/1 -K -p120/30 -UL/-1.25i/-0.75i/"Example 5 in Cookbook" > $ps
    echo "4.1 5.5 z(r) = cos (2@~p@~r/8) @~\327@~e@+-r/10@+" | pstext -R0/11/0/8.5 -Jx1i \
    	-F+f50p,ZapfChancery-MediumItalic+jBC -O >> $ps
    rm -f gray.cpt sombrero.nc intensity.nc

The variations in intensity could be made more dramatic by using
`grdmath <grdmath.html>`_ to scale the intensity file
before running `grdview <grdview.html>`_. For very rough
data sets one may improve the smoothness of the intensities by passing
the output of `grdgradient <grdgradient.html>`_ to
`grdhisteq <grdhisteq.html>`_. The shell-script above
will result in a plot like the one in Figure [fig:example\ :sub:`0`\ 5].

.. include:: fig_includes/fig_example_05.rst_

Plotting of histograms
----------------------

*GMT* provides two tools to render histograms:
`pshistogram <pshistogram.html>`_ and `psrose <psrose.html>`_. The former takes care of
regular histograms whereas the latter deals with polar histograms (rose
diagrams, sector diagrams, and wind rose diagrams). We will show an
example that involves both programs. The file ``fractures.yx`` contains a compilation of
fracture lengths and directions as digitized from geological maps. The
file ``v3206.t`` contains all the bathymetry measurements from *Vema* cruise 3206.
Our complete figure (Figure [fig:example:sub:`0`\ 6]) was made running
this script:

   ::

    #!/bin/bash
    #		GMT EXAMPLE 06
    #
    # Purpose:	Make standard and polar histograms
    # GMT progs:	pshistogram, psrose
    # Unix progs:	rm
    #
    ps=example_06.ps
    psrose fractures.d -: -A10r -S1.8in -UL/-2.25i/-0.75i/"Example 6 in Cookbook" -P -Gorange \
    	-R0/1/0/360 -X2.5i -K -Bx0.2g0.2 -By30g30 -B+glightblue -W1p > $ps
    pshistogram -Bxa2000f1000+l"Topography (m)" -Bya10f5+l"Frequency"+u% -BWSne+t"Histograms"+glightblue \
    	v3206.t -R-6000/0/0/30 -JX4.8i/2.4i -Gorange -O -Y5.5i -X-0.5i -L1p -Z1 -W250 >> $ps

.. include:: fig_includes/fig_example_06.rst_

A simple location map
---------------------

Many scientific papers start out by showing a location map of the region
of interest. This map will typically also contain certain features and
labels. This example will present a location map for the equatorial
Atlantic ocean, where fracture zones and mid-ocean ridge segments have
been plotted. We also would like to plot earthquake locations and
available isochrons. We have obtained one file, ``quakes.xym``, which contains the
position and magnitude of available earthquakes in the region. We choose
to use magnitude/100 for the symbol-size in inches. The digital fracture
zone traces (``fz.xy``) and isochrons (0 isochron as ``ridge.xy``, the rest as ``isochrons.xy``) were
digitized from available maps [25]_. We create the final location map
(Figure [fig:example:sub:`0`\ 7]) with the following script:

   ::

    #!/bin/bash
    #		GMT EXAMPLE 07
    #
    # Purpose:	Make a basemap with earthquakes and isochrons etc
    # GMT progs:	pscoast, pstext, psxy
    # Unix progs:	echo, rm
    #
    ps=example_07.ps
    pscoast -R-50/0/-10/20 -JM9i -K -Slightblue -GP300/26:FtanBdarkbrown -Dl -Wthinnest \
    	-B10 -U"Example 7 in Cookbook" --FORMAT_GEO_MAP=dddF > $ps
    psxy -R -J -O -K fz.xy -Wthinner,- >> $ps
    psxy quakes.xym -R -J -O -K -h1 -Sci+s0.01 -Gred -Wthinnest >> $ps
    psxy -R -J -O -K isochron.xy -Wthin,blue >> $ps
    psxy -R -J -O -K ridge.xy -Wthicker,orange >> $ps
    psxy -R -J -O -K -Gwhite -Wthick -A >> $ps << END
    -14.5	15.2
     -2	15.2
     -2	17.8
    -14.5	17.8
    END
    psxy -R -J -O -K -Gwhite -Wthinner -A >> $ps << END
    -14.35	15.35
     -2.15	15.35
     -2.15	17.65
    -14.35	17.65
    END
    echo "-13.5 16.5" | psxy -R -J -O -K -Sc0.08i -Gred -Wthinner >> $ps
    echo "-12.5 16.5 ISC Earthquakes" | pstext -R -J -F+f18p,Times-Italic+jLM -O -K >> $ps
    pstext -R -J -O -F+f30,Helvetica-Bold,white=thin >> $ps << END
    -43 -5 SOUTH
    -43 -8 AMERICA
     -7 11 AFRICA
    END

.. include:: fig_includes/fig_example_07.rst_

The same figure could equally well be made in color, which could be
rasterized and made into a slide for a meeting presentation. The script
is similar to the one outlined above, except we would choose a color for
land and oceans, and select colored symbols and pens rather than black
and white.

A 3-D histogram
---------------

The program `psxyz <psxyz.html>`_ allows us to plot
three-dimensional symbols, including columnar plots. As a simple
demonstration, we will convert a gridded netCDF of bathymetry into an
ASCII *xyz* table and use the height information to draw a 2-D
histogram in a 3-D perspective view. Our gridded bathymetry file is
called ``guinea_bay.nc`` and covers the region from 0 to 5 E and 0 to 5 N. Depth ranges
from -5000 meter to sea-level. We produce the
Figure [fig:example\ :sub:`0`\ 8] by running this script:

   ::

    #!/bin/bash
    #		GMT EXAMPLE 08
    #		$Id: example_08.sh 9872 2012-03-15 20:57:29Z remko $
    #
    # Purpose:	Make a 3-D bar plot
    # GMT progs:	grd2xyz, pstext, psxyz
    # Unix progs:	echo, rm
    #
    ps=example_08.ps
    grd2xyz guinea_bay.nc | psxyz -B1 -Bz1000:+l"Topography (m)" -BWSneZ+b+tETOPO5 \
    	-R-0.1/5.1/-0.1/5.1/-5000/0 -JM5i -JZ6i -p200/30 -So0.0833333ub-5000 -P \
    	-U"Example 8 in Cookbook" -Wthinnest -Glightgreen -K > $ps
    echo '0.1 4.9 This is the surface of cube' | pstext -R -J -JZ -Z0 \
    	-F+f24p,Helvetica-Bold+jTL -p -O >> $ps

.. include:: fig_includes/fig_example_08.rst_

Plotting time-series along tracks
---------------------------------

A common application in many scientific disciplines involves plotting
one or several time-series as as "wiggles" along tracks. Marine
geophysicists often display magnetic anomalies in this manner, and
seismologists use the technique when plotting individual seismic traces.
In our example we will show how a set of Geosat sea surface slope
profiles from the south Pacific can be plotted as "wiggles" using the
`pswiggle <pswiggle.html>`_ program. We will embellish
the plot with track numbers, the location of the Pacific-Antarctic
Ridge, recognized fracture zones in the area, and a "wiggle" scale. The
Geosat tracks are stored in the file ``tracks.txt``, the ridge in ``ridge.xy``, and all the
fracture zones are stored in the multiple segment file ``fz.xy``. The
profile id is contained in the segment headers and we wish to use the
last data point in each of the track segments to construct an input file
for `pstext <pstext.html>`_ that will label each profile
with the track number. We know the profiles trend approximately N40E so
we want the labels to have that same orientation (i.e., the angle with
the baseline must be 50). We do this by extracting the last record from
each track and select segment header as textstring when running
the output through `pstext <pstext.html>`_. Note we
offset the positions by -0.05 inch with **-D** in order to have a small
gap between the profile and the label:

   ::

    #!/bin/bash
    #		GMT EXAMPLE 09
    #		$Id: example_09.sh 11031 2013-03-02 01:27:34Z pwessel $
    #
    # Purpose:	Make wiggle plot along track from geoid deflections
    # GMT progs:	gmtconvert, pswiggle, pstext, psxy
    # Unix progs:	
    #
    ps=example_09.ps
    gmt pswiggle tracks.txt -R185/250/-68/-42 -U"Example 9 in Cookbook" -K -Jm0.13i \
    	-Ba10f5 -BWSne+g240/255/240 -G+red -G-blue -Z2000 -Wthinnest -S240/-67/500/@~m@~rad \
    	--FORMAT_GEO_MAP=dddF > $ps
    gmt psxy -R -J -O -K ridge.xy -Wthicker >> $ps
    gmt psxy -R -J -O -K fz.xy -Wthinner,- >> $ps
    # Take label from segment header and plot near coordinates of last record of each track
    gmt gmtconvert -El tracks.txt | gmt pstext -R -J -F+f10p,Helvetica-Bold+a50+jRM+h \
        -D-0.05i/-0.05i -O >> $ps

The output shows the sea-surface slopes along 42 descending Geosat
tracks in the Eltanin and Udintsev fracture zone region in a Mercator
projection.

.. include:: fig_includes/fig_example_09.rst_

A geographical bar graph plot
-----------------------------

Our next and perhaps most business-like example presents a
three-dimensional bar graph plot showing the geographic distribution of
the membership in the American Geophysical Union (AGU). The input data
was taken from the January 2008 AGU member directory and added up to
give total members per continent. We decide to plot a 3-D column
centered on each continent with a height that is proportional to the
logarithm of the membership. A log\ :math:`_{10}`-scale is used since
the memberships vary by almost 3 orders of magnitude. We choose a plain
linear projection for the basemap and add the columns and text on top.
Our script that produces Figure ex_10 reads:

   ::

    #!/bin/bash
    #		GMT EXAMPLE 10
    #		$Id: example_10.sh 11031 2013-03-02 01:27:34Z pwessel $
    #
    # Purpose:	Make 3-D bar graph on top of perspective map
    # GMT progs:	pscoast, pstext, psxyz
    # Unix progs:	awk, rm
    #
    ps=example_10.ps
    pscoast -Rd -JX8id/5id -Dc -Slightblue -Glightbrown -Wfaint -A1000 -p200/40 -K \
    	-U"Example 10 in Cookbook" > $ps
    awk '{print $1, $2, $3}' agu2008.d \
    	| pstext -R -J -O -K -p -D-0.2i/0 -F+f20p,Helvetica-Bold,blue=thinner+jRM >> $ps
    psxyz agu2008.d -R-180/180/-90/90/1.01/100000 -J -JZ2.5il -So0.3ib1 -Gdarkgreen -Wthinner \
    	--FONT_TITLE=30p,Times-Bold --MAP_TITLE_OFFSET=-0.7i \
    	-Bx60g60 -By30g30 -Bza1p+lMemberships" -BWSneZ+t"AGU 2008 Membership Distribution" -O -p >> $ps

.. include:: fig_includes/fig_example_10.rst_

Making a 3-D RGB color cube
---------------------------

In this example we generate a series of 6 color images, arranged so that
they can be cut out and assembled into a 3-D color cube. The six faces
of the cube represent the outside of the R-G-B color space. On each face
one of the color components is fixed at either 0 or 255 and the other
two components vary smoothly across the face from 0 to 255. The cube is
configured as a right-handed coordinate system with *x-y-z* mapping
R-G-B. Hence, the 8 corners of the cube represent the primaries red,
green, and blue, plus the secondaries cyan, magenta and yellow, plus
black and white.

The 6 color faces are generated by feeding
`grdimage <grdimage.html>`_ three grids, one for each
color component (R, G, and B). In some cases the X or Y axes of a face
are reversed by specifying a negative width or height in order to change
the variation of the color value in that direction from ascending to
descending, or vice versa.

A number of rays emanating from the white and black corners indicate the
Hue value (ranging from 0 to 360). The dashed and dotted lines near the
white corner reflect saturation levels, running from 0 to 1 (in black
font). On these 3 faces the brightness is a constant value of 1. On the
other 3 faces of the cube, around the black corner, the white decimal
numbers indicate brightnesses between 0 and 1, with saturation fixed at
1.

Here is the shell script to generate the RGB cube in Figure [fig:example\ :sub:`1`\ 1]:

   ::

    #!/bin/bash
    #		GMT EXAMPLE 11
    #
    # Purpose:	Create a 3-D RGB Cube
    # GMT progs:	gmtset, grdimage, grdmath, pstext, psxy
    # Unix progs:	rm
    ps=example_11.ps
    
    # Use psxy to plot "cut-along-the-dotted" lines.
    
    gmtset MAP_TICK_LENGTH_PRIMARY 0
    
    psxy cut-here.dat -Wthinnest,. -R-51/306/0/1071 -JX3.5i/10.5i -X2.5i -Y0.5i \
    	-P -UL/-2.0i/-0.2i/"Example 11 in Cookbook" -K > $ps
    
    # First, create grids of ascending X and Y and constant 0.
    # These are to be used to represent R, G and B values of the darker 3 faces of the cube.
    
    grdmath -I1 -R0/255/0/255 X = x.nc
    grdmath -I1 -R Y = y.nc
    grdmath -I1 -R 0 = c.nc
    
    gmtset FONT_ANNOT_PRIMARY 12p,Helvetica-Bold
    
    grdimage x.nc y.nc c.nc -JX2.5i/-2.5i -R -K -O -X0.5i >> $ps
    psxy -Wthinner,white,- rays.dat -J -R -K -O >> $ps
    pstext --FONT=white -J -R -K -O -F+f+a >> $ps << END
    128 128 12p -45 60\217
    102  26 12p -90 0.4
    204  26 12p -90 0.8
    10  140 16p 180 G
    END
    echo 0 0 0 128 | psxy -N -Sv0.15i+s+e -Gwhite -W2p,white -J -R -K -O >> $ps
    
    grdimage x.nc c.nc y.nc -JX2.5i/2.5i -R -K -O -Y2.5i >> $ps
    psxy -Wthinner,white,- rays.dat -J -R -K -O >> $ps
    pstext --FONT=white -J -R -K -O -F+f+a >> $ps << END
    128 128 12p  45 300\217
    26  102 12p   0 0.4
    26  204 12p   0 0.8
    140  10 16p -90 R
    100 100 16p -45 V
    END
    echo 0 0 128 0 | psxy -N -Sv0.15i+s+e -Gwhite -W2p,white -J -R -K -O >> $ps
    echo 0 0 90 90 | psxy -N -Sv0.15i+s+e -Gwhite -W2p,white -J -R -K -O >> $ps
    
    grdimage c.nc x.nc y.nc -JX-2.5i/2.5i -R -K -O -X-2.5i >> $ps
    psxy -Wthinner,white,- rays.dat -J -R -K -O >> $ps
    pstext --FONT=white -J -R -K -O -F+f+a >> $ps << END
    128 128 12p 135 180\217
    102  26 12p  90 0.4
    204  26 12p  90 0.8
    10  140 16p   0 B
    END
    echo 0 0 0 128 | psxy -N -Sv0.15i+s+e -Gwhite -W2p,white -J -R -K -O >> $ps
    echo 0 0 128 0 | psxy -N -Sv0.15i+s+e -Gwhite -W2p,white -J -R -K -O >> $ps
    
    # Second, create grids of descending X and Y and constant 255.
    # These are to be used to represent R, G and B values of the lighter 3 faces of the cube.
    
    grdmath -I1 -R 255 X SUB = x.nc
    grdmath -I1 -R 255 Y SUB = y.nc
    grdmath -I1 -R 255       = c.nc
    
    grdimage x.nc y.nc c.nc -JX-2.5i/-2.5i -R -K -O -X2.5i -Y2.5i >> $ps
    psxy -Wthinner,black,- rays.dat -J -R -K -O >> $ps
    pstext -J -R -K -O -F+f+a >> $ps << END
    128 128 12p 225 240\217
    102  26 12p 270 0.4
    204  26 12p 270 0.8
    END
    
    grdimage c.nc y.nc x.nc -JX2.5i/-2.5i -R -K -O -X2.5i >> $ps
    psxy -Wthinner,black,- rays.dat -J -R -K -O >> $ps
    pstext -J -R -K -O -F+f+a >> $ps << END
    128 128 12p -45 0\217
    26  102 12p   0 0.4
    26  204 12p   0 0.8
    100 100 16p  45 S
    204  66 16p  90 H
    END
    echo 0 0 90 90 | psxy -N -Sv0.15i+s+e -Gblack -W2p -J -R -K -O >> $ps
    echo 204 204 204 76 | psxy -N -Sv0.15i+s+e -Gblack -W2p -J -R -K -O >> $ps
    
    grdimage x.nc c.nc y.nc -JX-2.5i/2.5i -R -K -O -X-2.5i -Y2.5i >> $ps
    psxy -Wthinner,black,- rays.dat -J -R -K -O >> $ps
    pstext -J -R -O -F+f+a >> $ps << END
    128 128 12p 135 120\217
    26  102 12p 180 0.4
    26  204 12p 180 0.8
    200 200 16p 225 GMT 5
    END
    
    rm -f *.nc gmt.conf

.. include:: fig_includes/fig_example_11.rst_

Optimal triangulation of data
-----------------------------

[sec:example:sub:`1`\ 2]

Our next example (Figure [fig:example:sub:`1`\ 2]) operates on a data
set of topographic readings non-uniformly distributed in the plane
(Table 5.11 in Davis: *Statistics and Data Analysis in Geology*, J.
Wiley). We use `triangulate <triangulate.html>`_ to
perform the optimal Delaunay triangulation, then use the output to draw
the resulting network. We label the node numbers as well as the node
values, and call `pscontour <pscontour.html>`_ to make a
contour map and image directly from the raw data. Thus, in this example
we do not actually make grid files but still are able to contour and
image the data. We use a color palette table ``topo.cpt`` (created via
`minmax <minmax.html>`_ and
`makecpt <makecpt.html>`_). The script becomes:

   ::

    #!/bin/bash
    #		GMT EXAMPLE 12
    #
    # Purpose:	Illustrates Delaunay triangulation of points, and contouring
    # GMT progs:	makecpt, minmax, pscontour, pstext, psxy, triangulate
    # Unix progs:	awk, echo, rm
    #
    # First draw network and label the nodes
    #
    ps=example_12.ps
    triangulate table_5.11 -M > net.xy
    psxy -R0/6.5/-0.2/6.5 -JX3.06i/3.15i -B2f1 -BWSNe net.xy -Wthinner -P -K -X0.9i -Y4.65i > $ps
    psxy table_5.11 -R -J -O -K -Sc0.12i -Gwhite -Wthinnest >> $ps
    awk '{print $1, $2, NR-1}' table_5.11 | pstext -R -J -F+f6p -O -K >> $ps
    #
    # Then draw network and print the node values
    #
    psxy -R -J -B2f1 -BeSNw net.xy -Wthinner -O -K -X3.25i >> $ps
    psxy -R -J -O -K table_5.11 -Sc0.03i -Gblack >> $ps
    pstext table_5.11 -R -J -F+f6p+jLM -O -K -Gwhite -W -C0.01i -D0.08i/0i -N >> $ps
    #
    # Then contour the data and draw triangles using dashed pen; use "minmax" and "makecpt" to make a
    # color palette (.cpt) file
    #
    T=`minmax -T25/2 table_5.11`
    makecpt -Cjet $T > topo.cpt
    pscontour -R -J table_5.11 -B2f1 -BWSne -Wthin -Ctopo.cpt -Lthinnest,- -Gd1i -X-3.25i -Y-3.65i \
    	-O -K -U"Example 12 in Cookbook" >> $ps
    #
    # Finally color the topography
    #
    pscontour -R -J table_5.11 -B2f1 -BeSnw -Ctopo.cpt -I -X3.25i -O -K >> $ps
    echo "3.16 8 Delaunay Triangulation" | \
    	pstext -R0/8/0/11 -Jx1i -F+f30p,Helvetica-Bold+jCB -O -X-3.25i >> $ps
    #
    rm -f net.xy topo.cpt

.. include:: fig_includes/fig_example_12.rst_

Plotting of vector fields
-------------------------

In many areas, such as fluid dynamics and elasticity, it is desirable to
plot vector fields of various kinds. *GMT* provides a way to illustrate
2-component vector fields using the
`grdvector <grdvector.html>`_ utility. The two
components of the field (Cartesian or polar components) are stored in
separate grid files. In this example we use
`grdmath <grdmath.html>`_ to generate a surface
:math:`z(x, y) = x \cdot \exp(-x^2 -y^2)` and to calculate
:math:`\nabla z` by returning the *x*- and *y*-derivatives separately.
We superpose the gradient vector field and the surface *z* and also plot
the components of the gradient in separate windows. A
`pstext <pstext.html>`_ call to place a header finishes
the plot (Figure [fig:example:sub:`1`\ 3]:

   ::

    #!/bin/bash
    #		GMT EXAMPLE 13
    #
    # Purpose:	Illustrate vectors and contouring
    # GMT progs:	grdmath, grdcontour, grdvector, pstext
    # Unix progs:	echo, rm
    #
    ps=example_13.ps
    grdmath -R-2/2/-2/2 -I0.1 X Y R2 NEG EXP X MUL = z.nc
    grdmath z.nc DDX = dzdx.nc
    grdmath z.nc DDY = dzdy.nc
    grdcontour dzdx.nc -JX3i -B1 -BWSne -C0.1 -A0.5 -K -P -Gd2i -S4 -T0.1i/0.03i \
    	-U"Example 13 in Cookbook" > $ps
    grdcontour dzdy.nc -J -B -C0.05 -A0.2 -O -K -Gd2i -S4 -T0.1i/0.03i -Xa3.45i >> $ps
    grdcontour z.nc -J -B -C0.05 -A0.1 -O -K -Gd2i -S4 -T0.1i/0.03i -Y3.45i >> $ps
    grdcontour z.nc -J -B -C0.05 -O -K -Gd2i -S4 -X3.45i >> $ps
    grdvector dzdx.nc dzdy.nc -I0.2 -J -O -K -Q0.1i+e+n0.25i -Gblack -W1p -S5i \
    	--MAP_VECTOR_SHAPE=0.5 >> $ps
    echo "3.2 3.6 z(x,y) = x@~\327@~exp(-x@+2@+-y@+2@+)" \
    	| pstext -R0/6/0/4.5 -Jx1i -F+f40p,Times-Italic+jCB -O -X-3.45i >> $ps
    rm -f z.nc dzdx.nc dzdy.nc

.. include:: fig_includes/fig_example_13.rst_

Gridding of data and trend surfaces
-----------------------------------

This example shows how one goes from randomly spaced data points to an
evenly sampled surface. First we plot the distribution and values of our
raw data set (same as in Section [sec:example\ :sub:`1`\ 2]). We choose an equidistant grid and run
`blockmean <blockmean.html>`_ which preprocesses the
data to avoid aliasing. The dashed lines indicate the logical blocks
used by `blockmean <blockmean.html>`_; all points inside
a given bin will be averaged. The logical blocks are drawn from a
temporary file we make on the fly within the shell script. The processed
data is then gridded with the `surface <surface.html>`_
program and contoured every 25 units. A most important point here is
that `blockmean <blockmean.html>`_, `blockmedian <blockmedian.html>`_, or
`blockmode <blockmode.html>`_ should always be run prior
to running `surface <surface.html>`_, and both of these
steps must use the same grid interval. We use
`grdtrend <grdtrend.html>`_ to fit a bicubic trend
surface to the gridded data, contour it as well, and sample both grid
files along a diagonal transect using
`grdtrack <grdtrack.html>`_. The bottom panel compares
the gridded (solid line) and bicubic trend (dashed line) along the
transect using `psxy <psxy.html>`_
(Figure [fig:example:sub:`1`\ 4]):

   ::

    #!/bin/bash
    #		GMT EXAMPLE 14
    #
    # Purpose:	Showing simple gridding, contouring, and resampling along tracks
    # GMT progs:	blockmean, grdcontour, grdtrack, grdtrend, minmax, project
    # GMT progs:	gmtset, pstext, psbasemap, psxy, surface
    # Unix progs:	rm
    #
    ps=example_14.ps
    
    # First draw network and label the nodes
    
    gmtset MAP_GRID_PEN_PRIMARY thinnest,-
    psxy table_5.11 -R0/7/0/7 -JX3.06i/3.15i -B2f1 -BWSNe -Sc0.05i -Gblack -P -K -Y6.45i > $ps
    pstext table_5.11 -R -J -D0.1c/0 -F+f6p+jLM -O -K -N >> $ps
    blockmean table_5.11 -R0/7/0/7 -I1 > mean.xyz
    
    # Then draw blockmean cells
    
    psbasemap -R0.5/7.5/0.5/7.5 -J -O -K -Bg1 -X3.25i >> $ps
    psxy -R0/7/0/7 -J -B2f1 -BeSNw mean.xyz -Ss0.05i -Gblack -O -K >> $ps
    # Reformat to one decimal for annotation purposes
    gmtconvert mean.xyz --FORMAT_FLOAT_OUT=%.1f | \
    	pstext -R -J -D0.15c/0 -F+f6p+jLM -O -K -Gwhite -W -C0.01i -N >> $ps
    
    # Then surface and contour the data
    
    surface mean.xyz -R -I1 -Gdata.nc
    grdcontour data.nc -J -B2f1 -BWSne -C25 -A50 -Gd3i -S4 -O -K -X-3.25i -Y-3.55i >> $ps
    psxy -R -J mean.xyz -Ss0.05i -Gblack -O -K >> $ps
    
    # Fit bicubic trend to data and compare to gridded surface
    
    grdtrend data.nc -N10 -Ttrend.nc
    project -C0/0 -E7/7 -G0.1 -N > track
    grdcontour trend.nc -J -B2f1 -BwSne -C25 -A50 -Glct/cb -S4 -O -K -X3.25i >> $ps
    psxy -R -J track -Wthick,. -O -K >> $ps
    
    # Sample along diagonal
    
    grdtrack track -Gdata.nc -o2,3 > data.d
    grdtrack track -Gtrend.nc -o2,3 > trend.d
    psxy `minmax data.d trend.d -I0.5/25` -JX6.3i/1.4i data.d -Wthick -O -K -X-3.25i -Y-1.9i \
    	-Bx1 -By50 -BWSne >> $ps
    psxy -R -J trend.d -Wthinner,- -O -U"Example 14 in Cookbook" >> $ps
    
    rm -f mean.xyz track *.nc *.d gmt.conf

.. include:: fig_includes/fig_example_14.rst_

Gridding, contouring, and masking of unconstrained areas
--------------------------------------------------------

[sec:example:sub:`1`\ 5]

This example (Figure [fig:example:sub:`1`\ 5]) demonstrates some off the
different ways one can use to grid data in *GMT*, and how to deal with
unconstrained areas. We first convert a large ASCII file to binary with
`gmtconvert <gmtconvert.html>`_ since the binary file
will read and process much faster. Our lower left plot illustrates the
results of gridding using a nearest neighbor technique
(`nearneighbor <nearneighbor.html>`_) which is a local
method: No output is given where there are no data. Next (lower right),
we use a minimum curvature technique
(`surface <surface.html>`_) which is a global method.
Hence, the contours cover the entire map although the data are only
available for portions of the area (indicated by the gray areas plotted
using `psmask <psmask.html>`_). The top left scenario
illustrates how we can create a clip path (using
`psmask <psmask.html>`_) based on the data coverage to
eliminate contours outside the constrained area. Finally (top right) we
simply employ `pscoast <pscoast.html>`_ to overlay gray
land masses to cover up the unwanted contours, and end by plotting a
star at the deepest point on the map with
`psxy <psxy.html>`_. This point was extracted from the
grid files using `grdinfo <grdinfo.html>`_.

   ::

    #!/bin/bash
    #		GMT EXAMPLE 15
    #
    # Purpose:	Gridding and clipping when data are missing
    # GMT progs:	blockmedian, gmtconvert, grdclip, grdcontour, grdinfo, minmax
    # GMT progs:	nearneighbor, pscoast, psmask, pstext, surface
    # Unix progs:	echo, rm
    #
    ps=example_15.ps
    gmtconvert ship.xyz -bo > ship.b
    #
    region=`minmax ship.b -I1 -bi3`
    nearneighbor $region -I10m -S40k -Gship.nc ship.b -bi3
    grdcontour ship.nc -JM3i -P -B2 -BWSne -C250 -A1000 -Gd2i -K -U"Example 15 in Cookbook" > $ps
    #
    blockmedian $region -I10m ship.b -bi3 -bo > ship_10m.b
    surface $region -I10m ship_10m.b -Gship.nc -bi3
    psmask $region -I10m ship.b -J -O -K -T -Glightgray -bi3 -X3.6i >> $ps
    grdcontour ship.nc -J -B -C250 -L-8000/0 -A1000 -Gd2i -O -K >> $ps
    #
    psmask $region -I10m ship_10m.b -bi3 -J -B -O -K -X-3.6i -Y3.75i >> $ps
    grdcontour ship.nc -J -C250 -A1000 -L-8000/0 -Gd2i -O -K >> $ps
    psmask -C -O -K >> $ps
    #
    grdclip ship.nc -Sa-1/NaN -Gship_clipped.nc
    grdcontour ship_clipped.nc -J -B -C250 -A1000 -L-8000/0 -Gd2i -O -K -X3.6i >> $ps
    pscoast $region -J -O -K -Ggray -Wthinnest >> $ps
    grdinfo -C -M ship.nc | psxy -R -J -O -K -Sa0.15i -Wthick -i11,12 >> $ps
    echo "-0.3 3.6 Gridding with missing data" | pstext -R0/3/0/4 -Jx1i \
    	-F+f24p,Helvetica-Bold+jCB -O -N >> $ps
    rm -f ship.b ship_10m.b ship.nc ship_clipped.nc

.. include:: fig_includes/fig_example_15.rst_

Gridding of data, continued
---------------------------

`pscontour <pscontour.html>`_ (for contouring) and
`triangulate <triangulate.html>`_ (for gridding) use the
simplest method of interpolating data: a Delaunay triangulation (see
Section [sec:example\ :sub:`1`\ 2]) which forms *z(x, y)* as a
union of planar triangular facets. One advantage of this method is that
it will not extrapolate *z(x, y)* beyond the convex hull of the
input (*x, y*) data. Another is that it will not estimate a *z* value
above or below the local bounds on any triangle. A disadvantage is that
the *z(x, y)* surface is not differentiable, but has sharp kinks
at triangle edges and thus also along contours. This may not look
physically reasonable, but it can be filtered later (last panel below).
`surface <surface.html>`_ can be used to generate a
higher-order (smooth and differentiable) interpolation of
*z(x, y)* onto a grid, after which the grid may be illustrated
(`grdcontour <grdcontour.html>`_, `grdimage <grdimage.html>`_,
`grdview <grdview.html>`_).
`surface <surface.html>`_ will interpolate to all (*x,
y*) points in a rectangular region, and thus will extrapolate beyond the
convex hull of the data. However, this can be masked out in various ways
(see Section [sec:example\ :sub:`1`\ 5]).

A more serious objection is that `surface <surface.html>`_ may estimate *z* values
outside the local range of the data (note area near *x* = 0.8, *y* =
5.3). This commonly happens when the default tension value of zero is
used to create a "minimum curvature" (most smooth) interpolant.
`surface <surface.html>`_ can be used with non-zero
tension to partially overcome this problem. The limiting value
*tension = 1* should approximate the triangulation, while a value
between 0 and 1 may yield a good compromise between the above two cases.
A value of 0.5 is shown here (Figure [fig:example:sub:`1`\ 6]). A side
effect of the tension is that it tends to make the contours turn near
the edges of the domain so that they approach the edge from a
perpendicular direction. A solution is to use
`surface <surface.html>`_ in a larger area and then use
`grdcut <grdcut.html>`_ to cut out the desired smaller
area. Another way to achieve a compromise is to interpolate the data to
a grid and then filter the grid using `grdfft <grdfft.html>`_ or
`grdfilter <grdfilter.html>`_. The latter can handle
grids containing "NaN" values and it can do median and mode filters as
well as convolutions. Shown here is `triangulate <triangulate.html>`_ followed by
`grdfilter <grdfilter.html>`_. Note that the filter has
done some extrapolation beyond the convex hull of the original *x, y*
values. The "best" smooth approximation of *z(x, y)* depends on
the errors in the data and the physical laws obeyed by *z*. *GMT* cannot
always do the "best" thing but it offers great flexibility through its
combinations of tools. We illustrate all four solutions using a CPT file
that contains color fills, predefined patterns for interval (900,925)
and NaN, an image pattern for interval (875,900), and a "skip slice"
request for interval (700,725).

   ::

    #!/bin/bash
    #		GMT EXAMPLE 16
    #
    # Purpose:	Illustrates interpolation methods using same data as Example 12.
    # GMT progs:	gmtset, grdview, grdfilter, pscontour, psscale, pstext, surface, triangulate
    # Unix progs:	echo, rm
    #
    # Illustrate various means of contouring, using triangulate and surface.
    #
    ps=example_16.ps
    gmtset FONT_ANNOT_PRIMARY 9p
    #
    pscontour -R0/6.5/-0.2/6.5 -Jx0.45i -P -K -Y5.5i -Ba2f1 -BWSne table_5.11 -Cex16.cpt -I > $ps
    echo "3.25 7 pscontour (triangulate)" | pstext -R -J -O -K -N -F+f18p,Times-Roman+jCB >> $ps
    #
    surface table_5.11 -R -I0.2 -Graws0.nc
    grdview raws0.nc -R -J -B -Cex16.cpt -Qs -O -K -X3.5i >> $ps
    echo "3.25 7 surface (tension = 0)" | pstext -R -J -O -K -N -F+f18p,Times-Roman+jCB >> $ps
    #
    surface table_5.11 -R -I0.2 -Graws5.nc -T0.5
    grdview raws5.nc -R -J -B -Cex16.cpt -Qs -O -K -Y-3.75i -X-3.5i >> $ps
    echo "3.25 7 surface (tension = 0.5)" | pstext -R -J -O -K -N -F+f18p,Times-Roman+jCB >> $ps
    #
    triangulate table_5.11 -Grawt.nc -R -I0.2 > /dev/null
    grdfilter rawt.nc -Gfiltered.nc -D0 -Fc1
    grdview filtered.nc -R -J -B -Cex16.cpt -Qs -O -K -X3.5i >> $ps
    echo "3.25 7 triangulate @~\256@~ grdfilter" | pstext -R -J -O -K -N \
    	-F+f18p,Times-Roman+jCB >> $ps
    echo "3.2125 7.5 Gridding of Data" | pstext -R0/10/0/10 -Jx1i -O -K -N \
    	-F+f32p,Times-Roman+jCB -X-3.5i >> $ps
    psscale -D3.25i/0.35i/5i/0.25ih -Cex16.cpt -O -U"Example 16 in Cookbook" -Y-0.75i >> $ps
    #
    rm -f *.nc gmt.conf

.. include:: fig_includes/fig_example_16.rst_

Images clipped by coastlines
----------------------------

This example demonstrates how `pscoast <pscoast.html>`_
can be used to set up clip paths based on coastlines. This approach is
well suited when different gridded data sets are to be merged on a plot
using different color palette files. Merging the files themselves may
not be doable since they may represent different data sets, as we show
in this example. Here, we lay down a color map of the geoid field near
India with `grdimage <grdimage.html>`_, use
`pscoast <pscoast.html>`_ to set up land clip paths, and
then overlay topography from the ETOPO5 data set with another call to
`grdimage <grdimage.html>`_. We finally undo the
clippath with a second call to `pscoast <pscoast.html>`_
with the option **-Q** (Figure [fig:example:sub:`1`\ 7]):

We also plot a color legend on top of the land. So here we basically
have three layers of "paint" stacked on top of each other: the
underlaying geoid map, the land mask, and finally the color legend. This
legend makes clear how `grd2cpt <grd2cpt.html>`_
distributed the colors over the range: they are not of equal length put
are associated with equal amounts of area in the plot. Since the high
amounts (in red) are not very prevalent, that color spans a long range.

For this image it is appropriate to use the **-I** option in
`psscale <psscale.html>`_ so the legend gets shaded,
similar to the geoid grid. See Appendix [app:M] to learn more about
color palettes and ways to draw color legends.

   ::

    #!/bin/bash
    #		GMT EXAMPLE 17
    #		$Id: example_17.sh 9872 2012-03-15 20:57:29Z remko $
    #
    # Purpose:	Illustrates clipping of images using coastlines
    # GMT progs:	grd2cpt, grdgradient, grdimage, pscoast, pstext
    # Unix progs:	rm
    #
    ps=example_17.ps
    
    # First generate geoid image w/ shading
    
    grd2cpt india_geoid.nc -Crainbow > geoid.cpt
    grdgradient india_geoid.nc -Nt1 -A45 -Gindia_geoid_i.nc
    grdimage india_geoid.nc -Iindia_geoid_i.nc -JM6.5i -Cgeoid.cpt -P -K \
    	-U"Example 17 in Cookbook" > $ps
    
    # Then use pscoast to initiate clip path for land
    
    pscoast -Rindia_geoid.nc -J -O -K -Dl -Gc >> $ps
    
    # Now generate topography image w/shading
    
    echo "-10000 150 10000 150" > gray.cpt
    grdgradient india_topo.nc -Nt1 -A45 -Gindia_topo_i.nc
    grdimage india_topo.nc -Iindia_topo_i.nc -J -Cgray.cpt -O -K >> $ps
    
    # Finally undo clipping and overlay basemap
    
    pscoast -R -J -O -K -Q -B10f5 -B+t"Clipping of Images" >> $ps
    
    # Put a color legend on top of the land mask
    
    psscale -D4i/7.6i/4i/0.2ih -Cgeoid.cpt -Bx5f1 -By+lm -I -O -K >> $ps
    
    # Add a text paragraph
    
    pstext -R -J -O -M -Gwhite -Wthinner -TO -D-0.1i/0.1i -F+f12,Times-Roman+jRB >> $ps << END
    > 90 -10 12p 3i j
    @_@%5%Example 17.@%%@_  We first plot the color geoid image
    for the entire region, followed by a gray-shaded @#etopo5@#
    image that is clipped so it is only visible inside the coastlines.
    END
    
    # Clean up
    
    rm -f geoid.cpt gray.cpt *_i.nc

.. include:: fig_includes/fig_example_17.rst_

Volumes and Spatial Selections
------------------------------

To demonstrate potential usage of the new programs
`grdvolume <grdvolume.html>`_ and
`gmtselect <gmtselect.html>`_ we extract a subset of the
Sandwell & Smith altimetric gravity field [26]_ for the northern Pacific
and decide to isolate all seamounts that (1) exceed 50 mGal in amplitude
and (2) are within 200 km of the Pratt seamount. We do this by dumping
the 50 mGal contours to disk, then making a simple **AWK** script ``center.awk`` that
returns the mean location of the points making up each closed polygon,
and then pass these locations to
`gmtselect <gmtselect.html>`_ which retains only the
points within 200 km of Pratt. We then mask out all the data outside
this radius and use `grdvolume <grdvolume.html>`_ to
determine the combined area and volumes of the chosen seamounts. Our
illustration is presented in Figure [fig:example\ :sub:`1`\ 8].

   ::

    #!/bin/bash
    #		GMT EXAMPLE 18
    #
    # Purpose:	Illustrates volumes of grids inside contours and spatial
    #		selection of data
    # GMT progs:	gmtset, gmtselect, gmtspatial, grdclip, grdcontour, grdgradient, grdimage
    # GMT progs:	grdmath, grdvolume, makecpt, pscoast, psscale, pstext, psxy
    # Unix progs:	awk, cat, rm
    #
    ps=example_18.ps
    
    # Use spherical projection since SS data define on sphere
    gmtset PROJ_ELLIPSOID Sphere FORMAT_FLOAT_OUT %g
    
    # Define location of Pratt seamount
    echo "-142.65 56.25" > pratt.d
    
    # First generate gravity image w/ shading, label Pratt, and draw a circle
    # of radius = 200 km centered on Pratt.
    
    makecpt -Crainbow -T-60/60/120 -Z > grav.cpt
    grdgradient AK_gulf_grav.nc -Nt1 -A45 -GAK_gulf_grav_i.nc
    grdimage AK_gulf_grav.nc -IAK_gulf_grav_i.nc -JM5.5i -Cgrav.cpt -B2f1 -P -K -X1.5i \
    	-Y5.85i > $ps
    pscoast -RAK_gulf_grav.nc -J -O -K -Di -Ggray -Wthinnest >> $ps
    psscale -D2.75i/-0.4i/4i/0.15ih -Cgrav.cpt -Bx20f10 -By+lmGal -O -K >> $ps
    awk '{print $1, $2, "Pratt"}' pratt.d | pstext -R -J -O -K -D0.1i/0.1i \
    	-F+f12p,Helvetica-Bold+jLB >> $ps
    awk '{print $1, $2, 0, 400, 400}' pratt.d | psxy -R -J -O -K -SE -Wthinnest >> $ps
    
    # Then draw 10 mGal contours and overlay 50 mGal contour in green
    
    grdcontour AK_gulf_grav.nc -J -C20 -B2f1 -BWSEn -O -K -Y-4.85i \
    	-UL/-1.25i/-0.75i/"Example 18 in Cookbook" >> $ps
    # Save 50 mGal contours to individual files, then plot them
    grdcontour AK_gulf_grav.nc -C10 -L49/51 -Dsm_%d_%c.txt
    psxy -R -J -O -K -Wthin,green sm_*.txt >> $ps
    pscoast -R -J -O -K -Di -Ggray -Wthinnest >> $ps
    awk '{print $1, $2, 0, 400, 400}' pratt.d | psxy -R -J -O -K -SE -Wthinnest >> $ps
    rm -f sm_*_O.txt	# Only consider the closed contours
    
    # Now determine centers of each enclosed seamount > 50 mGal but only plot
    # the ones within 200 km of Pratt seamount.
    
    # First determine mean location of each closed contour and
    # add it to the file centers.d
    
    gmtspatial -Q -fg sm_*_C.txt > centers.d
    
    # Only plot the ones within 200 km
    
    gmtselect -C200k/pratt.d centers.d -fg | psxy -R -J -O -K -SC0.04i -Gred -Wthinnest >> $ps
    psxy -R -J -O -K -ST0.1i -Gyellow -Wthinnest pratt.d >> $ps
    
    # Then report the volume and area of these seamounts only
    # by masking out data outside the 200 km-radius circle
    # and then evaluate area/volume for the 50 mGal contour
    
    grdmath -R `cat pratt.d` SDIST = mask.nc
    grdclip mask.nc -Sa200/NaN -Sb200/1 -Gmask.nc
    grdmath AK_gulf_grav.nc mask.nc MUL = tmp.nc
    area=`grdvolume tmp.nc -C50 -Sk | cut -f2`
    volume=`grdvolume tmp.nc -C50 -Sk | cut -f3`
    
    psxy -R -J -A -O -K -L -Wthin -Gwhite >> $ps << END
    -148.5	52.75
    -140.5	52.75
    -140.5	53.75
    -148.5	53.75
    END
    pstext -R -J -O -F+f14p,Helvetica-Bold+jLM >> $ps << END
    -148 53.08 Areas: $area km@+2@+
    -148 53.42 Volumes: $volume mGal\264km@+2@+
    END
    
    # Clean up
    
    rm -f grav.cpt sm_*.txt *_i.nc tmp.nc mask.nc pratt.d center* gmt.conf

.. include:: fig_includes/fig_example_18.rst_

Color patterns on maps
----------------------

*GMT* 3.1 introduced color patterns and this examples give a few cases
of how to use this new feature. We make a phony poster that advertises
an international conference on *GMT*\ in Honolulu. We use
`grdmath <grdmath.html>`_,
`makecpt <makecpt.html>`_, and
`grdimage <grdimage.html>`_ to draw pleasing color
backgrounds on maps, and overlay
`pscoast <pscoast.html>`_ clip paths to have the
patterns change at the coastlines. The middle panel demonstrates a
simple `pscoast <pscoast.html>`_ call where the built-in
pattern # 86 is drawn at 100 dpi but with the black and white pixels
replaced with color combinations. At the same time the ocean is filled
with a repeating image of a circuit board (provides in Sun raster
format). The text *GMT* in the center is an off-line *PostScript* file
that was overlaid using `psimage <psimage.html>`_. The
final panel repeats the top panel except that the land and sea images
have changed places (Figure [fig:example:sub:`1`\ 9]).

   ::

    #!/bin/bash
    #		GMT EXAMPLE 19
    #
    # Purpose:	Illustrates various color pattern effects for maps
    # GMT progs:	gmtset, grdimage, grdmath, makecpt, pscoast, pstext, psimage
    # Unix progs:	rm
    #
    ps=example_19.ps
    
    # First make a worldmap with graded blue oceans and rainbow continents
    
    grdmath -Rd -I1 -r Y COSD 2 POW = lat.nc
    grdmath -Rd -I1 -r X = lon.nc
    echo "0 white 1 blue" > lat.cpt
    makecpt -Crainbow -T-180/180/360 -Z > lon.cpt
    grdimage lat.nc -JI0/6.5i -Clat.cpt -P -K -Y7.5i -B0 -nl > $ps
    pscoast -R -J -O -K -Dc -A5000 -Gc >> $ps
    grdimage lon.nc -J -Clon.cpt -O -K -nl >> $ps
    pscoast -R -J -O -K -Q >> $ps
    pscoast -R -J -O -K -Dc -A5000 -Wthinnest >> $ps
    echo "0 20 10TH INTERNATIONAL" | pstext -R -J -O -K -F+f32p,Helvetica-Bold,red=thinner >> $ps
    echo "0 -10 GMT CONFERENCE" | pstext -R -J -O -K -F+f32p,Helvetica-Bold,red=thinner >> $ps
    echo "0 -30 Honolulu, Hawaii, April 1, 2013" | pstext -R -J -O -K \
    	-F+f18p,Helvetica-Bold,green=thinnest >> $ps
    
    # Then show example of color patterns and placing a PostScript image
    
    pscoast -R -J -O -K -Dc -A5000 -Gp100/86:FredByellow -Sp100/circuit.ras -B0 -Y-3.25i >> $ps
    echo "0 30 SILLY USES OF" | pstext -R -J -O -K -F+f32p,Helvetica-Bold,lightgreen=thinner >> $ps
    echo "0 -30 COLOR PATTERNS" | pstext -R -J -O -K -F+f32p,Helvetica-Bold,magenta=thinner >> $ps
    psimage -C3.25i/1.625i/CM -W3i GMT_covertext.eps -O -K >> $ps
    
    # Finally repeat 1st plot but exchange the patterns
    
    grdimage lon.nc -J -Clon.cpt -O -K -Y-3.25i -B0 -U"Example 19 in Cookbook" -nl >> $ps
    pscoast -R -J -O -K -Dc -A5000 -Gc >> $ps
    grdimage lat.nc -J -Clat.cpt -O -K -nl >> $ps
    pscoast -R -J -O -K -Q >> $ps
    pscoast -R -J -O -K -Dc -A5000 -Wthinnest >> $ps
    echo "0 20 10TH INTERNATIONAL" | pstext -R -J -O -K -F+f32p,Helvetica-Bold,red=thinner >> $ps
    echo "0 -10 GMT CONFERENCE" | pstext -R -J -O -K -F+f32p,Helvetica-Bold,red=thinner >> $ps
    echo "0 -30 Honolulu, Hawaii, April 1, 2013" | pstext -R -J -O \
    	-F+f18p,Helvetica-Bold,green=thinnest >> $ps
    
    rm -f l*.nc l*.cpt gmt.conf

.. include:: fig_includes/fig_example_19.rst_

Custom plot symbols
-------------------

One is often required to make special maps that shows the distribution
of certain features but one would prefer to use a custom symbol instead
of the built-in circles, squares, triangles, etc. in the *GMT* plotting
programs `psxy <psxy.html>`_ and
`psxyz <psxyz.html>`_. Here we demonstrate one approach
that allows for a fair bit of flexibility in designing ones own symbols.
The following recipe is used when designing a new symbol.

#. Use `psbasemap <psbasemap.html>`_ (or engineering
   paper!) to set up an empty grid that goes from -0.5 to +0.5 in both
   *x* and *y*. Use ruler and compass to draw your new symbol using
   straight lines, arcs of circles, and stand-alone geometrical objects
   (see `psxy <psxy.html>`_ man page for a full
   description of symbol design). In this Section we will create two new
   symbols: a volcano and a bulls eye.

.. include:: fig_includes/fig_GMT_volcano.rst_

#. After designing the symbol we will encode it using a simple set of
   rules. In our case we describe our volcano and bulls eye using these
   three freeform polygon generators:

   :math:`x_0` :math:`y_0` *r* **C** [ **-G**\ *fill* ] [
   **-W**\ *pen* ] Draw :math:`x_0` :math:`y_0` **M** [ **-G**\ *fill* ]
   [ **-W**\ *pen* ] Start new element at :math:`x_0`, :math:`y_0`

   :math:`x_1` :math:`y_1` **D** Draw straight line from current point
   to :math:`x_1`, :math:`y_1` around (:math:`x_0`, :math:`y_0`)

   :math:`x_0` :math:`y_0` *r* :math:`\alpha_1` :math:`\alpha_2`
   **A** Draw arc segment of radius *r* from angle
   :math:`\alpha_1` to :math:`\alpha_2`

   We also add a few stand-alone circles (for other symbols, see
   `psxy <psxy.html>`_ man page):

   :math:`x_0` :math:`y_0` *r* **C** [ **-G**\ *fill* ] [
   **-W**\ *pen* ] Draw :math:`x_0` :math:`y_0` *r* **c** [
   **-G**\ *fill* ] [ **-W**\ *pen* ] Draw single circle of radius
   *r* around :math:`x_0`, :math:`y_0`

   The optional **-G** and **-W** can be used to hardwire the color fill
   and pen for segments (use **-** to disallow fill or line for any
   specific feature). By default the segments are painted based on the
   values of the command line settings.

   Manually applying these rules to our volcano symbol results in a
   definition file ``volcano.def``:

   Without much further discussion we also make a definition file ``bullseye.def`` for a
   multi-colored bulls eye symbol. Note that the symbol can be created
   beyond the -0.5 to +0.5 range, as shown by the red lines. There is no
   limit in *GMT* to the size of the symbols. The center, however, will
   always be at (0,0). This is the point to which the coordinates in
   `psxy <psxy.html>`_ refers.

   The values refer to positions and dimensions illustrated in the
   Figure above.

#. Given proper definition files we may now use them with
   `psxy <psxy.html>`_ or `psxyz <psxyz.html>`_.

We are now ready to give it a try. Based on the hotspot locations in the
file ``hotspots.d`` (with a 3rd column giving the desired symbol sizes in inches) we
lay down a world map and overlay red volcano symbols using our
custom-built volcano symbol and `psxy <psxy.html>`_. We
do something similar with the bulls eye symbols. Without the **-G**
option, however, they get the colors defined in ``bullseye.def``.

Here is our final map script that produces Figure [fig:example\ :sub:`2`\ 0]:

   ::

    #!/bin/bash
    #		GMT EXAMPLE 20
    #		$Id: example_20.sh 11031 2013-03-02 01:27:34Z pwessel $
    #
    # Purpose:	Extend GMT to plot custom symbols
    # GMT progs:	pscoast, psxy
    # Unix progs:	rm
    #
    # Plot a world-map with volcano symbols of different sizes
    # on top given locations and sizes in hotspots.d
    ps=example_20.ps
    
    cat > hotspots.d << END
    55.5	-21.0	0.25
    63.0	-49.0	0.25
    -12.0	-37.0	0.25
    -28.5	29.34	0.25
    48.4	-53.4	0.25
    155.5	-40.4	0.25
    -155.5	19.6	0.5
    -138.1	-50.9	0.25
    -153.5	-21.0	0.25
    -116.7	-26.3	0.25
    -16.5	64.4	0.25
    END
    
    pscoast -Rg -JR9i -Bx60 -By30 -B+t"Hotspot Islands and Cities" -Gdarkgreen -Slightblue -Dc -A5000 \
    	-K -U"Example 20 in Cookbook" > $ps
    
    psxy -R -J hotspots.d -Skvolcano -O -K -Wthinnest -Gred >> $ps
    
    # Overlay a few bullseyes at NY, Cairo, and Perth
    
    cat > cities.d << END
    286	40.45	0.8
    31.15	30.03	0.8
    115.49	-31.58	0.8
    END
    
    psxy -R -J cities.d -Skbullseye -O >> $ps
    
    rm -f hotspots.d cities.d

.. include:: fig_includes/fig_example_20.rst_

Given these guidelines you can easily make your own symbols. Symbols
with more than one color can be obtained by making several symbol
components. E.g., to have yellow smoke coming out of red volcanoes we
would make two symbols: one with just the cone and caldera and the other
with the bubbles. These would be plotted consecutively using the desired
colors. Alternatively, like in ``bullseye.def``, we may specify colors directly for the
various segments. Note that the custom symbols (Appendix [app:N]),
unlike the built-in symbols in *GMT*, can be used with the built-in
patterns (Appendix [app:E]). Other approaches are also possible, of
course.

Time-series of RedHat stock price
---------------------------------

As discussed in Section [sec:timeaxis], the annotation of time-series is
generally more complicated due to the extra degrees of freedom afforded
by the dual annotation system. In this example we will display the trend
of the stock price of RedHat (RHAT) from their initial public offering
until late 2006. The data file is a comma-separated table and the
records look like this:

::

    Date,Open,High,Low,Close,Volume,Adj.Close*
    12-Mar-04,17.74,18.49,17.67,18.02,4827500,18.02
    11-Mar-04,17.60,18.90,17.37,18.09,7700400,18.09

Hence, we have a single header record and various prices in USD for each
day of business. We will plot the trend of the opening price as a red
line superimposed on a yellow envelope representing the low-to-high
fluctuation during each day. We also indicate when and at what cost Paul
Wessel bought a few shares, and zoom in on the developments since 2004;
in the inset we label the time-axis in Finnish in honor of Linus
Thorvalds. Because the time coordinates are Y2K-challenged and the order
is backwards (big units of years come *after* smaller units like days)
we must change the default input/output formats used by *GMT*. Finally,
we want to prefix prices with the $ symbol to indicate the currency.
Here is how it all comes out:

   ::

    #!/bin/bash
    #		GMT EXAMPLE 21
    #
    # Purpose:	Plot a time-series
    # GMT progs:	gmtset, gmtconvert, minmax, psbasemap, psxy 
    # Unix progs:	cut, echo
    #
    ps=example_21.ps
    
    # File has time stored as dd-Mon-yy so set input format to match it
    
    gmtset FORMAT_DATE_IN dd-o-yy FORMAT_DATE_MAP o FONT_ANNOT_PRIMARY +10p
    gmtset FORMAT_TIME_PRIMARY_MAP abbreviated PS_CHAR_ENCODING ISOLatin1+
    
    # Pull out a suitable region string in yyy-mm-dd format
    
    minmax -fT -I50 -C RHAT_price.csv > RHAT.info
    w=`cut -f1 RHAT.info`
    e=`cut -f2 RHAT.info`
    s=`cut -f3 RHAT.info`
    n=`cut -f4 RHAT.info`
    R="-R$w/$e/$s/$n"
    
    # Lay down the basemap:
    
    psbasemap $R -JX9i/6i -K -U"Example 21 in Cookbook" -Bs1Y -BWSen \
       -Bpxa3Of1o -Bpy50+p"$ " -BWSen+t"RedHat (RHT) Stock Price Trend since IPO"+glightgreen > $ps
    
    # Plot main window with open price as red line over yellow envelope of low/highs
    
    gmtset FORMAT_DATE_OUT dd-o-yy
    gmtconvert -o0,2 -f0T RHAT_price.csv > RHAT.env
    gmtconvert -o0,3 -f0T -I -T RHAT_price.csv >> RHAT.env
    psxy -R -J -Gyellow -O -K RHAT.env >> $ps
    psxy -R -J RHAT_price.csv -Wthin,red -O -K >> $ps
    
    # Draw P Wessel's purchase price as line and label it.  Note we temporary switch
    # back to default yyyy-mm-dd format since that is what minmax gave us.
    
    echo "05-May-00	0" > RHAT.pw
    echo "05-May-00	300" >> RHAT.pw
    psxy -R -J RHAT.pw -Wthinner,- -O -K >> $ps
    echo "01-Jan-99	25" > RHAT.pw
    echo "01-Jan-02	25" >> RHAT.pw
    psxy -R -J RHAT.pw -Wthick,- -O -K >> $ps
    gmtset FORMAT_DATE_IN yyyy-mm-dd
    echo "$w 25 PW buy" | pstext -R -J -O -K -D1.5i/0.05i -N -F+f12p,Bookman-Demi+jLB >> $ps
    gmtset FORMAT_DATE_IN dd-o-yy
    
    # Draw P Wessel's sales price as line and label it.
    
    echo "25-Jun-07	0" > RHAT.pw
    echo "25-Jun-07	300" >> RHAT.pw
    psxy -R -J RHAT.pw -Wthinner,- -O -K >> $ps
    echo "01-Aug-06	23.8852" > RHAT.pw
    echo "01-Jan-08	23.8852" >> RHAT.pw
    psxy -R -J RHAT.pw -Wthick,- -O -K >> $ps
    gmtset FORMAT_DATE_IN yyyy-mm-dd
    echo "$e 23.8852 PW sell" | pstext -R -J -O -K -Dj0.8i/0.05i -N \
    	-F+f12p,Bookman-Demi+jRB >> $ps
    gmtset FORMAT_DATE_IN dd-o-yy
    
    # Get smaller region for insert for trend since 2004
    
    R="-R2004T/$e/$s/40"
    
    # Lay down the basemap, using Finnish annotations and place the insert in the upper right
    
    psbasemap --TIME_LANGUAGE=fi $R -JX6i/3i -Bpxa3Of3o -Bpy10+p"$ " -BESw+glightblue -Bsx1Y \
    	-O -K -X3i -Y3i >> $ps
    
    # Again, plot close price as red line over yellow envelope of low/highs
    
    psxy -R -J -Gyellow -O -K RHAT.env >> $ps
    psxy -R -J RHAT_price.csv -Wthin,red -O -K >> $ps
    
    # Draw P Wessel's sales price as dashed line
    
    psxy -R -J RHAT.pw -Wthick,- -O -K >> $ps
    
    # Mark sales date
    
    echo "25-Jun-07	0" > RHAT.pw
    echo "25-Jun-07	300" >> RHAT.pw
    psxy -R -J RHAT.pw -Wthinner,- -O >> $ps
    
    # Clean up after ourselves:
    
    rm -f RHAT.* gmt.conf

which produces the plot in Figure [fig:example\ :sub:`2`\ 1], suggesting
Wessel has missed a few trains if he had hoped to cash in on the
Internet bubble...

.. include:: fig_includes/fig_example_21.rst_

World-wide seismicity the last 7 days
-------------------------------------

The next example uses the command-line tool **wget** to obtain a data
file from a specified URL [27]_. In the example script this line is
commented out so the example will run even if you do not have **wget**
(we use the supplied ``neic_quakes.d`` which normally would be created by **wget**);
remove the comment to get the actual current seismicity plot using the
live data. The main purpose of this script is not to show how to plot a
map background and a few circles, but rather demonstrate how a map
legend may be composed using the new tool
`pslegend <pslegend.html>`_. Some scripting is used to
pull out information from the data file that is later used in the
legend. The legend will normally have the email address of the script
owner; here that command is commented out and the user is hardwired to
"GMT guru". The USGS logo, taken from their web page and converted to a
Sun raster file, is used to spice up the legend.

The script produces the plot in Figure [fig:example\ :sub:`2`\ 2],
giving the URL where these and similar data can be obtained.

   ::

    #!/bin/bash
    #		GMT EXAMPLE 22
    #
    # Purpose:	Automatic map of last 7 days of world-wide seismicity
    # GMT progs:	gmtset, pscoast, psxy, pslegend
    # Unix progs:	cat, sed, awk, wget|curl
    #
    ps=example_22.ps
    gmtset FONT_ANNOT_PRIMARY 10p FONT_TITLE 18p FORMAT_GEO_MAP ddd:mm:ssF
    
    # Get the data (-q quietly) from USGS using the wget (comment out in case
    # your system does not have wget or curl)
    
    #wget http://neic.usgs.gov/neis/gis/bulletin.asc -q -O neic_quakes.d
    #curl http://neic.usgs.gov/neis/gis/bulletin.asc -s > neic_quakes.d
    
    # Count the number of events (to be used in title later. one less due to header)
    
    n=`cat neic_quakes.d | wc -l`
    n=`expr $n - 1`
    
    # Pull out the first and last timestamp to use in legend title
    
    first=`sed -n 2p neic_quakes.d | awk -F, '{printf "%s %s\n", $1, $2}'`
    last=`sed -n '$p' neic_quakes.d | awk -F, '{printf "%s %s\n", $1, $2}'`
    
    # Assign a string that contains the current user @ the current computer node.
    # Note that two @@ is needed to print a single @ in pstext:
    
    #set me = "$user@@`hostname`"
    me="GMT guru @@ GMTbox"
    
    # Create standard seismicity color table
    
    cat > neis.cpt << END
    0	red	100	red
    100	green	300	green
    300	blue	10000	blue
    END
    
    # Start plotting. First lay down map, then plot quakes with size = magintude/50":
    
    pscoast -Rg -JK180/9i -B45g30 -B+t"World-wide earthquake activity" -Gbrown -Slightblue \
            -Dc -A1000 -K -UL/-0.75i/-2.5i/"Example 22 in Cookbook" -Y2.75i > $ps
    awk -F, '{ print $4, $3, $6, $5*0.02}' neic_quakes.d \
            | psxy -R -JK -O -K -Cneis.cpt -Sci -Wthin -h >> $ps
    # Create legend input file for NEIS quake plot
    
    cat > neis.legend << END
    H 16 1 $n events during $first to $last
    D 0 1p
    N 3
    V 0 1p
    S 0.1i c 0.1i red 0.25p 0.2i Shallow depth (0-100 km)
    S 0.1i c 0.1i green 0.25p 0.2i Intermediate depth (100-300 km)
    S 0.1i c 0.1i blue 0.25p 0.2i Very deep (> 300 km)
    V 0 1p
    D 0 1p
    N 7
    V 0 1p
    S 0.1i c 0.06i - 0.25p 0.3i M 3
    S 0.1i c 0.08i - 0.25p 0.3i M 4
    S 0.1i c 0.10i - 0.25p 0.3i M 5
    S 0.1i c 0.12i - 0.25p 0.3i M 6
    S 0.1i c 0.14i - 0.25p 0.3i M 7
    S 0.1i c 0.16i - 0.25p 0.3i M 8
    S 0.1i c 0.18i - 0.25p 0.3i M 9
    V 0 1p
    D 0 1p
    N 1
    END
    
    # Put together a reasonable legend text, and add logo and user's name:
    
    cat << END >> neis.legend
    P
    T USGS/NEIS most recent earthquakes for the last seven days.  The data were
    T obtained automatically from the USGS Earthquake Hazards Program page at
    T @_http://neic/usgs.gov @_.  Interested users may also receive email alerts
    T from the USGS.
    T This script can be called daily to update the latest information.
    G 0.4i
    # Add USGS logo
    I USGS.ras 1i RT
    G -0.3i
    L 12 6 LB $me
    END
    
    # OK, now we can actually run pslegend.  We center the legend below the map.
    # Trial and error shows that 1.7i is a good legend height:
    
    pslegend -Dx4.5i/-0.4i/7i/1.7i/TC -O -F neis.legend -Glightyellow >> $ps
    
    # Clean up after ourselves:
    
    rm -f neis.* gmt.conf

.. include:: fig_includes/fig_example_22.rst_

All great-circle paths lead to Rome
-----------------------------------

[sec:example:sub:`2`\ 3]

While motorists recently have started to question the old saying "all
roads lead to Rome", aircraft pilots have known from the start that only
one great-circle path connects the points of departure and
arrival [28]_. This provides the inspiration for our next example which
uses `grdmath <grdmath.html>`_ to calculate distances
from Rome to anywhere on Earth and
`grdcontour <grdcontour.html>`_ to contour these
distances. We pick five cities that we connect to Rome with great circle
arcs, and label these cities with their names and distances (in km) from
Rome, all laid down on top of a beautiful world map. Note that we
specify that contour labels only be placed along the straight map-line
connecting Rome to its antipode, and request curved labels that follows
the shape of the contours.

The script produces the plot in Figure [fig:example\ :sub:`2`\ 3]; note
how interesting the path to Seattle appears in this particular
projection (Hammer). We also note that Rome's antipode lies somewhere
near the Chatham plateau (antipodes will be revisited in
Section [sec:example\ :sub:`2`\ 5]).

   ::

    #!/bin/bash
    #		GMT EXAMPLE 23
    #
    # Purpose:	Plot distances from Rome and draw shortest paths
    # GMT progs:	grdmath, grdcontour, pscoast, psxy, pstext, grdtrack
    # Unix progs:	echo, cat, awk
    #
    ps=example_23.ps
    
    # Position and name of central point:
    
    lon=12.50
    lat=41.99
    name="Rome"
    
    # Calculate distances (km) to all points on a global 1x1 grid
    
    grdmath -Rg -I1 $lon $lat SDIST 111.13 MUL = dist.nc
    
    # Location info for 5 other cities + label justification
    
    cat << END > cities.d
    105.87	21.02	HANOI		LM
    282.95	-12.1	LIMA		LM
    178.42	-18.13	SUVA		LM
    237.67	47.58	SEATTLE		RM
    28.20	-25.75	PRETORIA	LM
    END
    
    pscoast -Rg -JH90/9i -Glightgreen -Sblue -U"Example 23 in Cookbook" -A1000 \
    	-Bg30 -B+t"Distances from $name to the World" -K -Dc -Wthinnest > $ps
    
    grdcontour dist.nc -A1000+v+ukm+fwhite -Glz-/z+ -S8 -C500 -O -K -J \
    	-Wathin,white -Wcthinnest,white,- >> $ps
    
    # For each of the cities, plot great circle arc to Rome with psxy
    
    while read clon clat city; do
    	(echo $lon $lat; echo $clon $clat) | psxy -R -J -O -K -Wthickest,red >> $ps
    done < cities.d
    
    # Plot red squares at cities and plot names:
    psxy -R -J -O -K -Ss0.2 -Gred -Wthinnest cities.d >> $ps
    awk '{print $1, $2, $4, $3}' cities.d | pstext -R -J -O -K -Dj0.15/0 \
    	-F+f12p,Courier-Bold,red+j -N >> $ps
    # Place a yellow star at Rome
    echo "$lon $lat" | psxy -R -J -O -K -Sa0.2i -Gyellow -Wthin >> $ps
    
    # Sample the distance grid at the cities and use the distance in km for labels
    
    grdtrack -Gdist.nc cities.d \
    	| awk '{printf "%s %s %d\n", $1, $2, int($NF+0.5)}' \
    	| pstext -R -J -O -D0/-0.2i -N -Gwhite -W -C0.02i -F+f12p,Helvetica-Bold+jCT >> $ps
    
    # Clean up after ourselves:
    
    rm -f cities.d dist.nc

.. include:: fig_includes/fig_example_23.rst_

Data selection based on geospatial criteria
-------------------------------------------

Although we are not seismologists, we have yet another example involving
seismicity. We use seismicity data for the Australia/New Zealand region
to demonstrate how we can extract subsets of data using geospatial
criteria. In particular, we wish to plot the epicenters given in the
file ``oz_quakes.d`` as red or green circles. Green circles should only be used for
epicenters that satisfy the following three criteria:

#. They are located in the ocean and not on land

#. They are within 3000 km of Hobart

#. They are more than 1000 km away from the International Dateline

All remaining earthquakes should be plotted in red. Rather that doing
the selection process twice we simply plot all quakes as red circles and
then replot those that pass our criteria. Most of the work here is done
by `gmtselect <gmtselect.html>`_; the rest is carried
out by the usual `pscoast <pscoast.html>`_ and
`psxy <psxy.html>`_ workhorses. Note for our purposes
the Dateline is just a line along the 180 meridian.

The script produces the plot in Figure [fig:example\ :sub:`2`\ 4]. Note
that the horizontal distance from the dateline seems to increase as we
go south; however that is just the projected distance (Mercator
distortion) and not the actual distance which remains constant at 1000 km.

   ::

    #!/bin/bash
    #		GMT EXAMPLE 24
    #
    # Purpose:	Extract subsets of data based on geospatial criteria
    # GMT progs:	gmtselect, pscoast, psxy, minmax
    # Unix progs:	echo, cat, awk
    #
    # Highlight oceanic earthquakes within 3000 km of Hobart and > 1000 km from dateline
    ps=example_24.ps
    echo "147:13 -42:48 3000 Hobart" > point.d
    cat << END > dateline.d
    > Our proxy for the dateline
    180	0
    180	-90
    END
    R=`minmax -I10 oz_quakes.d`
    pscoast $R -JM9i -K -Gtan -Sdarkblue -Wthin,white -Dl -A500 -Ba20f10g10 -BWeSn \
    	-U"Example 24 in Cookbook" > $ps
    psxy -R -J -O -K oz_quakes.d -Sc0.05i -Gred >> $ps
    gmtselect oz_quakes.d -L1000k/dateline.d -Nk/s -C3000k/point.d -fg -R -Il \
    	| psxy -R -JM -O -K -Sc0.05i -Ggreen >> $ps
    awk '{print $1, $2, 0, 2*$3, 2*$3}' point.d | psxy -R -J -O -K -SE -Wfat,white >> $ps
    awk '{print $1, $2, $4}' point.d | pstext -R -J -O -K -F+f14p,Helvetica-Bold,white+jLT \
    	-D0.1i/-0.1i >> $ps
    psxy -R -J -O -K point.d -Wfat,white -S+0.2i >> $ps
    psxy -R -J -O dateline.d -Wfat,white -A >> $ps
    rm -f point.d dateline.d

.. include:: fig_includes/fig_example_24.rst_

Global distribution of antipodes
--------------------------------

[sec:example:sub:`2`\ 5]

As promised in Section [sec:example\ :sub:`2`\ 3], we will study
antipodes. The antipode of a point at :math:`(\phi, \lambda)` is the
point at :math:`(-\phi, \lambda + 180)`. We seek an answer to the
question that has plagued so many for so long: Given the distribution of
land and ocean, how often is the antipode of a point on land also on
land? And what about marine antipodes? We use `grdlandmask <grdlandmask.html>`_ and
`grdmath <grdmath.html>`_ to map these distributions and
calculate the area of the Earth (in percent) that goes with each of the
three possibilities. To make sense of our
`grdmath <grdmath.html>`_ equations below, note that we
first calculate a grid that is +1 when a point and its antipode is on
land, -1 if both are in the ocean, and 0 elsewhere. We then seek to
calculate the area distribution of dry antipodes by only pulling out the
nodes that equal +1. As each point represent an area approximated by
:math:`\Delta \phi \times \Delta \lambda` where the
:math:`\Delta \lambda` term's actual dimension depends on
:math:`\cos (\phi)`, we need to allow for that shrinkage, normalize our
sum to that of the whole area of the Earth, and finally convert that
ratio to percent. Since the :math:`\Delta \lambda`, :math:`\Delta \phi`
terms appear twice in these expressions they cancel out, leaving the
somewhat intractable expressions below where the sum of
:math:`\cos (\phi)` for all :math:`\phi` is known to equal :math:`2N_y / \pi`:

In the end we obtain a funny-looking map depicting the antipodal
distribution as well as displaying in legend form the requested
percentages (Figure [fig:example:sub:`2`\ 5]). Note that the script is
set to evaluate a global 30 minute grid for expediency (*D = 30*),
hence several smaller land masses that do have terrestrial antipodes do
not show up. If you want a more accurate map you can set the parameter
*D* to a smaller increment (try 5 and wait a few minutes).

The call to `grdimage <grdimage.html>`_ includes the
``-Sn`` to suspend interpolation and only return the value of the
nearest neighbor. This option is particularly practical for plotting
categorical data, like these, that should not be interpolated.

   ::

    #!/bin/bash
    #		GMT EXAMPLE 25
    #
    # Purpose:	Display distribution of antipode types
    # GMT progs:	gmtset, grdlandmask, grdmath, grd2xyz, gmtmath, grdimage, pscoast, pslegend
    # Unix progs:	cat
    #
    # Create D minutes global grid with -1 over oceans and +1 over land
    ps=example_25.ps
    D=30
    grdlandmask -Rg -I${D}m -Dc -A500 -N-1/1/1/1/1 -r -Gwetdry.nc
    # Manipulate so -1 means ocean/ocean antipode, +1 = land/land, and 0 elsewhere
    grdmath -fg wetdry.nc DUP 180 ROTX FLIPUD ADD 2 DIV = key.nc
    # Calculate percentage area of each type of antipode match.
    grdmath -Rg -I${D}m -r Y COSD 60 $D DIV 360 MUL DUP MUL PI DIV DIV 100 MUL = scale.nc
    grdmath -fg key.nc -1 EQ 0 NAN scale.nc MUL = tmp.nc
    grd2xyz tmp.nc -s -ZTLf > key.b
    ocean=`gmtmath -bi1f -Ca -S key.b SUM UPPER RINT =`
    grdmath -fg key.nc 1 EQ 0 NAN scale.nc MUL = tmp.nc
    grd2xyz tmp.nc -s -ZTLf > key.b
    land=`gmtmath -bi1f -Ca -S key.b SUM UPPER RINT =`
    grdmath -fg key.nc 0 EQ 0 NAN scale.nc MUL = tmp.nc
    grd2xyz tmp.nc -s -ZTLf > key.b
    mixed=`gmtmath -bi1f -Ca -S key.b SUM UPPER RINT =`
    # Generate corresponding color table
    cat << END > key.cpt
    -1.5	blue	-0.5	blue
    -0.5	gray	0.5	gray
    0.5	red	1.5	red
    END
    # Create the final plot and overlay coastlines
    gmtset FONT_ANNOT_PRIMARY +10p FORMAT_GEO_MAP dddF
    grdimage key.nc -JKs180/9i -Bx60 -By30 -BWsNE+t"Antipodal comparisons" -K -Ckey.cpt -Y1.2i \
    	-UL/-0.75i/-0.95i/"Example 25 in Cookbook" -nn > $ps
    pscoast -R -J -O -K -Wthinnest -Dc -A500 >> $ps
    # Place an explanatory legend below
    pslegend -R0/9/0/0.5 -Jx1i -O -Dx4.5i/0/6i/TC -Y-0.2i -Fthick >> $ps << END
    N 3
    S 0.15i s 0.2i red  0.25p 0.3i Terrestrial Antipodes [$land %]
    S 0.15i s 0.2i blue 0.25p 0.3i Oceanic Antipodes [$ocean %]
    S 0.15i s 0.2i gray 0.25p 0.3i Mixed Antipodes [$mixed %]
    END
    rm -f *.nc key.* gmt.conf

.. include:: fig_includes/fig_example_25.rst_

General vertical perspective projection
---------------------------------------

Next, we present a recent extension to the **-JG** projection option
which allows the user to specify a particular altitude (this was always
at infinity before), as well as several further parameters to limit the
view from the chosen vantage point. In this example we show a view of
the eastern continental US from a height of 160 km. Below we add a view
with a specific tilt of 55 and azimuth 210; here we have chosen a
boresight twist of 45. We view the land from New York towards
Washington, D.C.

At this point the full projection has not been properly optimized and
the map annotations will need additional work. Also, note that the
projection is only implemented in
`pscoast <pscoast.html>`_ and
`grdimage <grdimage.html>`_. We hope to refine this
further and extend the availability of the full projection to all of the
*GMT* mapping programs.

   ::

    #!/bin/bash
    #		GMT EXAMPLE 26
    #
    # Purpose:	Demonstrate general vertical perspective projection
    # GMT progs:	pscoast
    # Unix progs:	rm
    #
    ps=example_26.ps
    
    # first do an overhead of the east coast from 160 km altitude point straight down
    
    latitude=41.5
    longitude=-74.0
    altitude=160.0
    tilt=0
    azimuth=0
    twist=0
    Width=0.0
    Height=0.0
    
    PROJ=-JG${longitude}/${latitude}/${altitude}/${azimuth}/${tilt}/${twist}/${Width}/${Height}/4i
    
    pscoast -Rg $PROJ -X1i -B5g5 -Glightbrown -Slightblue -W -Dl -N1/1p,red -N2,0.5p -P -K \
    	-Y5i > $ps
    
    # now point from an altitude of 160 km with a specific tilt and azimuth and with a wider restricted
    # view and a boresight twist of 45 degrees
    
    tilt=55
    azimuth=210
    twist=45
    Width=30.0
    Height=30.0
    
    PROJ=-JG${longitude}/${latitude}/${altitude}/${azimuth}/${tilt}/${twist}/${Width}/${Height}/5i
    
    pscoast -R $PROJ -B5g5-Glightbrown -Slightblue -W -Ia/blue -Di -Na -O -X1i -Y-4i \
    	-UL/-1.75i/-0.75i/"Example 26 in Cookbook" >> $ps

.. include:: fig_includes/fig_example_26.rst_

Plotting Sandwell/Smith Mercator img grids
------------------------------------------

Next, we show how to plot a data grid that is distributed in projected
form. The gravity and predicted bathymetry grids produced by David
Sandwell and Walter H. F. Smith are not geographical grids but instead
given on a spherical Mercator grid. The *GMT* supplement imgsrc has
tools to extract subsets of these large grids. If you need to make a
non-Mercator map then you must extract a geographic grid using
`img2grd <supplements/imgsrc/img2grd.html>`_ and then plot it using your
desired map projection. However, if you want to make a Mercator map then
you can save time and preserve data quality by avoiding to re-project
the data set twice since it is already in a Mercator projection. This
example shows how this is accomplished. We use the **-M** option in
`img2grd <supplements/imgsrc/img2grd.html>`_\  [29]_ to pull out the grid
in Mercator units (i.e., do *not* invert the Mercator projection) and
then simply plot the grid using a linear projection with a suitable
scale (here 0.25 inches per degrees of longitude). To overlay basemaps
and features that has geographic longitude/latitude coordinates we must
remember two key issues:

#. This is a *spherical* Mercator grid so we must use
   --**PROJ_ELLIPSOID**\ =Sphere with all commands that involve
   projections (or use `gmtset <gmtset.html>`_ to change the setting).

#. Select Mercator projection and use the same scale that was used with
   the linear projection.

This map of the Tasman Sea shows the marine gravity anomalies with land
painted black. A color scale bar was then added to complete the illustration.

   ::

    #!/bin/bash
    #		GMT EXAMPLE 27
    #
    # Purpose:	Illustrates how to plot Mercator img grids
    # GMT progs:	makecpt, grdgradient, grdimage, grdinfo, pscoast
    # GMT supplement: img2grd (to read Sandwell/Smith img files)
    # Unix progs:	rm, grep, awk
    #
    ps=example_27.ps
    
    # Gravity in tasman_grav.nc is in 0.1 mGal increments and the grid
    # is already in projected Mercator x/y units.
    # First get gradients.
    
    grdgradient tasman_grav.nc -Nt1 -A45 -Gtasman_grav_i.nc
    
    # Make a suitable cpt file for mGal
    
    makecpt -T-120/120/240 -Z -Crainbow > grav.cpt
    
    # Since this is a Mercator grid we use a linear projection
    
    grdimage tasman_grav.nc=ns/0.1 -Itasman_grav_i.nc -Jx0.25i -Cgrav.cpt -P -K \
    	-U"Example 27 in Cookbook" > $ps
    
    # Then use pscoast to plot land; get original -R from grid remark
    # and use Mercator projection with same scale as above on a spherical Earth
    
    R=`grdinfo tasman_grav.nc | grep Remark | awk '{print $NF}'`
    
    pscoast $R -Jm0.25i -Ba10f5 -BWSne -O -K -Gblack --PROJ_ELLIPSOID=Sphere \
    	-Cwhite -Dh+ --FORMAT_GEO_MAP=dddF >> $ps
    
    # Put a color legend on top of the land mask justified with 147E,31S
    
    #echo 147E 31S 1i 2.5i | psxy -R -J -O -K -Sr -D0.25i/0.05i -Gwhite -W1p \
    #	--PROJ_ELLIPSOID=Sphere >> $ps
    pos=`echo 147E 31S | mapproject -R -J --PROJ_ELLIPSOID=Sphere | \
    	awk '{printf "%si/%si\n", $1, $2}'`
    psscale -D$pos/2i/0.15i -Cgrav.cpt -Bx50f10 -By+lmGal -I -O -T+gwhite+p1p >> $ps
    
    # Clean up
    
    rm -f grav.cpt *_i.nc

.. include:: fig_includes/fig_example_27.rst_

Mixing UTM and geographic data sets
-----------------------------------

Next, we present a similar case: We wish to plot a data set given in UTM
coordinates (meter) and want it to be properly registered with overlying
geographic data, such as coastlines or data points. The mistake many
*GMT* rookies make is to specify the UTM projection with their UTM data.
However, that data have already been projected and is now in linear
meters. The only sensible way to plot such data is with a linear
projection, yielding a UTM map. In this step one can choose to annotate
or tick the map in UTM meters as well. To plot geographic (lon/lat) data
on the same map you simply have to specify the region using the UTM
meters but supply the actual UTM projection parameters. Make sure you
use the same scale with both the linear and UTM projection.

Our script illustrates how we would plot a UTM grid (with coordinates in
meters) of elevations near Kilauea volcano on the Big Island of Hawaii
and overlay geographical information (with longitude, latitude
coordinates). We first lay down the UTM grid using the linear
projection. Then, given we are in UTM zone 5Q, we use the UTM domain and
the UTM projection when overlaying the coastline and light blue ocean.
We do some trickery by converting the UTM domain to km so that we can
add custom annotations to the map. Finally, we place a scale bar and
label Kilauea crater to complete the figure.

   ::

    #!/bin/bash
    #		GMT EXAMPLE 28
    #
    # Purpose:	Illustrates how to mix UTM data and UTM projection
    # GMT progs:	makecpt, grdgradient, grdimage, grdinfo, grdmath, pscoast, pstext, mapproject
    # Unix progs:	rm, echo
    #
    ps=example_28.ps
    
    # Get intensity grid and set up a color table
    grdgradient Kilauea.utm.nc -Nt1 -A45 -GKilauea.utm_i.nc
    makecpt -Ccopper -T0/1500/100 -Z > Kilauea.cpt
    # Lay down the UTM topo grid using a 1:16,000 scale
    grdimage Kilauea.utm.nc -IKilauea.utm_i.nc -CKilauea.cpt -Jx1:160000 -P -K \
    	-U"Example 28 in Cookbook" --FORMAT_FLOAT_OUT=%.10g --FONT_ANNOT_PRIMARY=9p \
    	> $ps
    # Overlay geographic data and coregister by using correct region and projection with the same scale
    pscoast -RKilauea.utm.nc -Ju5Q/1:160000 -O -K -Df+ -Slightblue -W0.5p -B5mg5m -BNE \
    	--FONT_ANNOT_PRIMARY=12p --FORMAT_GEO_MAP=ddd:mmF >> $ps
    echo 155:16:20W 19:26:20N KILAUEA | pstext -R -J -O -K -F+f12p,Helvetica-Bold+jCB >> $ps
    psbasemap -R -J -O -K --FONT_ANNOT_PRIMARY=9p -Lf155:07:30W/19:15:40N/19:23N/5k+l1:16,000+u \
    	--FONT_LABEL=10p >> $ps
    # Annotate in km but append ,000m to annotations to get customized meter labels
    psbasemap -RKilauea.utm.nc+Uk -Jx1:160 -B5g5+u"@:8:000m" -BWSne -O --FONT_ANNOT_PRIMARY=10p \
    	--MAP_GRID_CROSS_SIZE_PRIMARY=0.1i --FONT_LABEL=10p >> $ps
    # Clean up
    rm -f Kilauea.utm_i.nc Kilauea.cpt tmp.txt

.. include:: fig_includes/fig_example_28.rst_

Gridding spherical surface data using splines
---------------------------------------------

Finally, we demonstrate how gridding on a spherical surface can be
accomplished using Green's functions of surface splines, with or without
tension. Global gridding does not work particularly well in Cartesian
coordinates hence the chosen approach. We use
`greenspline <greenspline.html>`_ to produce a crude
topography grid for Mars based on radii estimates from the Mariner 9 and
Viking Orbiter spacecrafts. This data comes from *Smith and Zuber*
[Science, 1996] and is used here as a small (*N* = 370) data set we can
use to demonstrate spherical surface gridding. Since
`greenspline <greenspline.html>`_ must solve a *N* by
*N* matrix system your system memory may impose limits on how large data
sets you can handle; also note that the spherical surface spline in
tension is particularly slow to compute.

Our script must first estimate the ellipsoidal shape of Mars from the
parameters given by *Smith and Zuber* so that we can remove this
reference surface from the gridded radii. We run the gridding twice:
First with no tension using *Parker*\ 's [1990] method and then with
tension using the *Wessel and Becker* [2008] method. The grids are then
imaged with `grdimage <grdimage.html>`_ and
`grdcontour <grdcontour.html>`_ and a color scale is placed between them.

   ::

    #!/bin/bash
    #		GMT EXAMPLE 29
    #
    # Purpose:	Illustrates spherical surface gridding with Green's function of splines
    # GMT progs:	makecpt, grdcontour, grdgradient, grdimage, grdmath greenspline, psscale, pstext
    # Unix progs:	rm, echo
    #
    ps=example_29.ps
    
    # This example uses 370 radio occultation data for Mars to grid the topography.
    # Data and information from Smith, D. E., and M. T. Zuber (1996), The shape of
    # Mars and the topographic signature of the hemispheric dichotomy, Science, 271, 184-187.
    
    # Make Mars PROJ_ELLIPSOID given their three best-fitting axes:
    a=3399.472
    b=3394.329
    c=3376.502
    grdmath -Rg -I4 -r X COSD $a DIV DUP MUL X SIND $b DIV DUP MUL ADD Y COSD DUP MUL MUL Y \
    	SIND $c DIV DUP MUL ADD SQRT INV = PROJ_ELLIPSOID.nc
    
    #  Do both Parker and Wessel/Becker solutions (tension = 0.9975)
    greenspline -RPROJ_ELLIPSOID.nc mars370.in -D4 -Sp -Gmars.nc
    greenspline -RPROJ_ELLIPSOID.nc mars370.in -D4 -SQ0.9975/5001 -Gmars2.nc
    # Scale to km and remove PROJ_ELLIPSOID
    grdmath mars.nc 1000 DIV PROJ_ELLIPSOID.nc SUB = mars.nc
    grdmath mars2.nc 1000 DIV PROJ_ELLIPSOID.nc SUB = mars2.nc
    makecpt -Crainbow -T-7/15/22 -Z > mars.cpt
    grdgradient mars2.nc -fg -Ne0.75 -A45 -Gmars2_i.nc
    grdimage mars2.nc -Imars2_i.nc -Cmars.cpt -B30g30 -BWsne -JH0/7i -P -K -E200 \
    	-UL/-0.5i/-0.75i/"Example 29 in Cookbook" --FONT_ANNOT_PRIMARY=12p -X0.75i > $ps
    grdcontour mars2.nc -J -O -K -C1 -A5 -Glz+/z- >> $ps
    psxy -Rg -J -O -K -Sc0.045i -Gblack mars370.in  >> $ps
    echo "0 90 b)" | pstext -R -J -O -K -N -D-3.5i/-0.2i -F+f14p,Helvetica-Bold+jLB >> $ps
    grdgradient mars.nc -fg -Ne0.75 -A45 -Gmars_i.nc
    grdimage mars.nc -Imars_i.nc -Cmars.cpt -B30g30 -BWsne -J -O -K -Y4.2i -E200 \
    	--FONT_ANNOT_PRIMARY=12p >> $ps
    grdcontour mars.nc -J -O -K -C1 -A5 -Glz+/z- >> $ps
    psxy -Rg -J -O -K -Sc0.045i -Gblack mars370.in  >> $ps
    psscale -Cmars.cpt -O -K -D3.5i/-0.15i/6i/0.1ih -I --FONT_ANNOT_PRIMARY=12p -Bx2f1 -By+lkm >> $ps
    echo "0 90 a)" | pstext -R -J -O -N -D-3.5i/-0.2i -F+f14p,Helvetica-Bold+jLB >> $ps
    # Clean up
    rm -f *.nc mars.cpt

.. include:: fig_includes/fig_example_29.rst_

Trigonometric functions plotted in graph mode
---------------------------------------------

Finally, we end with a simple mathematical illustration of sine and
cosine, highlighting the *graph* mode for linear projections and the new
curved vectors for angles.

The script simply draws a graph basemap, computes sine and cosine and
plots them as lines, then indicates on a circle that these quantities
are simply the projections of an unit vector on the x- and y-axis, at
the given angle.

   ::

    #!/bin/bash
    #		GMT EXAMPLE 30
    #
    # Purpose:	Show graph mode and math angles
    # GMT progs:	gmtmath, psbasemap, pstext and psxy
    # Unix progs:	echo, rm
    #
    # Draw generic x-y axes with arrows
    ps=example_30.ps
    
    psbasemap -R0/360/-1.25/1.75 -JX8i/6i -B90f30+u"\\312" -By1g10 -BWS+t"Two Trigonometric Functions" \
    	-K -U"Example 30 in Cookbook" --MAP_FRAME_TYPE=graph --MAP_VECTOR_SHAPE=0.5 > $ps
    
    # Draw sine an cosine curves
    
    gmtmath -T0/360/0.1 T COSD = | psxy -R -J -O -K -W3p >> $ps
    gmtmath -T0/360/0.1 T SIND = | psxy -R -J -O -K -W3p,0_6:0 --PS_LINE_CAP=round >> $ps
    
    # Indicate the x-angle = 120 degrees
    psxy -R -J -O -K -W0.5p,- << EOF >> $ps
    120	-1.25
    120	1.25
    EOF
    
    pstext -R -J -O -K -Dj0.2c -N -F+f+j << EOF >> $ps
    360 1 18p,Times-Roman RB x = cos(@%12%a@%%)
    360 0 18p,Times-Roman RB y = sin(@%12%a@%%)
    120 -1.25 14p,Times-Roman LB 120\\312
    370 -1.35 24p,Symbol LT a
    -5 1.85 24p,Times-Roman RT x,y
    EOF
    
    # Draw a circle and indicate the 0-70 degree angle
    
    echo 0 0 | psxy -R-1/1/-1/1 -Jx1.5i -O -K -X3.625i -Y2.75i -Sc2i -W1p -N >> $ps
    psxy -R -J -O -K -W1p << EOF >> $ps
    > x-gridline  -Wdefault
    -1	0
    1	0
    > y-gridline  -Wdefault
    0	-1
    0	1
    > angle = 0
    0	0
    1	0
    > angle = 120
    0	0
    -0.5	0.866025
    > x-projection -W2p
    -0.3333	0
    0	0
    > y-projection -W2p
    -0.3333	0.57735
    -0.3333	0
    EOF
    
    pstext -R -J -O -K -Dj0.05i -F+f+a+j << EOF >> $ps
    -0.16666 0 12p,Times-Roman 0 CT x
    -0.3333 0.2888675 12p,Times-Roman 0 RM y
    0.22 0.27 12p,Symbol -30 CB a
    -0.33333 0.6 12p,Times-Roman 30 LB 120\\312
    EOF
    
    echo 0 0 0.5i 0 120 | psxy -R -J -O -Sm0.15i+e -W1p -Gblack >> $ps

.. include:: fig_includes/fig_example_30.rst_

Using non-default fonts in *PostScript*
---------------------------------------

[sec:non-default-fonts-example]

This example illustrates several possibilities to create *GMT*\ plots
with non-default fonts. As these fonts are not part of the standard
*PostScript* font collection they have to be embedded in the PS- or
PDF-file with **Ghostscript**. See also
Appendix [sec:non-default-fonts] for further information. The script
includes the following steps:

-  create a ``CUSTOM_font_info.d`` file;

-  set the *GMT* parameters ``MAP_DEGREE_SYMBOL``, ``PS_CHAR_ENCODING``, and ``FONT``;

-  replace the default Helvetica font in the *GMT*-*PostScript*-File with sed;

-  create a *PostScript*-File with outlined fonts (optional);

-  convert *GMT*\ 's *PostScript* output to PDF or any image format (optional).

The script produces the plot in Figure [fig:example\ :sub:`3`\ 1]. All
standard fonts have been substituted by the free OpenType fonts Linux
Libertine (title) and Linux Biolinum (annotations). Uncomment the
appropriate lines in the script to make a *PostScript*-file with
outlined fonts or to convert to a PDF-file.

   ::

    #!/bin/bash
    #		GMT EXAMPLE 31
    #
    # Purpose:	Illustrate usage of non-default fonts in PostScript
    # GMT progs:	gmtset, pscoast, psxy, pstext, pslegend
    # Unix progs:	gs, awk, cat, rm
    #
    file=example_31
    ps=${file}.ps
    ps_outlined=${file}_outlined.ps
    eps_outlined=${file}_outlined.eps
    
    # create file CUSTOM_font_info.d in current working directory
    # and add PostScript font names of Linux Biolinum and Libertine
    awk '{print $1, 0.700, 0}' << EOF > CUSTOM_font_info.d
    LinBiolinumO
    LinBiolinumOI
    LinBiolinumOB
    LinLibertineOB
    EOF
    
    # common settings
    gmtset FORMAT_GEO_MAP ddd:mm:ssF \
    MAP_DEGREE_SYMBOL colon \
    MAP_TITLE_OFFSET 20p \
    MAP_GRID_CROSS_SIZE_PRIMARY 0.4c \
    PS_LINE_JOIN round \
    PS_CHAR_ENCODING ISO-8859-5 \
    FONT LinBiolinumO \
    FONT_TITLE 24p,LinLibertineOB \
    MAP_ANNOT_OBLIQUE 42
    
    # map of countries
    pscoast -Dl -R-7/31/64/66/r -JL15/50/40/60/16c -P \
            -Bx10g10 -By5g5 -B+t"Europe\072 Countries and Capital Cities" -A250 \
            -U"Example 31 in Cookbook" -Slightblue -Glightgreen -W0.25p -N1/1p,white -K > $ps
    
    # mark capitals
    psxy europe-capitals-ru.csv -R -J -i0,1 -Sc0.15c -G196/80/80 -O -K >> $ps
    
    # small EU cities
    awk 'BEGIN {FS=","} $4 !="" && $4 <= 1000000 {print $1, $2}' europe-capitals-ru.csv | \
        psxy -R -J -Sc0.15c -W0.25p -O -K >> $ps
    
    # big EU cities
    awk 'BEGIN {FS=","} $4 > 1000000 {print $1, $2}' europe-capitals-ru.csv | \
        psxy -R -J -Sc0.15c -W1.25p -O -K >> $ps
    
    # label big EU cities
    awk 'BEGIN {FS=","} $4 > 1000000 {print $1, $2, $3}' europe-capitals-ru.csv | \
        pstext -R -J -F+f7p,LinBiolinumOI+jBL -Dj0.1c -Gwhite -C5% -Qu -TO -O -K >> $ps
    
    # construct legend
    cat << EOF > legend.txt
    G -0.1c
    H 10 LinBiolinumOB Population of the European Union capital cities
    G 0.15c
    N 2
    S 0.15c c 0.15c 196/80/80 0.25p 0.5c < 1 Million inhabitants
    S 0.15c c 0.15c 196/80/80 1.25p 0.5c > 1 Million inhabitants
    N 1
    G 0.15c
    L 8 LinBiolinumOB L Population in Millions 
    N 6
    EOF
    
    # append city names and population to legend
    awk 'BEGIN {FS=","; f="L 8 LinBiolinumO L"}
        $4 > 1000000 {printf "%s %s:\n%s %.2f\n", f, $3, f, $4/1e6}' \
        europe-capitals-ru.csv >> legend.txt
    
    # reduce annotation font size for legend
    gmtset FONT_ANNOT_PRIMARY 8p
    
    # plot legend
    pslegend -R -J -Gwhite -Dx7.9c/12.6c/8.0c/BL -C0.3c/0.4c -L1.2 -F -O legend.txt >> $ps
    
    # make a PostScript and a PDF file with outlined fonts
    # unfortunately ps2raster won't be able to crop that file correctly anymore
    # use Heiko Oberdiek's pdfcrop (http://code.google.com/p/pdfcrop2/) instead
    # or crop with ps2raster -A -Te before
    #
    # a. remove GMT logo and crop EPS:
    #ps2raster -P -Au -Te -C-sFONTPATH="${PWD}/fonts" -Fex31CropNoLogo $ps
    # b. make PS with outlined fonts:
    #gs -q -sPAPERSIZE=a3 -dNOCACHE -dSAFER -dNOPAUSE -dBATCH -dNOPLATFONTS \
    #  -sDEVICE=pswrite -sFONTPATH="${PWD}/fonts" -sOutputFile=$ps_outlined ex31CropNoLogo.eps
    # c. make croppepd EPS:
    #gs -q -dNOCACHE -dSAFER -dNOPAUSE -dBATCH -dEPSCrop -sDEVICE=epswrite \
    #  -sOutputFile=$eps_outlined $ps_outlined
    # d. make cropped PDF:
    #ps2raster -P -A -Tf $ps_outlined
    # uncomment to do conversation to PDF and PNG
    # you will get a PDF with subsetted TrueType/PostScript fonts embedded
    # which you can still edit with your favorite vector graphics editor
    #export GS_FONTPATH="${PWD}/fonts"
    #ps2raster -P -A -Tf $ps
    #ps2raster -P -A -Tg -E110 $ps
    # clean up
    rm -f .gmtcommands* gmt.conf CUSTOM_font_info.d legend.txt ex31CropNoLogo.eps

.. include:: fig_includes/fig_example_31.rst_
    
Draping an image over topography
--------------------------------

In some cases, it is nice to "drape" an arbitrary image over a
topographic map. We have already seen how to use
`psimage <psimage.html>`_ to plot an image anywhere in
out plot. But here are aim is different, we want to manipulate an image
to shade it and plot it in 3-D over topography. This example was
originally created by Stephan Eickschen for a flyer emphasizing the
historical economical and cultural bond between Brussels, Maastricht and
Bonn. Obviously, the flag of the European Union came to mind as a good
"background".

To avoid adding large files to this example, some steps have been
already done. First we get the EU flag directly from the web and convert
it to a grid with values ranging from 0 to 255, where the higher values
will become yellow and the lower values blue. This use of
`grdreformat <grdreformat.html>`_ requires GDAL support.
`grdedit <grdedit.html>`_ then adds the right grid dimension.

The second step is to reformat the GTOPO30 DEM file to a netCDF grid as
well and then subsample it at the same pixels as the EU flag. We then
illuminate the topography grid so we can use it later to emphasize the
topography. The colors that we will use are those of the proper flag.
Lower values will become blue and the upper values yellow.

The call the `grdview <grdview.html>`_ plots a
topography map of northwest continental Europe, with the flagged draped
over it and with shading to show the little topography there is.
`pscoast <pscoast.html>`_ is used in conjunction with
`grdtrack <grdtrack.html>`_ and *GMT*\ psxyz to plot
borders "at altitude". Something similar is done at the end to plot some
symbols and names for cities.

The script produces the plot in Figure [fig:example\ :sub:`3`\ 2]. Note
that the PNG image of the flag can be downloaded directly in the call
the `grdreformat <grdreformat.html>`_, but we have
commented that out in the example because it requires compilation with
GDAL support. You will also see the
`grdcut <grdcut.html>`_ command commented out because we
did not want to store the 58 MB DEM file, whose location is mentioned in the script.

   ::

    #!/bin/bash
    #		GMT EXAMPLE 32
    #
    # Purpose:	Illustrate draping of an image over topography
    # GMT progs:	grdcut, grdedit, grdgradient, grdreformat, grdtrack, grdview
    # GMT progs:	pscoast, pstext, psxyz
    # Unix progs:	cat, rm
    # Credits:	Original by Stephan Eickschen
    #
    ps=example_32.ps
    
    # Here we get and convert the flag of Europe directly from the web through grdreformat using
    # GDAL support. We take into account the dimension of the flag (1000x667 pixels)
    # for a ratio of 3x2.
    # Because GDAL support will not be standard for most users, we have stored
    # the result, euflag.nc in this directory.
    
    Rflag=-R3/9/50/54
    # grdreformat \
    #   http://upload.wikimedia.org/wikipedia/commons/thumb/b/b7/Flag_of_Europe.svg/1000px-Flag_of_Europe.svg.png=gd \
    #   euflag.nc=ns
    # grdedit euflag.nc -fg $Rflag
    
    # Now get the topography for the same area from GTOPO30 and store it as topo.nc.
    # The DEM file comes from http://eros.usgs.gov/#/Find_Data/Products_and_Data_Available/gtopo30/w020n90
    # We make an gradient grid as well, which we will use to "illuminate" the flag.
    
    # grdcut W020N90.DEM $Rflag -Gtopo.nc=ns
    grdgradient topo.nc -A0/270 -Gillum.nc -Ne0.6
    
    # The color map assigns "Reflex Blue" to the lower half of the 0-255 range and
    # "Yellow" to the upper half.
    cat << EOF > euflag.cpt
    0	0/51/153	127	0/51/153
    127	255/204/0	255	255/204/0
    EOF
    
    # The next step is the plotting of the image.
    # We use grdview to plot the topography, euflag.nc to give the color, and illum.nc to give
    # the shading.
    
    Rplot=$Rflag/-10/790
    grdview topo.nc -JM13c $Rplot -Ceuflag.cpt -Geuflag.nc -Iillum.nc -Qc -JZ1c -p157.5/30 -P \
    	-K -U"Example 32 in Cookbook" > $ps
    
    # We now add borders. Because we have a 3-D plot, we want them to be plotted "at elevation".
    # So we write out the borders, pipe them through grdtack and then plot them with psxyz.
    
    pscoast $Rflag -Df -M -N1 | grdtrack -Gtopo.nc -sa | psxyz $Rplot -J -JZ -p -W1p,white \
    	-O -K >> $ps
    
    # Finally, we add dots and names for three cities.
    # Again, grdtrack is used to put the dots "at elevation".
    
    cat << EOF > cities.txt
    05:41:27 50:51:05 Maastricht
    04:21:00 50:51:00 Bruxelles
    07:07:03 50:43:09 Bonn
    EOF
    
    grdtrack -Gtopo.nc -sa cities.txt | psxyz -i0,1,3 $Rplot -J -JZ -p -Sc7p -W1p,white -Gred \
    	-K -O >> $ps
    pstext $Rplot -J -JZ -p -F+f12p,Helvetica-Bold,red+jRM -Dj0.1i/0.0i -O cities.txt >> $ps
    
    # cleanup
    
    rm -f gmt.conf euflag.cpt illum.nc cities.txt

.. include:: fig_includes/fig_example_32.rst_

Stacking automatically generated cross-profiles
-----------------------------------------------

The script produces the plot in Figure [fig:example\ :sub:`3`\ 3]. Here
we demonstrate how `grdtrack <grdtrack.html>`_ can be
used to automatically create a suite of crossing profiles of uniform
spacing and length and then sample one or more grids along these
profiles; we also use the median stacking option to create a stacked
profile, showed above the map, with the gray area representing the
variations about the stacked median profile.

   ::

    #!/bin/bash
    #               GMT EXAMPLE 33
    #
    # Purpose:      Illustrate grdtracks new cross-track and stacking options
    # GMT progs:    makecpt, gmtconvert, grdimage, grdgradient, grdtrack, pstext, psxy
    # GMT progs:    pscoast, pstext, psxyz
    # Unix progs:   cat, rm
    #
    ps=example_33.ps
    
    # Extract a subset of ETOPO1m for the East Pacific Rise
    # grdcut etopo1m_grd.nc -R118W/107W/49S/42S -Gspac.nc
    makecpt -Crainbow -T-5000/-2000/500 -Z > z.cpt
    grdgradient spac.nc -A15 -Ne0.75 -Gspac_int.nc
    grdimage spac.nc -Ispac_int.nc -Cz.cpt -JM6i -P -Baf -K -Xc --FORMAT_GEO_MAP=dddF \
    	-U"Example 33 in Cookbook" > $ps
    # Select two points along the ridge
    cat << EOF > ridge.txt
    -111.6	-43.0
    -113.3	-47.5
    EOF
    # Plot ridge segment and end points
    psxy -Rspac.nc -J -O -K -W2p,blue ridge.txt >> $ps
    psxy -R -J -O -K -Sc0.1i -Gblue ridge.txt >> $ps
    # Generate cross-profiles 400 km long, spaced 10 km, samped every 2km
    # and stack these using the median, write stacked profile
    grdtrack ridge.txt -Gspac.nc -C400k/2k/10k -Sm+sstack.txt > table.txt
    psxy -R -J -O -K -W0.5p table.txt >> $ps
    # Show upper/lower values encountered as an envelope
    gmtconvert stack.txt -o0,5 > env.txt
    gmtconvert stack.txt -o0,6 -I -T >> env.txt
    psxy -R-200/200/-3500/-2000 -Bxafg1000+l"Distance from ridge (km)" -Byaf+l"Depth (m)" -BWSne \
    	-JX6i/3i -O -K -Glightgray env.txt -Y6.5i >> $ps
    psxy -R -J -O -K -W3p stack.txt >> $ps
    echo "0 -2000 MEDIAN STACKED PROFILE" | pstext -R -J -O -K -Gwhite -F+jTC+f14p -Dj0.1i >> $ps
    psxy -R -J -O -T >> $ps
    # cleanup
    rm -f gmt.conf z.cpt spac_int.nc ridge.txt table.txt env.txt stack.txt

.. include:: fig_includes/fig_example_33.rst_

Using country polygons for plotting and shading
-----------------------------------------------

The script produces the plot in Figure [fig:example\ :sub:`3`\ 4]. Here
we demonstrate how `pscoast <pscoast.html>`_ can be used to extract
and plot country polygons.  We show two panels; one in which we do
a basic basemap and another where we lay down a color topography
image and then place a transparent layer identifying the future
Franco-Italian Union whose untimely breakup in 2045 the historians
will continue to debate for some time.

   ::

    #!/bin/bash
    #               GMT EXAMPLE 34
    #
    # Purpose:      Illustrate pscoast with DCW country polygons
    # GMT progs:    pscoast, makecpt, grdimage, grdgradient
    # Unix progs:   rm
    #
    ps=example_34.ps
    gmtset FORMAT_GEO_MAP dddF
    pscoast -JM4.5i -R-6/20/35/52 -FFR,IT+fP300/8 -Glightgray -Baf -BWSne -P -K \
    	-X2i -U-1.75i/-0.75i/"Example 34 in Cookbook" > $ps
    # Extract a subset of ETOPO2m for this part of Europe
    # grdcut etopo2m_grd.nc -R -GFR+IT.nc=ns
    makecpt -Cglobe -T-5000/5000/500 -Z > z.cpt
    grdgradient FR+IT.nc -A15 -Ne0.75 -GFR+IT_int.nc
    grdimage FR+IT.nc -IFR+IT_int.nc -Cz.cpt -J -O -K -Y4.5i \
    	-Baf -BWsnE+t"Franco-Italian Union, 2042-45" >> $ps
    pscoast -J -R -FFR,IT+fred@60 -O >> $ps
    # cleanup
    rm -f gmt.conf FR+IT_int.nc z.cpt

.. include:: fig_includes/fig_example_34.rst_

Spherical triangulation and distance calculations
-------------------------------------------------

The script produces the plot in Figure [fig:example\ :sub:`3`\ 5]. Here
we demonstrate how `sphtriangulate <sphtriangulate.html>`_ and
`sphdistance <sphdistance.html>`_ are used to compute the Delauney and
Voronoi information on a sphere, using a decimated GSHHG crude coastline.
We show a color image of the distances, highlighted with 500-km contours,
and overlay the Voronoi polygons in green.  Finally, the continents are
placed on top.

   ::

    #!/bin/bash
    #               GMT EXAMPLE 35
    #               $Id$
    #
    # Purpose:      Illustrate sphtriangulate and sphdistance with GSHHG crude data
    # GMT progs:    pscoast, psxy, makecpt, grdimage, grdcontour, sphtriangulate, sphdistance
    # Unix progs:   rm
    #
    ps=example_35.ps
    
    # Get the crude GSHHS data, select GMT format, and decimate to ~20%:
    # gshhs gshhs_c.b | $AWK '{if ($1 == ">" || NR%5 == 0) print $0}' > gshhs_c.txt
    # Get Voronoi polygons
    gmt sphtriangulate gshhs_c.txt -Qv -D > tt.pol
    # Compute distances in km
    gmt sphdistance -Rg -I1 -Qtt.pol -Gtt.nc -Lk
    makecpt -Chot -T0/3500/500 -Z > t.cpt
    # Make a basic image plot and overlay contours, Voronoi polygons and coastlines
    gmt grdimage tt.nc -JG-140/30/7i -Ct.cpt -U/-0.5i/-1.75i/"Example 35 in Cookbook" \
        -X0.75i -Y2i -P -K > $ps
    gmt grdcontour tt.nc -J -O -K -C500 -A1000+f10p,Helvetica,white -L500 -\
        GL0/90/203/-10,175/60/170/-30,-50/30/220/-5 -Wa0.75p,white -Wc0.25p,white >> $ps
    gmt psxy -R -J -O -K tt.pol -W0.25p,green,. >> $ps
    gmt pscoast -R -J -W1p -Gsteelblue -A0/1/1 -B30g30 -B+t"Distances from GSHHG crude coastlines" \
        -O >> $ps
    # cleanup
    rm -f gmt.conf tt.pol tt.nc t.cpt

.. include:: fig_includes/fig_example_35.rst_

Spherical gridding using Renka's algorithms
-------------------------------------------

The next script produces the plot in Figure [fig:example\ :sub:`3`\ 6]. Here
we demonstrate how `sphtinterpolate <sphtinterpolate.html>`_ can be used
to perform spherical gridding.  Our example uses early measurements of
the radius of Mars from Mariner 9 and Viking Orbiter spacecrafts.  The
middle panels shows the data distribution while the top and bottom panel
are images of the interpolation using a piecewise linear interpolation
and a smoothed spline interpolation, respectively.  For spherical gridding
with large volumes of data we recommend `sphtinterpolate <sphtinterpolate.html>`_
while for small data sets (such as this one, actually) you have more flexibility
with `greenspline <greenspline.html>`_.

   ::

    #!/bin/bash
    #               GMT EXAMPLE 36
    #               $Id$
    #
    # Purpose:      Illustrate sphinterpolate with Mars radii data
    # GMT progs:    psxy, makecpt, grdimage, sphinterpolate
    # Unix progs:   rm
    #
    ps=example_36.ps
    # Interpolate data of Mars radius from Mariner 9 and Viking Orbiter spacecrafts
    gmt makecpt -Crainbow -T-7000/15000/1000 -Z > tt.cpt
    # Piecewise linear interpolation; no tension
    gmt sphinterpolate mars370.txt -Rg -I1 -Q0 -Gtt.nc
    gmt grdimage tt.nc -JH0/6i -Bag -Ctt.cpt -P -Xc -Y7.25i -K -U/-1i/-7i/"Example 36 in Cookbook" > $ps
    gmt psxy -Rg -J -O -K mars370.txt -Sc0.05i -G0 -B30g30 -Y-3.25i >> $ps
    # Smoothing
    gmt sphinterpolate mars370.txt -Rg -I1 -Q3 -Gtt.nc
    gmt grdimage tt.nc -J -Bag -Ctt.cpt  -Y-3.25i -O -K >> $ps
    gmt psxy -Rg -J -O -T >> $ps
    # cleanup
    rm -f gmt.conf tt.cpt tt.nc

.. include:: fig_includes/fig_example_36.rst_

Spectral coherence between gravity and bathymetry grids
-------------------------------------------------------

The next script produces the plot in Figure [fig:example\ :sub:`3`\ 7].
We demonstrate how `grdfft <grdfft.html>`_ is used to compute the
spectral coherence between two data sets, here multibeam bathymetry
and satellite-derived gravity.  The grids are detrended and tapered
before the Fourier transform is computed; the intermediate plots show
the grids being extended and padded to a suitable dimension.

   ::

    #!/bin/bash
    #               GMT EXAMPLE 37
    #               $Id$
    #
    # Purpose:      Illustrate 2-D FFT and coherence between gravity and bathymetry grids
    # GMT progs:    psbasemap, psxy, makecpt, grdfft, grdimage, grdinfo, grdgradient
    # Unix progs:   rm
    #
    ps=example_37.ps
    
    # Testing gmt grdfft coherence calculation with Karen Marks example data
    # Prefix of two .nc files
    
    G=grav.V18.par.surf.1km.sq
    T=mb.par.surf.1km.sq
    gmt gmtset FONT_TITLE 14p
    
    gmt makecpt -Crainbow -T-5000/-3000/100 -Z > z.cpt
    gmt makecpt -Crainbow -T-50/25/5 -Z > g.cpt
    gmt grdinfo $T.nc -Ib > bbox
    gmt grdgradient $G.nc -A0 -Nt1 -G${G}_int.nc
    gmt grdgradient $T.nc -A0 -Nt1 -G${T}_int.nc
    scl=1.4e-5
    sclkm=1.4e-2
    gmt grdimage $T.nc -I${T}_int.nc -Jx${scl}i -Cz.cpt -U/-1.224i/-0.75i/"Example 37 in Cookbook" \
        -P -K -X1.474i -Y1i > $ps
    gmt psbasemap -R-84/75/-78/81 -Jx${sclkm}i -O -K -Ba -BWSne+t"Multibeam bathymetry" >> $ps
    gmt grdimage $G.nc -I${G}_int.nc -Jx${scl}i -Cg.cpt -O -K -X3.25i >> $ps
    gmt psbasemap -R-84/75/-78/81 -Jx${sclkm}i -O -K -Ba -BWSne+t"Satellite gravity" >> $ps
    
    gmt grdfft $T.nc $G.nc -Ewk -N192/192+d+wtmp > cross.txt
    gmt grdgradient ${G}_tmp.nc -A0 -Nt1 -G${G}_tmp_int.nc
    gmt grdgradient ${T}_tmp.nc -A0 -Nt1 -G${T}_tmp_int.nc
    
    gmt makecpt -Crainbow -T-1500/1500/100 -Z > z.cpt
    gmt makecpt -Crainbow -T-40/40/5 -Z > g.cpt
    
    gmt grdimage ${T}_tmp.nc -I${T}_tmp_int.nc -Jx${scl}i -Cz.cpt -O -K -X-3.474i -Y3i >> $ps
    gmt psxy -R${T}_tmp.nc -J bbox -O -K -L -W0.5p,- >> $ps
    gmt psbasemap -R-100/91/-94/97 -Jx${sclkm}i -O -K -Ba -BWSne+t"Detrended and extended" >> $ps
    
    gmt grdimage ${G}_tmp.nc -I${G}_tmp_int.nc -Jx${scl}i -Cg.cpt -O -K -X3.25i >> $ps
    gmt psxy -R${G}_tmp.nc -J bbox -O -K -L -W0.5p,- >> $ps
    gmt psbasemap -R-100/91/-94/97 -Jx${sclkm}i -O -K -Ba -BWSne+t"Detrended and extended" >> $ps
    
    gmt gmtset FONT_TITLE 24p
    gmt psxy cross.txt -i0,15 -R2/160/0/1 -JX-6il/2.5i -W0.5p -Bxa2f3g3+u" km" -Byafg0.5+l"Coherency@+2@+" \
        -BWsNe+t"Coherency between gravity and bathymetry" -O -K -X-3.25i -Y3.3i >> $ps
    gmt psxy -R -J cross.txt -O -K -i0,15,16 -Sc0.075i -Gred -W0.25p -Ey >> $ps
    gmt psxy -R -J -O -T >> $ps
    rm -f cross.txt *_tmp.nc *_int.nc ?.cpt bbox

.. include:: fig_includes/fig_example_37.rst_

Histogram equalization of bathymetry grids
------------------------------------------

The next script produces the plot in Figure [fig:example\ :sub:`3`\ 8].
This example shows how to use histogram equalization to enhance various
ranges of a grid depending on its frequency distribution.  The key tool
used here is `grdhisteq <grdhisteq.html>`_.

   ::

    #!/bin/bash
    #               GMT EXAMPLE 38
    #               $Id$
    #
    # Purpose:      Illustrate histogram equalization on topography grids
    # GMT progs:    psscale, pstext, makecpt, grdhisteq, grdimage, grdinfo, grdgradient
    # Unix progs:   rm
    #
    ps=example_38.ps
    
    gmt makecpt -Crainbow -T0/1700/100 -Z > t.cpt
    gmt makecpt -Crainbow -T0/15/1 > c.cpt
    gmt grdgradient topo.nc -Nt1 -fg -A45 -Gitopo.nc
    gmt grdhisteq topo.nc -Gout.nc -C16
    gmt grdimage topo.nc -Iitopo.nc -Ct.cpt -B5 -BWSne -U/-0.75i/-5.75i/"Example 38 in Cookbook" \
        -JM3i -Y6i -K -P > $ps
    echo "315 -10 Original" | gmt pstext -Rtopo.nc -J -O -K -F+jTR+f14p -T -Gwhite -W1p -Dj0.1i >> $ps
    gmt grdimage out.nc -Cc.cpt -J -X3.5i -K -O -B5 -BWSne >> $ps
    echo "315 -10 Equalized" | gmt pstext -R -J -O -K -F+jTR+f14p -T -Gwhite -W1p -Dj0.1i >> $ps
    gmt psscale -D0i/-0.4i/5i/0.15ih -O -K -Ct.cpt -Ba500 -By+lm -E+n >> $ps
    gmt grdhisteq topo.nc -Gout.nc -N
    gmt makecpt -Crainbow -T-3/3/0.1 -Z > c.cpt
    gmt grdimage out.nc -Cc.cpt -J -X-3.5i -Y-4i -K -O -B5 -BWSne >> $ps
    echo "315 -10 Normalized" | gmt pstext -R -J -O -K -F+jTR+f14p -T -Gwhite -W1p -Dj0.1i >> $ps
    gmt grdhisteq topo.nc -Gout.nc -N
    gmt grdimage out.nc -Cc.cpt -J -X3.5i -K -O -B5 -BWSne >> $ps
    echo "315 -10 Quadratic" | gmt pstext -R -J -O -K -F+jTR+f14p -T -Gwhite -W1p -Dj0.1i >> $ps
    gmt psscale -D0i/-0.4i/5i/0.15ih -O -Cc.cpt -Bx1 -By+lz -E+n >> $ps
    rm -f itopo.nc out.nc ?.cpt

.. include:: fig_includes/fig_example_38.rst_

Evaluation of spherical harmonics coefficients
----------------------------------------------

The next script produces the plot in Figure [fig:example\ :sub:`3`\ 9].
We use a spherical harmonic model for the topography of Venus and evaluate
the resulting global grid for three sets of upper order/degrees, here 30,
90, and 180; the original file (see below) goes to order and degree 720.
We use the coefficients to evaluate the grids and make perspective globes
of the different resolutions.  The key tool
used here is `sph2grd <sph2grd.html>`_.

   ::

    #!/bin/bash
    #               GMT EXAMPLE 39
    #               $Id$
    #
    # Purpose:      Illustrate evaluation of spherical harmonic coefficients
    # GMT progs:    psscale, pstext, makecpt, grdimage, grdgradient. sph2grd
    # Unix progs:   rm
    #
    ps=example_39.ps
    
    # Evaluate the first 180, 90, and 30 order/degrees of Venus spherical
    # harmonics topography model, skipping the L = 0 term (radial mean).
    # File truncated from http://www.ipgp.fr/~wieczor/SH/VenusTopo180.txt.zip
    # Wieczorek, M. A., Gravity and topography of the terrestrial planets,
    #   Treatise on Geophysics, 10, 165-205, doi:10.1016/B978-044452748-6/00156-5, 2007
    
    gmt sph2grd VenusTopo180.txt -I1 -Rg -Ng -Gv1.nc -F1/1/25/30
    gmt sph2grd VenusTopo180.txt -I1 -Rg -Ng -Gv2.nc -F1/1/85/90
    gmt sph2grd VenusTopo180.txt -I1 -Rg -Ng -Gv3.nc -F1/1/170/180
    gmt grd2cpt v3.nc -Crainbow -E16 -Z > t.cpt
    grdgradient v1.nc -Nt0.75 -A45 -Gvint.nc
    gmt grdimage v1.nc -Ivint.nc -JG90/30/5i -P -K -Bg -Ct.cpt -X3i -Y1.1i \
        -U/-2.75i/-0.85i/"Example 39 in Cookbook" > $ps
    echo 4 4.5 L = 30 | gmt pstext -R0/6/0/6 -Jx1i -O -K -Dj0.2i -F+f16p+jLM -N >> $ps
    psscale -Ct.cpt -O -K -D1.25i/-0.2i/5.5i/0.1ih -Bxaf -By+lm >> $ps
    grdgradient v2.nc -Nt0.75 -A45 -Gvint.nc
    gmt grdimage v2.nc -Ivint.nc -JG -O -K -Bg -Ct.cpt -X-1.25i -Y1.9i >> $ps
    echo 4 4.5 L = 90 | gmt pstext -R0/6/0/6 -Jx1i -O -K -Dj0.2i -F+f16p+jLM -N >> $ps
    gmt sph2grd VenusTopo180.txt -I1 -Rg -Ng -Gv3.nc -V -F1/1/170/180
    grdgradient v3.nc -Nt0.75 -A45 -Gvint.nc
    gmt grdimage v3.nc -Ivint.nc -JG -O -K -Bg -Ct.cpt -X-1.25i -Y1.9i >> $ps
    echo 4 4.5 L = 180 | gmt pstext -R0/6/0/6 -Jx1i -O -K -Dj0.2i -F+f16p+jLM -N >> $ps
    echo 3.75 5.4 Venus Spherical Harmonic Model | gmt pstext -R0/6/0/6 -Jx1i -O \
        -F+f24p+jCM -N >> $ps
    rm -f v*.nc t.cpt

.. include:: fig_includes/fig_example_39.rst_

Creating GMT Animations
=======================

[ch:8]

Unlike the previous chapter, in this chapter we will explore what is
involved in creating animations (i.e., movies). Of course, an animation
is nothing more than a series of individual images played back in an
orderly fashion. Here, these images will have been created with *GMT*.
To ensure a smooth transition from frame to frame we will be following
some general guidelines when writing our scripts. Since there is no
"movie" mode in *GMT* we must take care of all the book-keeping in our
script. Thus, animations may require a bit of planning and may use more
advanced scripting than the previous static examples. Note: This is a
new chapter introduced with the 4.4.0 version and should be considered
work in progress.

Most, if not all, animation scripts must deal with several specific
phases of movie making:

#. Define parameters that determine the dimension of the final movie.

#. Pre-calculate all variables, data tables, grids, or background map
   layers that are *independent* of your time variable.

#. Have a frame-number loop where each frame is created as a
   *PostScript* plot, then rasterized to a TIFF file of chosen
   dimension.

#. Convert the individual frames to a single movie of suitable format.

#. Clean up temporary files and eventually the individual frames.

We will discuss these phases in more detail before showing our first
example.

#. There are several coordinates that you need to consider when planning
   your movie. The first is the coordinates of your data, i.e., the
   *user coordinates*. As with all *GMT* plots you will transform those
   to the second set of *plot coordinates* in inches (or cm) by applying
   a suitable region and map projection. As before, you normally do this
   with a particular paper size in mind. When printed you get a
   high-resolution plot in monochrome or color. However, movies are not
   device-independent and you must finally consider the third set of
   *pixel coordinates* which specifies the resolution of the final
   movie. We control the frame size by selecting a suitable *dpi*
   setting that will scale your physical dimensions to the desired frame
   size in pixels. If you decide up front on a particular resolution
   (e.g., 480 by 320 pixels) then you should specify a paper size and
   *dpi* so that their product yields the desired pixel dimensions. For
   instance, here it might make sense to plan your plotting on a 4.8 by
   3.2 inch "paper" and use 100 *dpi* to convert it to pixels, but you
   are free to use any combination that multiplies to the desired
   dimensions. After deciding on frame size you need to consider how
   many frames your movie should have. This depends on lots of things
   such as how patient you are, how many frames per second you need and
   the time range of your animation. We recommend you use variables to
   specify the items that go into computing the number of frames so that
   you can easily test your script with a few frames before changing
   settings and running the full Hollywood production overnight.

#. Depending on what you want to display, there are usually many
   elements that do not change between frames. Examples include a
   coastline base map for background, an overlay of text legends,
   perhaps some variables that hold information that will be used during
   the movie, and possibly subsets of larger data sets. Since
   movie-making can take a long time if you are ambitious, it is best to
   compute or plot all the elements that can be done outside your main
   frame-loop rather than waste time doing the same thing over and over
   again. You are then ready for the main loop.

#. Initialize a frame counter to 0 and have a loop that continues until
   your frame counter equals the desired number of frames. You must use
   your frame counter to create a unique file name for each frame image
   so that the series of images can be lexically arranged. We recommend
   using the *GMT* shell function **gmt_set_framename** to format
   the frame counter with an adequate number of leading zeros; see our
   examples for details. The bulk of your main loop involves create the
   single *PostScript* plot for this particular frame (time). This can
   be trivial or a serious scripting exercise depending on what you want
   to show. We will give a few examples with increasing complexity. Once
   the *PostScript* plot is created you need to rasterize it; we
   recommend you use `ps2raster <ps2raster.html>`_ to
   generate a TIFF image at the agreed-upon resolution. We also
   recommend that you place all frame images in a sub-directory. You may
   increment your frame counter using **gmt_set_framenext**.

#. Once you have all your frames you are ready to combine them into an
   animation. There are two general approaches. (a) If your image
   sequence is not too long then you can convert the images into a
   single animated GIF file. This file can be included in PowerPoint
   presentations or placed on a web page and will play back as a movie
   by pausing the specified amount between frames, optionally repeating
   the entire sequence one or more times. (b) For more elaborate
   projects you will need to convert the frames into a proper movie
   format such as Quicktime, AVI, MPEG-2, MPEG-4, etc., etc. There are
   both free and commercial tools that can help with this conversion and
   they tend to be platform-specific. Most movie tools such as iMovie or
   MovieMaker can ingest still images and let you specify the frame
   duration. Under OS X we prefer to use Quicktime. [30]_ Free tools
   exist to call the Quicktime library functions from the command line
   as we prefer to do in our scripts. Another choice is to use the free
   `mencoder <http://www.mplayerhq.hu/design7/news.html>`_.
   You will find yourself
   experimenting with compression settings and movie formats so that the
   final movie has the resolution and portability you require.

#. Finally, when all is done you should delete any temporary files
   created. However, since creating the frames may take a lot of time it
   is best to not automatically delete the frame sub directory. That way
   you can redo the frames-to-movie conversion with different settings
   until you are satisfied.

Animation of the sine function
------------------------------

Our first animation is not very ambitious: We wish to plot the sine
function from 0-360 and take snap shots every 20. To get a smooth curve
we must sample the function much more frequently; we settle on 10 times
more frequently than the frame spacing. We place a bright red circle at
the leading edge of the curve, and as we move forward in time (here,
angles) we dim the older circles to a dark red color. We add a label
that indicates the current angle value. Once the 18 frames are completed
we convert them to a single animated GIF file and write a plain HTML
wrapper with a simple legend. Opening the HTML page in ``anim01.html`` the browser will
display the animation.

.. literalinclude:: ../../examples/anim01/anim_01.sh

Make sure you understand the purpose of all the steps in our script. In
this case we did some trial-and-error to determine the exact values to
use for the map projection, the region, the spacing around the frame,
etc. so that the final result gave a reasonable layout. Do this planning
on a single *PostScript* plot before running a lengthy animation script.

Examining DEMs using variable illumination
------------------------------------------

Our next animation uses a gridded topography for parts of Colorado (US);
the file is distributed with the tutorial examples. Here, we want to use
`grdimage <grdimage.html>`_ to generate a shaded-relief
image sequence in which we sweep the illumination azimuth around the
entire horizon. The resulting animation illustrates how changing the
illumination azimuth can bring out subtle features (or artifacts) in the
gridded data. The red arrow points in the direction of the illumination.

.. literalinclude:: ../../examples/anim02/anim_02.sh

As you can see, these sorts of animations are not terribly difficult to
put together, especially since our vantage point is fixed. In the next
example we will move the "camera" around and must therefore deal with
how to frame perspective views.

Orbiting a static map
---------------------

Our third animation keeps a fixed gridded data set but moves the camera
angle around the full 360. We use
`grdview <grdview.html>`_ to generate a shaded-relief
image sequence using the new enhanced **-E** option. No additional
information is plotted on the image. As before we produce an animated
GIF image and a simple HTML wrapper for it.

.. literalinclude:: ../../examples/anim03/anim_03.sh

Flying over topography
----------------------

Our next animation simulates what an imaginary satellite might see as it
passes in a great circle from New York to Miami at an altitude of 160
km. We use the general perspective view projection with
`grdimage <grdimage.html>`_ and use
`project <project.html>`_ to create a great circle path
between the two cities, sampled every 5 km. The main part of the script
will make the DVD-quality frames from different view points, draw the
path on the ground, and add frame numbers to each frame. As this
animation generates 355 frames we can use 3rd party tools to turn the
image sequence into a MPEG-4 movie [31]_. Note: At the moment,
`grdview <grdview.html>`_ cannot use general perspective
view projection to allow "fly-through" animations like Fledermaus; we
expect to add this functionality in a future version.

.. literalinclude:: ../../examples/anim04/anim_04.sh

