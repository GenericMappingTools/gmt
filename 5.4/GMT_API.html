
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    <title>1. Introduction &#8212; GMT 5.4.6_c5d65a4_2019.11.05 documentation</title>

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"/>


    <link rel="stylesheet" href="_static/rtd.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/searchtools.js"></script>
    <script type="text/javascript" src="_static/rtd-sidebar.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="MATLAB Wrapper" href="ml_wrapper.html" />
    <link rel="prev" title="GMT_API" href="api.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="ml_wrapper.html" title="MATLAB Wrapper"
             accesskey="N">next</a> </li>
        <li class="right" >
          <a href="api.html" title="GMT_API"
             accesskey="P">previous</a> </li>
  <li><a href="/projects/gmt/wiki/Documentation">Project Home</a>  &#187;</li>
  
        <li class="nav-item nav-item-0"><a href="index.html">GMT 5.4.6_c5d65a4_2019.11.05 documentation</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="api.html" accesskey="U">GMT_API</a> &#187;</li>
<li class="right">
<form class="search" accept-charset="UTF-8" action="search.html" method="get">
  <div style="margin:0;padding:0;display:inline"><input name="utf8" type="hidden" value="✓"></div>
  <label for="q">
    <a class="search" href="search.html" accesskey="s" original-title="">Search:</a>
  </label>
  <input accesskey="f" class="small" id="q" name="q" size="20" type="text">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form></li>
   

      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <p><strong>The Generic Mapping Tools</strong></p>
<p><strong>C/C++ Application Programming Interface</strong></p>
<p><strong>Pål (Paul) Wessel</strong></p>
<p><strong>SOEST, University of Hawai’i at Manoa</strong></p>
<p><strong>Walter H. F. Smith</strong></p>
<p><strong>Laboratory for Satellite Altimetry, NOAA/NESDIS/STAR</strong></p>
<p><strong>Remko Scharroo</strong></p>
<p><strong>EUMETSAT, Darmstadt, Germany</strong></p>
<p><strong>Joaquim F. Luis</strong></p>
<p><strong>Universidade do Algarve, Faro, Portugal</strong></p>
<p><strong>Florian Wobbe</strong></p>
<p><strong>Alfred Wegener Institute, Germany</strong></p>
<div class="section" id="introduction">
<h1>1. Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h1>
<div class="section" id="preamble">
<span id="index-0"></span><h2>1.1. Preamble<a class="headerlink" href="#preamble" title="Permalink to this headline">¶</a></h2>
<div class="figure align-center" id="id12">
<a class="reference internal image-reference" href="_images/GMT4_mode.png"><img alt="_images/GMT4_mode.png" src="_images/GMT4_mode.png" style="width: 561.0px; height: 277.0px;" /></a>
<p class="caption"><span class="caption-text">GMT 4 programs contain all the high-level functionality.</span></p>
</div>
<p>Prior to version 5, the bulk of GMT functionality was coded directly
in the standard GMT C program modules (e.g., <code class="docutils literal notranslate"><span class="pre">surface.c</span></code>, <code class="docutils literal notranslate"><span class="pre">psxy.c</span></code>, <code class="docutils literal notranslate"><span class="pre">grdimage.c</span></code>, etc.). The
GMT library only offered access to low-level functions from which
those high-level GMT programs were built. The standard GMT programs
have been very successful, with tens of thousands of users world-wide.
However, the design of the main programs prevented developers from
leveraging GMT functionality from within other programming
environments since access to GMT tools could only be achieved via
system calls <a class="footnote-reference" href="#id7" id="id1">[1]</a>. Consequently, all data i/o had to be done via
temporary files. The design also prevented the GMT developers
themselves from taking advantage of these modules directly. For
instance, the tool <a class="reference internal" href="pslegend.html"><span class="doc">pslegend</span></a> needed to
make extensive use of system calls to <a class="reference internal" href="psxy.html"><span class="doc">psxy</span></a> and
<a class="reference internal" href="pstext.html"><span class="doc">pstext</span></a> in order to plot the lines,
symbols and text that make up a map legend, making it a very awkward
program to maintain.</p>
<div class="figure align-center" id="id13">
<a class="reference internal image-reference" href="_images/GMT5_mode.png"><img alt="_images/GMT5_mode.png" src="_images/GMT5_mode.png" style="width: 558.0px; height: 199.5px;" /></a>
<p class="caption"><span class="caption-text">GMT 5 programs contain all the high-level functionality.</span></p>
</div>
<p>Starting with GMT version 5, all standard GMT programs have been
rewritten into separate function “modules” invoked by a single
driver program called <code class="docutils literal notranslate"><span class="pre">gmt.c</span></code>.
The <a class="reference internal" href="gmt.html"><span class="doc">gmt</span></a> executable simply calls the corresponding
GMT modules; it is these modules that do all the work. These new
functions have been placed in a new GMT high-level API library and can
be called from a variety of environments (C/C++, Fortran, Julia, Python,
MATLAB, Visual Basic, R, etc.) <a class="footnote-reference" href="#id8" id="id2">[2]</a>. For example, the main
program <code class="docutils literal notranslate"><span class="pre">blockmean.c</span></code> has been reconfigured as a high-level function
<code class="docutils literal notranslate"><span class="pre">GMT_blockmean()</span></code>, which does the actual spatial averaging and can
pass the result back to the calling program (or write it to file). The
previous behavior of <code class="docutils literal notranslate"><span class="pre">blockmean.c</span></code> is achieved by calling <code class="docutils literal notranslate"><span class="pre">gmt</span> <span class="pre">blockmean</span></code>,
i.e., the module is now just the first argument to the <a class="reference internal" href="gmt.html"><span class="doc">gmt</span></a> executable.
For backwards compatibility with older GMT (4) scripts we optionally
install numerous symbolic links to the gmt executable with names such
as blockmean, psxy, surface, etc.  The gmt executable is smart enough to
understand when it is being invoked via one of these links and then knows
which module to call upon.
Consequently, <code class="docutils literal notranslate"><span class="pre">blockmean.c</span></code> and other files do in
fact no longer exist.</p>
<div class="figure align-center" id="id14">
<a class="reference internal image-reference" href="_images/GMT5_external.png"><img alt="_images/GMT5_external.png" src="_images/GMT5_external.png" style="width: 596.5px; height: 308.0px;" /></a>
<p class="caption"><span class="caption-text">GMT 5 API showing current and future external environments.</span></p>
</div>
</div>
<div class="section" id="the-i-o-abstraction-layer">
<h2>1.2. The i/o abstraction layer<a class="headerlink" href="#the-i-o-abstraction-layer" title="Permalink to this headline">¶</a></h2>
<p>In order for the API to be as flexible as possible we have
generalized the notions of input and output. Data that already reside in
an application’s memory may serve as input to a GMT module and we refer
to such data as “Virtual Files”. Other
sources of input may be file pointers and file descriptors (as well as
the standard mechanism for passing file names). For standard
data table i/o, the GMT API takes care of the task of assembling any
combination of files, pointers, and memory locations into <em>a single
virtual data set</em> from which the GMT module may read (a) all
records at once into memory, or (b) read one record at a time. Likewise,
GMT functions may write their output to a virtual destination, which
might be a memory location in the user’s application (another Virtual File), a file pointer or
descriptor, or an output file. The GMT modules are unaware of these
details and simply read from a “source” and write to a “destination”.
Thus, the standard concept of file-based input/output so familiar to
any GMT user carries over to the API, except for the generalization
that files can be virtual files already in memory.  Because of this
design we will see that we need to associate these virtual files
with special filenames that we may pass to modules, and the modules
will faithfully treat these as real files.  However, under the hood
the API layer will take care of the differences between real and
virtual files.</p>
<p>Users who wish to maintain their own data types and memory management
can also use the GMT modules, but some limitations and requirements do
apply: The user’s data can either be provided as (1) a 2-D matrix (of
any data type, e.g., float, integer, etc.) and in any memory layout
configuration (e.g., row-major or column-major layout) or as (2) a
set of column vectors that each may be of any type.  These custom arrays
will need to be hooked onto the GMT containers <a class="reference internal" href="#struct-matrix"><span class="std std-ref">GMT_MATRIX</span></a>
and <a class="reference internal" href="#struct-vector"><span class="std std-ref">GMT_VECTOR</span></a>, respectively.
Such objects can then be treated as virtual files for either input of output.</p>
</div>
<div class="section" id="our-audience">
<h2>1.3. Our audience<a class="headerlink" href="#our-audience" title="Permalink to this headline">¶</a></h2>
<p>Here, we document the new functions in the GMT API library for
application developers who wish to call these functions from their own
custom programs. At this point, only the new high-level GMT API is
fully documented and intended for public use. The structure and
documentation of the under-lying lower-level GMT library is not
finalized. Developers using these functions may risk disruption to their
programs due to changes we may make in the library in support of the
GMT API. However, developers who wish to make supplemental packages to
be distributed as part of GMT will (other than talk to us) probably
want to access the entire low-level GMT library as well. It is
unlikely that the low-level library will ever be fully documented.</p>
<p>There are two classes of development that users can pursue:</p>
<ol class="arabic simple">
<li>Building stand-alone custom executables that link with the shared GMT
API.  Our examples in this documentation are of this kind.  There programs
are likely to address a user’s special data formats or processing needs
by leveraging high-level GMT modules to do some of the heavy lifting.</li>
<li>Building shared library plugins to extend the breath of GMT.  Users who
wish to build one or more new modules and distributed then via a plugin
that is dynamically loaded at run-time can now do so.   At the present,
all the modules in the official GMT supplement are compiled into a single
plugin that can be accessed at run-time.  Similarly, developers may add
additional plugin libraries with any number of GMT-like modules and these
will then be available from the gmt command (as well as from derived
interfaces such as the GMT/MATLAB toolbox and the Python module).  An
example of plugin development is given by the
<a class="reference external" href="http://www.soest.hawaii.edu/PT/GSFML/">GSFML extension to GMT</a>.</li>
</ol>
</div>
<div class="section" id="definitions">
<h2>1.4. Definitions<a class="headerlink" href="#definitions" title="Permalink to this headline">¶</a></h2>
<p>For the purpose of this documentation a few definitions are needed:</p>
<ol class="arabic simple">
<li>“Standard GMT program” refers to one of the traditional stand-alone
command-line executables known to all GMT users, e.g.,
<a class="reference internal" href="blockmean.html"><span class="doc">blockmean</span></a>, <a class="reference internal" href="psxy.html"><span class="doc">psxy</span></a>,
<a class="reference internal" href="grdimage.html"><span class="doc">grdimage</span></a>, etc. Prior to version 5,
these were the only GMT executables available.  In GMT 5, these are
accessed via the <a class="reference internal" href="gmt.html"><span class="doc">gmt</span></a> executable.</li>
<li>“GMT module” refers to the function in the GMT API library that
is responsible for all the action taken by the corresponding
standard GMT program. All such modules are given the same names as the
corresponding programs e.g., “blockmean”, but are invoked via the
<code class="docutils literal notranslate"><span class="pre">GMT_Call_Module</span></code> function.</li>
<li>“GMT application” refers to a new application written by any
developer.  It uses the API, perhaps for custom i/o, and may call one
or more GMT functions to create a new GMT-compatible executable.</li>
<li>“GMT plugin library” refers to a collection of one or more new custom
GMT-like modules that are presented as a plugin library.  It such libraries
are placed in the official GMT plugin directory or their path is added to
the GMT defaults parameter GMT_CUSTOM_LIBS then the <a class="reference internal" href="gmt.html"><span class="doc">gmt</span></a> executable can find them.</li>
<li>“Family” refers to one of the many high-level GMT data types (e.g., grids, CPTs)
and is typically a required argument to some API functions.</li>
<li>“Method” refers to one of several ways in which data can be read or written
in the API, including from existing memory variables.</li>
<li>“Direction” is typically either GMT_IN (for reading) or GMT_OUT (for writing).</li>
<li>In the API description that follows we will use the type <code class="docutils literal notranslate"><span class="pre">int</span></code> to
mean a 4-byte integer. All integers used in the API are 4-byte
integers with the exception of one function where an 8-byte integer is
used. Since different operating systems have their own way of
defining 8-byte integers we use C99’s <code class="docutils literal notranslate"><span class="pre">int64_t</span></code> for this purpose;
it is guaranteed to yield the correct type that the GMT function
expects.</li>
</ol>
<p>In version 5, the standard GMT programs are themselves simple invocations
of the <a class="reference internal" href="gmt.html"><span class="doc">gmt</span></a> application with the function name as argument.
However, some of these modules, such as
<a class="reference internal" href="pslegend.html"><span class="doc">pslegend</span></a>, <a class="reference internal" href="gmtconvert.html"><span class="doc">gmtconvert</span></a>,
<a class="reference internal" href="grdblend.html"><span class="doc">grdblend</span></a>,
<a class="reference internal" href="grdfilter.html"><span class="doc">grdfilter</span></a> and others may call several additional modules.</p>
</div>
<div class="section" id="gmt-resources">
<h2>1.5. GMT resources<a class="headerlink" href="#gmt-resources" title="Permalink to this headline">¶</a></h2>
<p>The GMT API knows how to create, duplicate, read and write six types of data objects common to
GMT operations: Pure data tables (ASCII or binary), grids, images, color
palette tables (also known as CPT), PostScript documents, and text tables (ASCII,
usually a mix of data and free-form text).  In addition, we
provide two data objects to facilitate the passing of simple user arrays
(one or more equal-length data columns of any data type, e.g., double,
char) and 2-D or 3-D user matrices (of any data type and column/row
organization <a class="footnote-reference" href="#id9" id="id3">[3]</a>). We refer to these data types as GMT <em>resources</em>.
There are many attributes for each of these resources and therefore we
use a top-level structure for each object to keep them all within one
container. These containers are given or returned by GMT API
functions using opaque pointers (<code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span></code>). Below we provide a brief
overview of these containers, listing only the most critical members.
For complete details, see Appendix A.  We will later present how they are used when
importing or exporting them to or from files, memory locations, or
streams. The first six are the standard GMT objects, while the latter
two are special data containers to facilitate the passing of user
data in and out of GMT modules. These resources are defined in the include
file <code class="docutils literal notranslate"><span class="pre">gmt_resources.h</span></code>; please consult this file to ensure correctness
in case the documentation is not up-to-date.  Note than in all instances
the fundamental data variable is called “data”.</p>
<div class="section" id="data-tables">
<h3>1.5.1. Data tables<a class="headerlink" href="#data-tables" title="Permalink to this headline">¶</a></h3>
<p>Much data processed in GMT come in the form of ASCII, netCDF, or
native binary data tables. These may have any number of header records
(ASCII files only) and perhaps segment headers that separate groups of points
or lines and polygons. GMT programs will read
one or more such tables when importing data. However, to avoid memory
duplication or data limitations some programs may prefer to read such records one
at the time. The GMT API has functions that let you read your data
record-by-record by presenting a <em>virtual</em> data set that combines all the
data tables specified as input. This simplifies record processing
considerably.  Programs reading an entire data set will encounter several
structures: A data set (<code class="docutils literal notranslate"><span class="pre">struct</span></code> <a class="reference internal" href="#struct-dataset"><span class="std std-ref">GMT_DATASET</span></a>) may contain any number of
tables (<code class="docutils literal notranslate"><span class="pre">struct</span></code> <a class="reference internal" href="#struct-datatable"><span class="std std-ref">GMT_DATATABLE</span></a>), each with any number of segments
(<code class="docutils literal notranslate"><span class="pre">struct</span></code> <a class="reference internal" href="#struct-datasegment"><span class="std std-ref">GMT_DATASEGMENT</span></a>), each segment with any number of
records, and each record with any number of (fixed) columns. Thus, the arguments
to GMT API functions that handle such data sets expect a struct <a class="reference internal" href="#struct-dataset"><span class="std std-ref">GMT_DATASET</span></a>.
All segments are expected to have the same number of columns.</p>
<div class="highlight-c notranslate" id="struct-dataset2"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">GMT_DATASET</span> <span class="p">{</span> <span class="cm">/* Single container for an array of GMT tables (files) */</span>
    <span class="kt">uint64_t</span>  <span class="n">n_tables</span><span class="p">;</span>     <span class="cm">/* The total number of tables contained */</span>
    <span class="kt">uint64_t</span>  <span class="n">n_columns</span><span class="p">;</span>    <span class="cm">/* The number of data columns */</span>
    <span class="kt">uint64_t</span>  <span class="n">n_segments</span><span class="p">;</span>   <span class="cm">/* The total number of segments across all tables */</span>
    <span class="kt">uint64_t</span>  <span class="n">n_records</span><span class="p">;</span>    <span class="cm">/* The total number of data records across all tables */</span>
    <span class="kt">double</span>   <span class="o">*</span><span class="n">min</span><span class="p">;</span>         <span class="cm">/* Minimum coordinate for each column */</span>
    <span class="kt">double</span>   <span class="o">*</span><span class="n">max</span><span class="p">;</span>         <span class="cm">/* Maximum coordinate for each column */</span>
    <span class="k">struct</span> <span class="n">GMT_DATATABLE</span> <span class="o">**</span><span class="n">table</span><span class="p">;</span>    <span class="cm">/* Pointer to array of tables */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The top-level dataset structure for pure data tables contains the table structure, as defined below:</p>
<div class="highlight-c notranslate" id="struct-datatable2"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">GMT_DATATABLE</span> <span class="p">{</span>  <span class="cm">/* Single container for an array of data segments */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n_headers</span><span class="p">;</span>    <span class="cm">/* Number of table header records (0 if no header) */</span>
    <span class="kt">uint64_t</span>     <span class="n">n_columns</span><span class="p">;</span>    <span class="cm">/* Number of columns (fields) in each record */</span>
    <span class="kt">uint64_t</span>     <span class="n">n_segments</span><span class="p">;</span>   <span class="cm">/* Number of segments in the array */</span>
    <span class="kt">uint64_t</span>     <span class="n">n_records</span><span class="p">;</span>    <span class="cm">/* Total number of data records across all segments */</span>
    <span class="kt">double</span>      <span class="o">*</span><span class="n">min</span><span class="p">;</span>          <span class="cm">/* Minimum coordinate for each column */</span>
    <span class="kt">double</span>      <span class="o">*</span><span class="n">max</span><span class="p">;</span>          <span class="cm">/* Maximum coordinate for each column */</span>
    <span class="kt">char</span>       <span class="o">**</span><span class="n">header</span><span class="p">;</span>       <span class="cm">/* Array with all table header records, if any) */</span>
    <span class="k">struct</span> <span class="n">GMT_DATASEGMENT</span> <span class="o">**</span><span class="n">segment</span><span class="p">;</span> <span class="cm">/* Pointer to array of segments */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Finally, the table structure depends on a structure for individual data segments:</p>
<div class="highlight-c notranslate" id="struct-datasegment2"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">GMT_DATASEGMENT</span> <span class="p">{</span>       <span class="cm">/* For holding segment lines in memory */</span>
    <span class="kt">uint64_t</span> <span class="n">n_rows</span><span class="p">;</span>           <span class="cm">/* Number of points in this segment */</span>
    <span class="kt">uint64_t</span> <span class="n">n_columns</span><span class="p">;</span>        <span class="cm">/* Number of fields in each record (&gt;= 2) */</span>
    <span class="kt">double</span>  <span class="o">*</span><span class="n">min</span><span class="p">;</span>              <span class="cm">/* Minimum coordinate for each column */</span>
    <span class="kt">double</span>  <span class="o">*</span><span class="n">max</span><span class="p">;</span>              <span class="cm">/* Maximum coordinate for each column */</span>
    <span class="kt">double</span> <span class="o">**</span><span class="n">data</span><span class="p">;</span>             <span class="cm">/* Data x,y, and possibly other columns */</span>
    <span class="kt">char</span>    <span class="o">*</span><span class="n">label</span><span class="p">;</span>            <span class="cm">/* Label string (if applicable) */</span>
    <span class="kt">char</span>    <span class="o">*</span><span class="n">header</span><span class="p">;</span>           <span class="cm">/* Segment header (if applicable) */</span>
 <span class="p">;</span>
</pre></div>
</div>
<p>Data sets may have different geometries, such as representing a set of points,
one or more lines, or closed polygons.</p>
</div>
<div class="section" id="gmt-grids">
<h3>1.5.2. GMT grids<a class="headerlink" href="#gmt-grids" title="Permalink to this headline">¶</a></h3>
<p>GMT grids are used to represent equidistant and organized 2-D
surfaces. These can be processed or plotted as contour maps, color images, or
perspective surfaces. Because the native GMT grid is simply a 1-D
float array with metadata kept in a separate <code class="docutils literal notranslate"><span class="pre">struct</span></code> <a class="reference internal" href="#struct-gridheader"><span class="std std-ref">GMT_GRID_HEADER</span></a> header, we pass
this information via a <code class="docutils literal notranslate"><span class="pre">struct</span></code> <a class="reference internal" href="#struct-grid"><span class="std std-ref">GMT_GRID</span></a>, which is a container that
holds both items. Thus, the arguments to GMT API functions that handle
GMT grids expect this type of variable.</p>
<div class="highlight-c notranslate" id="struct-grid2"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">GMT_GRID</span> <span class="p">{</span>                        <span class="cm">/* A GMT float grid and header in one container */</span>
    <span class="k">struct</span> <span class="n">GMT_GRID_HEADER</span> <span class="o">*</span><span class="n">header</span><span class="p">;</span>      <span class="cm">/* The full GMT header for the grid */</span>
    <span class="kt">float</span>                  <span class="o">*</span><span class="n">data</span><span class="p">;</span>        <span class="cm">/* Pointer to the float grid array */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The top-level grid structure, holding both header and data array, depends on the grid header structure:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">GMT_GRID_HEADER</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">n_columns</span><span class="p">;</span>                     <span class="cm">/* Number of columns */</span>
    <span class="kt">uint32_t</span> <span class="n">n_rows</span><span class="p">;</span>                        <span class="cm">/* Number of rows */</span>
    <span class="kt">uint32_t</span> <span class="n">registration</span><span class="p">;</span>                  <span class="cm">/* GMT_GRID_NODE_REG (0) for node grids,</span>
<span class="cm">                                               GMT_GRID_PIXEL_REG (1) for pixel grids */</span>
    <span class="kt">double</span> <span class="n">wesn</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>                         <span class="cm">/* Min/max x and y coordinates */</span>
    <span class="kt">double</span> <span class="n">z_min</span><span class="p">;</span>                           <span class="cm">/* Minimum z value */</span>
    <span class="kt">double</span> <span class="n">z_max</span><span class="p">;</span>                           <span class="cm">/* Maximum z value */</span>
    <span class="kt">double</span> <span class="n">inc</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>                          <span class="cm">/* The x and y increments */</span>
    <span class="kt">double</span> <span class="n">z_scale_factor</span><span class="p">;</span>                  <span class="cm">/* Grid values must be multiplied by this factor */</span>
    <span class="kt">double</span> <span class="n">z_add_offset</span><span class="p">;</span>                    <span class="cm">/* After scaling, add this */</span>
    <span class="kt">char</span>   <span class="n">x_units</span><span class="p">[</span><span class="n">GMT_GRID_UNIT_LEN80</span><span class="p">];</span>    <span class="cm">/* Units in x-direction */</span>
    <span class="kt">char</span>   <span class="n">y_units</span><span class="p">[</span><span class="n">GMT_GRID_UNIT_LEN80</span><span class="p">];</span>    <span class="cm">/* Units in y-direction */</span>
    <span class="kt">char</span>   <span class="n">z_units</span><span class="p">[</span><span class="n">GMT_GRID_UNIT_LEN80</span><span class="p">];</span>    <span class="cm">/* Grid value units */</span>
    <span class="kt">char</span>   <span class="n">title</span><span class="p">[</span><span class="n">GMT_GRID_TITLE_LEN80</span><span class="p">];</span>     <span class="cm">/* Name of data set */</span>
    <span class="kt">char</span>   <span class="n">command</span><span class="p">[</span><span class="n">GMT_GRID_COMMAND_LEN320</span><span class="p">];</span><span class="cm">/* Name of generating command */</span>
    <span class="kt">char</span>   <span class="n">remark</span><span class="p">[</span><span class="n">GMT_GRID_REMARK_LEN160</span><span class="p">];</span>  <span class="cm">/* Comments regarding this data set */</span>
<span class="p">};</span>

<span class="n">The</span> <span class="n">basic</span> <span class="n">grid</span> <span class="n">header</span> <span class="n">holds</span> <span class="n">the</span> <span class="n">metadata</span> <span class="n">written</span> <span class="n">to</span> <span class="n">grid</span> <span class="n">files</span><span class="p">.</span>
</pre></div>
</div>
</div>
<div class="section" id="gmt-images">
<h3>1.5.3. GMT images<a class="headerlink" href="#gmt-images" title="Permalink to this headline">¶</a></h3>
<p>GMT images are used to represent bit-mapped images typically obtained
via the GDAL bridge. These can be reprojected internally, such as when
used in <a class="reference internal" href="grdimage.html"><span class="doc">grdimage</span></a>. Since images and grids share the concept of a header,
we use the same header structure for grids as for images; however, some
additional metadata attributes are also needed. Finally, the image
itself may be of any data type and have more than one band (channel).
Both image and header information are passed via a <code class="docutils literal notranslate"><span class="pre">struct</span></code> <a class="reference internal" href="#struct-image"><span class="std std-ref">GMT_IMAGE</span></a>,
which is a container that holds both items. Thus, the arguments to
GMT API functions that handle GMT images expect this type of
variable. Unlike the other objects, writing images has only partial
support via <a class="reference internal" href="grdimage.html"><span class="doc">grdimage</span></a> <a class="footnote-reference" href="#id10" id="id4">[4]</a>.
For the full definition, see <a class="reference internal" href="#struct-image"><span class="std std-ref">GMT_IMAGE</span></a>.</p>
<div class="highlight-c notranslate" id="struct-image2"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">GMT_IMAGE</span> <span class="p">{</span>     <span class="cm">/* A GMT char image, header, and colormap in one container */</span>
    <span class="k">enum</span> <span class="n">GMT_enum_type</span>      <span class="n">type</span><span class="p">;</span>             <span class="cm">/* Data type, e.g. GMT_FLOAT */</span>
    <span class="kt">int</span>                    <span class="o">*</span><span class="n">colormap</span><span class="p">;</span>         <span class="cm">/* Array with color lookup values */</span>
    <span class="kt">int</span>                     <span class="n">n_indexed_colors</span><span class="p">;</span> <span class="cm">/* Number of colors in a color-mapped image */</span>
    <span class="k">struct</span> <span class="n">GMT_GRID_HEADER</span> <span class="o">*</span><span class="n">header</span><span class="p">;</span>           <span class="cm">/* Pointer to full GMT header for the image */</span>
    <span class="kt">unsigned</span> <span class="kt">char</span>          <span class="o">*</span><span class="n">data</span><span class="p">;</span>             <span class="cm">/* Pointer to actual image */</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="color-palette-tables-cpt">
<h3>1.5.4. Color palette tables (CPT)<a class="headerlink" href="#color-palette-tables-cpt" title="Permalink to this headline">¶</a></h3>
<p>The color palette table files, or just CPTs, contain colors and
patterns used for plotting data such as surfaces (i.e., GMT grids) or
symbols, lines and polygons (i.e., GMT tables). GMT programs will
generally read in a color palette table, make it the current palette, do
the plotting, and destroy the table when done. The information is
accessed via a pointer to <code class="docutils literal notranslate"><span class="pre">struct</span></code> <a class="reference internal" href="#struct-palette"><span class="std std-ref">GMT_PALETTE</span></a>. Thus, the arguments
to GMT API functions that handle palettes expect this type of
variable. It is not expected that users will wish to manipulate the CPT
directly, but rather use this mechanism to hold them in memory and
pass as arguments to GMT modules.  Developers are unlikely to actually
manipulate the contents of CPT structures but if needed then
the full definition can be found in <a class="reference internal" href="#struct-palette"><span class="std std-ref">GMT_PALETTE</span></a>.</p>
<div class="highlight-c notranslate" id="struct-palette2"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">GMT_PALETTE</span> <span class="p">{</span> <span class="cm">/* Holds color-related parameters for look-up */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>          <span class="n">n_headers</span><span class="p">;</span>     <span class="cm">/* Number of CPT header records (0 if no header) */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>          <span class="n">n_colors</span><span class="p">;</span>      <span class="cm">/* Number of colors in the data array */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>          <span class="n">mode</span><span class="p">;</span>          <span class="cm">/* Flags controlling use of BFN colors */</span>
    <span class="k">struct</span> <span class="n">GMT_LUT</span>       <span class="o">*</span><span class="n">data</span><span class="p">;</span>          <span class="cm">/* CPT lookup data with color information */</span>
    <span class="k">struct</span> <span class="n">GMT_BFN</span>        <span class="n">bfn</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>        <span class="cm">/* Structures with back/fore/nan fills */</span>
    <span class="kt">char</span>                <span class="o">**</span><span class="n">header</span><span class="p">;</span>        <span class="cm">/* Array with all CPT header records, if any) */</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="postscript-document">
<h3>1.5.5. PostScript document<a class="headerlink" href="#postscript-document" title="Permalink to this headline">¶</a></h3>
<p>Normally, GMT modules producing PostScript will write to standard output
or a designated file.  Alternatively, you can tell the API to write to a
memory buffer instead and then receive a structure with the final
plot (or partial plot) represented as a long text string.
The full structure definition can be found in <a class="reference internal" href="#struct-postscript"><span class="std std-ref">GMT_POSTSCRIPT</span></a>.</p>
<div class="highlight-c notranslate" id="struct-postscript2"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">GMT_POSTSCRIPT</span> <span class="p">{</span>      <span class="cm">/* Single container for a chunk of PostScript text */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n_headers</span><span class="p">;</span>          <span class="cm">/* Number of PostScript header records (0 if no header) */</span>
    <span class="kt">size_t</span> <span class="n">n_alloc</span><span class="p">;</span>                  <span class="cm">/* Size of array allocated so far */</span>
    <span class="kt">size_t</span> <span class="n">n_bytes</span><span class="p">;</span>                  <span class="cm">/* Length of data array so far */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">;</span>               <span class="cm">/* Bit-flag for header (1) and trailer (2) */</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>                      <span class="cm">/* Pointer to actual PostScript text */</span>
    <span class="kt">char</span> <span class="o">**</span><span class="n">header</span><span class="p">;</span>                   <span class="cm">/* Array with all PostScript header records, if any) */</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="text-tables">
<h3>1.5.6. Text tables<a class="headerlink" href="#text-tables" title="Permalink to this headline">¶</a></h3>
<p>Some data needed by GMT are simply free-form ASCII text tables. In many respects these
are handled similarly to data tables. E.g., they may have any number of
header records and even segment headers, and GMT programs can read one
or more tables or get text records one at the time. A
<code class="docutils literal notranslate"><span class="pre">struct</span></code> <a class="reference internal" href="#struct-textset"><span class="std std-ref">GMT_TEXTSET</span></a> may contain any number of <code class="docutils literal notranslate"><span class="pre">struct</span></code> <a class="reference internal" href="#struct-texttable"><span class="std std-ref">GMT_TEXTTABLE</span></a>, each with any
number of <code class="docutils literal notranslate"><span class="pre">struct</span></code> <a class="reference internal" href="#struct-textsegment"><span class="std std-ref">GMT_TEXTSEGMENT</span></a>, and each segment with any number of text records. Thus,
the arguments to GMT API functions that handle such data sets expect
this type of variable. The user’s program may then parse and process
such text records as required. This resources is particularly useful
when your data consist of a mix or data coordinates and ordinary text
since regular data tables will be parsed for floating-point columns
only.  For the full definition, see <a class="reference internal" href="#struct-textset"><span class="std std-ref">GMT_TEXTSET</span></a>.</p>
<div class="highlight-c notranslate" id="struct-textset2"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">GMT_TEXTSET</span> <span class="p">{</span> <span class="cm">/* Single container for an array of GMT text tables (files) */</span>
    <span class="kt">uint64_t</span>               <span class="n">n_tables</span><span class="p">;</span>     <span class="cm">/* The total number of tables in the set */</span>
    <span class="kt">uint64_t</span>               <span class="n">n_segments</span><span class="p">;</span>   <span class="cm">/* The total number of segments in the set */</span>
    <span class="kt">uint64_t</span>               <span class="n">n_records</span><span class="p">;</span>    <span class="cm">/* The total number of data records in the set */</span>
    <span class="k">struct</span> <span class="n">GMT_TEXTTABLE</span> <span class="o">**</span><span class="n">table</span><span class="p">;</span>        <span class="cm">/* Pointer to array of tables */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The top-level structure for mixed data/text data sets depends on the text table structure:</p>
<div class="highlight-c notranslate" id="struct-texttable2"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">GMT_TEXTTABLE</span> <span class="p">{</span>  <span class="cm">/* Single container for an array of text segments */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n_headers</span><span class="p">;</span>   <span class="cm">/* Number of table header records (0 if no header) */</span>
    <span class="kt">uint64_t</span> <span class="n">n_segments</span><span class="p">;</span>      <span class="cm">/* Number of segments in the table */</span>
    <span class="kt">uint64_t</span> <span class="n">n_records</span><span class="p">;</span>       <span class="cm">/* Total number of data records in the table */</span>
    <span class="kt">char</span>   <span class="o">**</span><span class="n">header</span><span class="p">;</span>          <span class="cm">/* Array with all table header records, if any) */</span>
    <span class="k">struct</span> <span class="n">GMT_TEXTSEGMENT</span> <span class="o">**</span><span class="n">segment</span><span class="p">;</span> <span class="cm">/* Pointer to array of segments */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Finally, the text table structure depends on the structure for text segments:</p>
<div class="highlight-c notranslate" id="struct-textsegment2"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">GMT_TEXTSEGMENT</span> <span class="p">{</span>      <span class="cm">/* For holding segment text records in memory */</span>
    <span class="kt">uint64_t</span> <span class="n">n_rows</span><span class="p">;</span>          <span class="cm">/* Number of rows in this segment */</span>
    <span class="kt">char</span>   <span class="o">**</span><span class="n">data</span><span class="p">;</span>            <span class="cm">/* Array of text records */</span>
    <span class="kt">char</span>    <span class="o">*</span><span class="n">label</span><span class="p">;</span>           <span class="cm">/* Label string (if applicable) */</span>
    <span class="kt">char</span>    <span class="o">*</span><span class="n">header</span><span class="p">;</span>          <span class="cm">/* Segment header (if applicable) */</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="user-data-matrices">
<h3>1.5.7. User data matrices<a class="headerlink" href="#user-data-matrices" title="Permalink to this headline">¶</a></h3>
<p>Users may write programs that need to call GMT modules but may keep their data in separate
2-D arrays that the allocate and maintain independent of GMT.
For instance, a program may have built an integer 2-D matrix in memory and wish to
use that as the input grid to the <code class="docutils literal notranslate"><span class="pre">grdfilter</span></code> module, which
normally expects a <code class="docutils literal notranslate"><span class="pre">struct</span></code> <a class="reference internal" href="#struct-grid"><span class="std std-ref">GMT_GRID</span></a> with floating point data via an actual or virtual
file. To handle this case we create a <code class="docutils literal notranslate"><span class="pre">struct</span></code> <a class="reference internal" href="#struct-matrix"><span class="std std-ref">GMT_MATRIX</span></a> container (see <a class="reference internal" href="#sec-create"><span class="std std-ref">Create empty resources</span></a>),
assign the appropriate union pointer to your data matrix and provide information on dimensions
and data type. We then open this container as a virtual file and pass its filename to any module.
The full structure definition can be found in <a class="reference internal" href="#struct-matrix"><span class="std std-ref">GMT_MATRIX</span></a>.</p>
<div class="highlight-c notranslate" id="struct-matrix2"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">GMT_MATRIX</span> <span class="p">{</span>  <span class="cm">/* Single container to hold a user matrix */</span>
   <span class="kt">uint64_t</span>             <span class="n">n_rows</span><span class="p">;</span>        <span class="cm">/* Number of rows in the matrix */</span>
   <span class="kt">uint64_t</span>             <span class="n">n_columns</span><span class="p">;</span>     <span class="cm">/* Number of columns in the matrix */</span>
   <span class="kt">uint64_t</span>             <span class="n">n_layers</span><span class="p">;</span>      <span class="cm">/* Number of layers in a 3-D matrix */</span>
   <span class="k">enum</span> <span class="n">GMT_enum_fmt</span>    <span class="n">shape</span><span class="p">;</span>         <span class="cm">/* 0 = C (rows) and 1 = Fortran (cols) */</span>
   <span class="k">enum</span> <span class="n">GMT_enum_reg</span>    <span class="n">registration</span><span class="p">;</span>  <span class="cm">/* 0 for gridline and 1 for pixel registration  */</span>
   <span class="kt">size_t</span>               <span class="n">dim</span><span class="p">;</span>           <span class="cm">/* Allocated length of longest C or Fortran dim */</span>
   <span class="kt">size_t</span>               <span class="n">size</span><span class="p">;</span>          <span class="cm">/* Byte length of data */</span>
   <span class="k">enum</span> <span class="n">GMT_enum_type</span>   <span class="n">type</span><span class="p">;</span>          <span class="cm">/* Data type, e.g. GMT_FLOAT */</span>
   <span class="kt">double</span>               <span class="n">range</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>      <span class="cm">/* Contains xmin/xmax/ymin/ymax[/zmin/zmax] */</span>
   <span class="k">union</span> <span class="n">GMT_UNIVECTOR</span>  <span class="n">data</span><span class="p">;</span>          <span class="cm">/* Pointer to actual matrix of the chosen type */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">enum</span></code> types referenced in <a class="reference internal" href="#struct-vector"><span class="std std-ref">GMT_VECTOR</span></a> and
Table <a class="reference internal" href="#struct-matrix"><span class="std std-ref">GMT_MATRIX</span></a> and summarized in Table <a class="reference internal" href="#tbl-types"><span class="std std-ref">types</span></a>.</p>
</div>
<div class="section" id="user-data-columns">
<h3>1.5.8. User data columns<a class="headerlink" href="#user-data-columns" title="Permalink to this headline">¶</a></h3>
<p>Likewise, programs may instead be manipulating a set of custom column vectors.
For instance, the user’s program may have allocated and populated
three column arrays of type float and wishes to use these as the input
source to the <code class="docutils literal notranslate"><span class="pre">surface</span></code> module, which normally expects double
precision triplets via a <code class="docutils literal notranslate"><span class="pre">struct</span></code> <a class="reference internal" href="#struct-dataset"><span class="std std-ref">GMT_DATASET</span></a> read from an actual or virtual file
Simply create a new <a class="reference internal" href="#struct-vector"><span class="std std-ref">GMT_VECTOR</span></a> container
(see section <a class="reference internal" href="#sec-create"><span class="std std-ref">Create empty resources</span></a>) and assign the union array pointers (see
<a class="reference internal" href="#struct-univector"><span class="std std-ref">univector</span></a>) to your data columns and provide the required
information on length, data types, and optionally range. Again, once we open this data
as a virtual file we can pass its filename to any module expecting such data.
The full structure definition can be found in <a class="reference internal" href="#struct-vector"><span class="std std-ref">GMT_VECTOR</span></a>.</p>
<div class="highlight-c notranslate" id="struct-vector2"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">GMT_VECTOR</span> <span class="p">{</span>   <span class="cm">/* Single container to hold user vectors */</span>
    <span class="kt">uint64_t</span>             <span class="n">n_columns</span><span class="p">;</span>     <span class="cm">/* Number of vectors */</span>
    <span class="kt">uint64_t</span>             <span class="n">n_rows</span><span class="p">;</span>        <span class="cm">/* Number of rows in each vector */</span>
    <span class="k">enum</span> <span class="n">GMT_enum_reg</span>    <span class="n">registration</span><span class="p">;</span>  <span class="cm">/* 0 for gridline and 1 for pixel registration */</span>
    <span class="k">enum</span> <span class="n">GMT_enum_type</span>  <span class="o">*</span><span class="n">type</span><span class="p">;</span>          <span class="cm">/* Array with data type for each vector */</span>
    <span class="k">union</span> <span class="n">GMT_UNIVECTOR</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>          <span class="cm">/* Array with unions for each column */</span>
    <span class="kt">double</span>               <span class="n">range</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>      <span class="cm">/* The min and max limits on t-range (or 0,0) */</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="overview-of-the-gmt-c-application-program-interface">
<span id="chapter-overview"></span><h1>2. Overview of the GMT C Application Program Interface<a class="headerlink" href="#overview-of-the-gmt-c-application-program-interface" title="Permalink to this headline">¶</a></h1>
<p>Users who wish to create their own GMT application based on the API
must make sure their program goes through the steps below. The details for
each step will be revealed in the following chapter. We have kept the
API simple: In addition to the GMT modules, there are only 57 public
functions to become familiar with, but most applications will only use a
very small subset of this selection. Functions either return an integer error
code (when things go wrong; otherwise it is set to <code class="docutils literal notranslate"><span class="pre">GMT_NOERROR</span> <span class="pre">(0)</span></code>), or they
return a void pointer to a GMT resource (or NULL if things go wrong).
In either case, the API will report what the error is. The layout here
assumes you wish to use virtual files as input sources (i.e., data you already
have in memory); if the data must be
read from actual data files then things simplify considerably.</p>
<p>To keep things as simple as possible we will assume you are writing an
application that will read in table data, call a module using the data in
memory as input, and then save the output from the module back into
another memory location.  No actual processing of the data or further
calculation will be done here (so a bit of a boring program, but the
point is to develop something short we can test).  Also, to keep the code
short we completely ignore
the return codes of the modules for now.  We will call our program
<a class="reference internal" href="#example-code1"><span class="std std-ref">example1.c</span></a>.  Here are the steps:</p>
<ol class="arabic simple">
<li>Initialize a new GMT session with <a class="reference internal" href="#gmt-create-session">GMT_Create_Session</a>, which
allocates a hidden GMT API control structure and returns an opaque
pointer to it. This pointer is a <em>required</em> argument to all subsequent
GMT API function calls within the session.</li>
<li>Read a data set (or grid, etc.) into memory with <a class="reference internal" href="#gmt-read-data">GMT_Read_Data</a>,
which, depending on data type, returns one of the data structures
discussed earlier.</li>
<li>Associate your data with a virtual file using <a class="reference internal" href="#gmt-open-virtualfile">GMT_Open_VirtualFile</a>.
This steps returns a special filename that you can use to tell a module where
to read its input.  No actual file is created.</li>
<li>Open a new virtual file to hold the output using <a class="reference internal" href="#gmt-open-virtualfile">GMT_Open_VirtualFile</a>.
This step also returns a special filename for the module to send its output.</li>
<li>Prepare required arguments (including the two virtual file names) and
call the GMT module you wish to use via GMT_Call_Module.</li>
<li>Obtain the desired output object via <a class="reference internal" href="#gmt-read-virtualfile">GMT_Read_VirtualFile</a>, which
returns a data structure of requested type.</li>
<li>Close the virtual files you have been using with <a class="reference internal" href="#gmt-close-virtualfile">GMT_Close_VirtualFile</a>.</li>
<li>We terminate the GMT session by calling <a class="reference internal" href="#gmt-destroy-session">GMT_Destroy_Session</a>.</li>
</ol>
<div class="section" id="example-code">
<h2>2.1. Example code<a class="headerlink" href="#example-code" title="Permalink to this headline">¶</a></h2>
<p>For the example code to run, make sure the data table “table_5.11” from gallery
example 14 is placed in the current directory, then compile and run
this program:</p>
<div class="highlight-c notranslate" id="example-code1"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;gmt.h&quot;</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">;</span>                        <span class="cm">/* The API control structure */</span>
    <span class="k">struct</span> <span class="n">GMT_DATASET</span> <span class="o">*</span><span class="n">D</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>     <span class="cm">/* Structure to hold input dataset */</span>
    <span class="k">struct</span> <span class="n">GMT_GRID</span> <span class="o">*</span><span class="n">G</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>        <span class="cm">/* Structure to hold output grid */</span>
    <span class="kt">char</span> <span class="n">input</span><span class="p">[</span><span class="n">GMT_STR16</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;&quot;</span><span class="p">};</span>     <span class="cm">/* String to hold virtual input filename */</span>
    <span class="kt">char</span> <span class="n">output</span><span class="p">[</span><span class="n">GMT_STR16</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;&quot;</span><span class="p">};</span>    <span class="cm">/* String to hold virtual output filename */</span>
    <span class="kt">char</span> <span class="n">args</span><span class="p">[</span><span class="mi">128</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;&quot;</span><span class="p">};</span>            <span class="cm">/* String to hold module command arguments */</span>

    <span class="cm">/* Initialize the GMT session */</span>
    <span class="n">API</span> <span class="o">=</span> <span class="n">GMT_Create_Session</span> <span class="p">(</span><span class="s">&quot;test&quot;</span><span class="p">,</span> <span class="mi">2U</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="cm">/* Read in our data table to memory */</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">GMT_Read_Data</span> <span class="p">(</span><span class="n">API</span><span class="p">,</span> <span class="n">GMT_IS_DATASET</span><span class="p">,</span> <span class="n">GMT_IS_FILE</span><span class="p">,</span> <span class="n">GMT_IS_PLP</span><span class="p">,</span> <span class="n">GMT_READ_NORMAL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
        <span class="s">&quot;table_5.11&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="cm">/* Associate our data table with a virtual file */</span>
    <span class="n">GMT_Open_VirtualFile</span> <span class="p">(</span><span class="n">API</span><span class="p">,</span> <span class="n">GMT_IS_DATASET</span><span class="p">,</span> <span class="n">GMT_IS_PLP</span><span class="p">,</span> <span class="n">GMT_IN</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">input</span><span class="p">);</span>
    <span class="cm">/* Create a virtual file to hold the resulting grid */</span>
    <span class="n">GMT_Open_VirtualFile</span> <span class="p">(</span><span class="n">API</span><span class="p">,</span> <span class="n">GMT_IS_GRID</span><span class="p">,</span> <span class="n">GMT_IS_SURFACE</span><span class="p">,</span> <span class="n">GMT_OUT</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">output</span><span class="p">);</span>
    <span class="cm">/* Prepare the module arguments */</span>
    <span class="n">sprintf</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="s">&quot;-R0/7/0/7 -I0.2 -D1 -St0.3 %s -G%s&quot;</span><span class="p">,</span> <span class="n">input</span><span class="p">,</span> <span class="n">output</span><span class="p">);</span>
    <span class="cm">/* Call the greenspline module */</span>
    <span class="n">GMT_Call_Module</span> <span class="p">(</span><span class="n">API</span><span class="p">,</span> <span class="s">&quot;greenspline&quot;</span><span class="p">,</span> <span class="n">GMT_MODULE_CMD</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
    <span class="cm">/* Obtain the grid from the virtual file */</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">GMT_Read_VirtualFile</span> <span class="p">(</span><span class="n">API</span><span class="p">,</span> <span class="n">output</span><span class="p">);</span>
    <span class="cm">/* Close the virtual files */</span>
    <span class="n">GMT_Close_VirtualFile</span> <span class="p">(</span><span class="n">API</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">input</span><span class="p">);</span>
    <span class="n">GMT_Close_VirtualFile</span> <span class="p">(</span><span class="n">API</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">output</span><span class="p">);</span>
    <span class="cm">/* Write the grid to file */</span>
    <span class="n">GMT_Write_Data</span> <span class="p">(</span><span class="n">API</span><span class="p">,</span> <span class="n">GMT_IS_GRID</span><span class="p">,</span> <span class="n">GMT_IS_FILE</span><span class="p">,</span> <span class="n">GMT_IS_SURFACE</span><span class="p">,</span> <span class="n">GMT_READ_NORMAL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
        <span class="s">&quot;junk.nc&quot;</span><span class="p">,</span> <span class="n">G</span><span class="p">);</span>
    <span class="cm">/* Destroy the GMT session */</span>
    <span class="n">GMT_Destroy_Session</span> <span class="p">(</span><span class="n">API</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="compilation">
<h2>2.2. Compilation<a class="headerlink" href="#compilation" title="Permalink to this headline">¶</a></h2>
<p>To compile this program (we assume it is called example1.c), we use the
gmt-config script to determine the correct compile and link flags and then run
gcc:</p>
<div class="highlight-bash notranslate" id="example-comp"><div class="highlight"><pre><span></span><span class="nv">inc</span><span class="o">=</span><span class="sb">`</span>gmt-config --cflags<span class="sb">`</span>
<span class="nv">lib</span><span class="o">=</span><span class="sb">`</span>gmt-config --libs<span class="sb">`</span>
gcc example1.c <span class="nv">$inc</span> <span class="nv">$lib</span> -o example1
./example1
</pre></div>
</div>
<p>This obviously assumes you have already installed GMT and that it is in your path.
If you run example1 it will take a moment (this is mostly due to the gridding
performed by <a class="reference internal" href="greenspline.html"><span class="doc">greenspline</span></a>) and then it stops.  You should find the resulting
grid junk.nc in the current directory.  Plot it to see if it makes sense, e.g.</p>
<div class="highlight-bash notranslate" id="example-view"><div class="highlight"><pre><span></span>gmt grdimage junk.nc &gt; junk.ps
</pre></div>
</div>
<p>If you intend to write applications that take any number of data files
via the command line then there will be more book-keeping to deal with,
and we will discuss those steps later.
Likewise, if you need to process a file record-by-record then more lines
of code will be required.</p>
</div>
<div class="section" id="plugins">
<h2>2.3. Plugins<a class="headerlink" href="#plugins" title="Permalink to this headline">¶</a></h2>
<p>Developers who wish to make custom plugin libraries that are compatible
with GMT should examine the fully functioning examples of more involved
code, available from the repository gmt-custom, obtainable via</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>svn checkout svn://gmtserver.soest.hawaii.edu/gmt-custom/trunk gmt-custom
</pre></div>
</div>
</div>
<div class="section" id="list-of-api-functions">
<h2>2.4. List of API functions<a class="headerlink" href="#list-of-api-functions" title="Permalink to this headline">¶</a></h2>
<p>The following is an alphabetical listing of all the public API functions in GMT. Click on
any of them to see the full syntax of each function.</p>
<p>The C/C++ API is deliberately kept small to make it easy to use.</p>
<blockquote id="tbl-api">
<div><table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">constant</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#gmt-alloc-segment">GMT_Alloc_Segment</a></td>
<td>Allocate data and text segments</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#gmt-append-option">GMT_Append_Option</a></td>
<td>Append new option structure to linked list</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#gmt-begin-io">GMT_Begin_IO</a></td>
<td>Enable record-by-record i/o</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#gmt-call-module">GMT_Call_Module</a></td>
<td>Call any of the GMT modules</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#gmt-convert-data">GMT_Convert_Data</a></td>
<td>Convert between compatible data types</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#gmt-close-virtualfile">GMT_Close_VirtualFile</a></td>
<td>Close a virtual file</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#gmt-create-args">GMT_Create_Args</a></td>
<td>Convert linked list of options to text array</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#gmt-create-cmd">GMT_Create_Cmd</a></td>
<td>Convert linked list of options to command line</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#gmt-create-data">GMT_Create_Data</a></td>
<td>Create an empty data resource</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#gmt-create-options">GMT_Create_Options</a></td>
<td>Convert command line options to linked list</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#gmt-create-session">GMT_Create_Session</a></td>
<td>Initialize a new GMT session</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#gmt-delete-option">GMT_Delete_Option</a></td>
<td>Delete an option structure from the linked list</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#gmt-destroy-args">GMT_Destroy_Args</a></td>
<td>Delete text array of arguments</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#gmt-destroy-cmd">GMT_Destroy_Cmd</a></td>
<td>Delete text command of arguments</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#gmt-destroy-data">GMT_Destroy_Data</a></td>
<td>Delete a data resource</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#gmt-destroy-group">GMT_Destroy_Group</a></td>
<td>Delete a group of data resources</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#gmt-destroy-options">GMT_Destroy_Options</a></td>
<td>Delete the linked list of option structures</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#gmt-destroy-session">GMT_Destroy_Session</a></td>
<td>Terminate a GMT session</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#gmt-duplicate-data">GMT_Duplicate_Data</a></td>
<td>Make an identical copy of a data resources</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#gmt-encode-options">GMT_Encode_Options</a></td>
<td>Encode option arguments for external interfaces</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#gmt-expand-option">GMT_Expand_Option</a></td>
<td>Expand option with explicit memory references</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#gmt-end-io">GMT_End_IO</a></td>
<td>Disable further record-by-record i/o</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#gmt-fft">GMT_FFT</a></td>
<td>Take the Fast Fourier Transform of data object</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#gmt-fft-1d">GMT_FFT_1D</a></td>
<td>Take the Fast Fourier Transform of 1-D float data</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#gmt-fft-2d">GMT_FFT_2D</a></td>
<td>Take the Fast Fourier Transform of 2-D float data</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#gmt-fft-create">GMT_FFT_Create</a></td>
<td>Initialize the FFT machinery</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#gmt-fft-destroy">GMT_FFT_Destroy</a></td>
<td>Terminate the FFT machinery</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#gmt-fft-option">GMT_FFT_Option</a></td>
<td>Explain the FFT options and modifiers</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#gmt-fft-parse">GMT_FFT_Parse</a></td>
<td>Parse argument with FFT options and modifiers</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#gmt-fft-wavenumber">GMT_FFT_Wavenumber</a></td>
<td>Return wavenumber given data index</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#gmt-find-option">GMT_Find_Option</a></td>
<td>Find an option in the linked list</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#gmt-get-common">GMT_Get_Common</a></td>
<td>Determine if a GMT common option was set</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#gmt-get-coord">GMT_Get_Coord</a></td>
<td>Create a coordinate array</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#gmt-get-default">GMT_Get_Default</a></td>
<td>Obtain one of the API or GMT default settings</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#gmt-get-index">GMT_Get_Index</a></td>
<td>Convert row, col into a grid or image index</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#gmt-get-matrix">GMT_Get_Matrix</a></td>
<td>Obtain pointer to user matrix from container</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#gmt-get-pixel">GMT_Get_Pixel</a></td>
<td>Get grid or image node</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#gmt-get-record">GMT_Get_Record</a></td>
<td>Import a single data record</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#gmt-get-row">GMT_Get_Row</a></td>
<td>Import a single grid row</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#gmt-get-values">GMT_Get_Values</a></td>
<td>Convert string into coordinates or dimensions</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#gmt-get-vector">GMT_Get_Vector</a></td>
<td>Obtain pointer to user vector from container</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#gmt-init-io">GMT_Init_IO</a></td>
<td>Initialize i/o given registered resources</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#gmt-init-virtualfile">GMT_Init_VirtualFile</a></td>
<td>Reset a virtual file for reuse</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#gmt-make-option">GMT_Make_Option</a></td>
<td>Create an option structure</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#gmt-message">GMT_Message</a></td>
<td>Issue a message, optionally with time stamp</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#gmt-open-virtualfile">GMT_Open_VirtualFile</a></td>
<td>Select memory location as input or output for module</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#gmt-option">GMT_Option</a></td>
<td>Explain one or more GMT common options</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#gmt-parse-common">GMT_Parse_Common</a></td>
<td>Parse the GMT common options</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#gmt-put-matrix">GMT_Put_Matrix</a></td>
<td>Put user matrix into container</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#gmt-put-record">GMT_Put_Record</a></td>
<td>Export a data record</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#gmt-put-row">GMT_Put_Row</a></td>
<td>Export a grid row</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#gmt-put-vector">GMT_Put_Vector</a></td>
<td>Put user vector into container</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#gmt-read-data">GMT_Read_Data</a></td>
<td>Import a data resource or file</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#gmt-read-group">GMT_Read_Group</a></td>
<td>Import a group of data resources or files</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#gmt-read-virtualfile">GMT_Read_VirtualFile</a></td>
<td>Access the output from a module via memory</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#gmt-register-io">GMT_Register_IO</a></td>
<td>Register a resources for i/o</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#gmt-report">GMT_Report</a></td>
<td>Issue a message contingent upon verbosity level</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#gmt-set-default">GMT_Set_Default</a></td>
<td>Set one of the API or GMT default settings</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#gmt-set-comment">GMT_Set_Comment</a></td>
<td>Assign a comment to a data resource</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#gmt-set-columns">GMT_Set_Columns</a></td>
<td>Specify how many output columns to use for rec-by-rec</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#gmt-set-geometry">GMT_Set_Geometry</a></td>
<td>Specify data geometry for rec-by-rec i/o</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#gmt-set-index">GMT_Set_Index</a></td>
<td>Convert row, col into a grid or image index</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#gmt-status-io">GMT_Status_IO</a></td>
<td>Check status of record-by-record i/o</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#gmt-update-option">GMT_Update_Option</a></td>
<td>Modify an option structure</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#gmt-write-data">GMT_Write_Data</a></td>
<td>Export a data resource</td>
</tr>
</tbody>
</table>
<p>Summary of all the API functions and their purpose.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="the-gmt-c-application-program-interface">
<h1>3. The GMT C Application Program Interface<a class="headerlink" href="#the-gmt-c-application-program-interface" title="Permalink to this headline">¶</a></h1>
<div class="section" id="initialize-a-new-gmt-session">
<h2>3.1. Initialize a new GMT session<a class="headerlink" href="#initialize-a-new-gmt-session" title="Permalink to this headline">¶</a></h2>
<p>Advanced programs may be calling more than one GMT session and thus
run several sessions, perhaps concurrently as different threads on
multi-core machines. We will now discuss these steps in more detail.
Throughout, we will introduce upper-case GMT C enum constants <em>in
lieu</em> of simple integer constants. These are considered part of the API
and are available for developers via the <code class="docutils literal notranslate"><span class="pre">gmt_resources.h</span></code> include file.</p>
<p>Most applications will need to initialize only a single GMT session.
This is true of all the standard GMT programs since they only call one
GMT module and then exit. Most user-developed GMT applications are
likely to only initialize one session even though they may call many
GMT modules. However, the GMT API supports any number of
simultaneous sessions should the programmer wish to take advantage of
it. This might be useful when you have access to several CPUs and want
to spread the computing load <a class="footnote-reference" href="#id11" id="id5">[5]</a>. In the following discussion we will
simplify our treatment to the use of a single session only.</p>
<p>To initiate the new GMT session we use</p>
<blockquote id="gmt-create-session">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="o">*</span><span class="nf">GMT_Create_Session</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tag</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pad</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">print_func</span><span class="p">)</span> <span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">));</span>
</pre></div>
</div>
</div></blockquote>
<p>and you will typically call it like this:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>   <span class="cm">/* Opaque pointer to GMT controls */</span>
<span class="n">API</span> <span class="o">=</span> <span class="n">GMT_Create_Session</span> <span class="p">(</span><span class="s">&quot;Session name&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>where <code class="docutils literal notranslate"><span class="pre">API</span></code> is an opaque pointer to the hidden GMT API control
structure. You will need to pass this pointer to <em>all</em> subsequent
GMT API functions; this is how essential internal information is
passed around. The key task of this initialization is to
set up the GMT machinery and internal variables used for map
projections, plotting, i/o, etc. The initialization also allocates space
for internal structures used to keep track of data. The <code class="docutils literal notranslate"><span class="pre">pad</span></code> argument
specifies how many rows and columns should be used as padding for grids and
images so that boundary conditions can be applied. GMT uses 2 and we strongly
recommend that you use that value. In particular, if you choose 0 or 1 there may be certain
GMT modules that will be unable to do their work properly as they count on those
boundary rows and columns in the grids.  Note that this setting has no effect
on what is written to a grid file; the padding is an internal feature.
The <code class="docutils literal notranslate"><span class="pre">mode</span></code> argument is only used for external APIs that need
to communicate their special needs during the session creation.  This integer argument
is a sum of bit flags and the various bits control the following settings:</p>
<ol class="arabic simple">
<li>Bit 1 (1): If set, then GMT will not call the system exit function when a
serious problem has been detected but instead will simply return control
to the calling environment.  For instance, this is required by the GMT/MATLAB toolbox
since calling exit would also exit MATLAB itself.  Unless your environment
has this feature you should leave this bit alone.</li>
<li>Bit 2 (2): If set, then it means we are calling the GMT API from an external
API, such as MATLAB, Octave, or Python.  Normal C/C++ programs should
leave this bit alone.  Its effect is to enable two additional modules
for reading and writing GMT resources from these environments (those modules
would not make any sense in a Unix command-line environment).</li>
<li>Bit 3 (4): If set, then it means the external API uses a column-major format for
matrices (e.g., MATLAB, Fortran).  If not set we default to row-major
format (C/C++, Python, etc.).</li>
<li>Bit 4 (8): If set, the we enable GMT’s modern run-mode (where -O -K are
not allowed and PostScript is written to hidden temp file).  Default
is the GMT classic run-mode.</li>
</ol>
<p>The <code class="docutils literal notranslate"><span class="pre">print_func</span></code> argument is a pointer to a function that is used to print
messages from GMT via <a class="reference internal" href="#gmt-message">GMT_Message</a> or <a class="reference internal" href="#gmt-report">GMT_Report</a> from external environments that cannot use the
standard printf function (this is the case for the GMT/MATLAB toolbox, for instance).
For all other uses you should simply pass NULL for this argument.
Should something go wrong during the API initialization then <code class="docutils literal notranslate"><span class="pre">API</span></code> will be returned as <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.
Finally, <a class="reference internal" href="#gmt-create-session">GMT_Create_Session</a> will examine the environmental parameter TMPDIR (TEMP on Windows)
to set the GMT temporary directory [/tmp on Unix, current directory on Windows].</p>
<p>Below is a bare-bones minimalistic GMT program hello.c that initializes and destroys
a GMT session:</p>
<div class="highlight-c notranslate" id="example-code2"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;gmt.h&quot;</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
      <span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">;</span>      <span class="cm">/* The API control structure */</span>
      <span class="cm">/* Initialize the GMT session */</span>
      <span class="n">API</span> <span class="o">=</span> <span class="n">GMT_Create_Session</span> <span class="p">(</span><span class="s">&quot;test&quot;</span><span class="p">,</span> <span class="mi">2U</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
      <span class="cm">/* And now for something original: */</span>
      <span class="n">GMT_Message</span> <span class="p">(</span><span class="n">API</span><span class="p">,</span> <span class="n">GMT_TIME_NONE</span><span class="p">,</span> <span class="s">&quot;hello, world</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
      <span class="cm">/* Destroy the GMT session */</span>
      <span class="n">GMT_Destroy_Session</span> <span class="p">(</span><span class="n">API</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>While not super-exiting, this code demonstrates the two essential API calls
required to initiate and later terminate a GMT session.  In between we do what
all basic programs are supposed to do: print “Hello, world”.  The user is of course
allowed to do whatever custom processing before the GMT session is created
and can do all sorts of stuff after the GMT session is destroyed, as long as
no GMT functions or resources are accessed.  It may be convenient to isolate
the GMT-specific processing from the custom part of the program and only
maintain an active GMT session when needed.</p>
</div>
<div class="section" id="register-input-or-output-resources">
<h2>3.2. Register input or output resources<a class="headerlink" href="#register-input-or-output-resources" title="Permalink to this headline">¶</a></h2>
<p>When using the standard GMT programs, it is common to specify input files on the
command line or via special program options (e.g.,
<strong>-I</strong><em>intensity.nc</em>). The outputs of the programs are either written
to standard output (which you may redirect to files or pipes into other
programs) or to files specified by specific program options (e.g.,
<strong>-G</strong><em>output.nc</em>). Alternatively, the GMT API allows you to specify
input (and output) to be associated with open file handles or virtual files.
We will examine this more closely below. Registering a
resource is a required step before attempting to import or export data
that <em>do not</em> come from files or standard input/output.</p>
<div class="section" id="resource-initialization">
<span id="sec-res-init"></span><h3>3.2.1. Resource initialization<a class="headerlink" href="#resource-initialization" title="Permalink to this headline">¶</a></h3>
<p>All GMT programs dealing with input or output files given on the
command line, and perhaps defaulting to the standard input or output
streams if no files are given, must call the i/o initializer function
<a class="reference internal" href="#gmt-init-io">GMT_Init_IO</a> once for each direction required (i.e., input and output
separately). For input it determines how many input sources have already
been registered. If none has been registered then it scans the program
arguments for any filenames given on the command line and register these
input resources. Finally, if we still have found no input sources we
assign the standard input stream as the single input source. For output
it is similar: If no single destination has been registered we specify
the standard output stream as the output destination. Only one main
output destination is allowed to be active when a module writes data
(some modules also write additional output via program-specific
options). The prototype for this function is</p>
<blockquote id="gmt-init-io">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">GMT_Init_IO</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">geometry</span><span class="p">,</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">direction</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n_args</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>where <a class="reference internal" href="#tbl-family"><span class="std std-ref">family</span></a> specifies what kind of resource is to be registered,
<a class="reference internal" href="#tbl-geometry"><span class="std std-ref">geometry</span></a> specifies the geometry of the data, <code class="docutils literal notranslate"><span class="pre">direction</span></code> is either
<code class="docutils literal notranslate"><span class="pre">GMT_IN</span></code> or <code class="docutils literal notranslate"><span class="pre">GMT_OUT</span></code>, and <code class="docutils literal notranslate"><span class="pre">mode</span></code> is a bit flag that determines
what we do if no resources have been registered. The choices are</p>
<blockquote>
<div><p><strong>GMT_ADD_FILES_IF_NONE</strong> (1) means “add command line (option)
files if none have been registered already”.</p>
<p><strong>GMT_ADD_FILES_ALWAYS</strong> (2) means “always add any command line files”.</p>
<p><strong>GMT_ADD_STDIO_IF_NONE</strong> (4) means “add std* if no other
input/output have been specified”.</p>
<p><strong>GMT_ADD_DEFAULT</strong> (6) means “always add any command line files first, and then
add std* if no other input/output were specified”.</p>
<p><strong>GMT_ADD_STDIO_ALWAYS</strong> (8) means “always add std* even if
resources have been registered”.</p>
<p><strong>GMT_ADD_EXISTING</strong> (16) means “only use already registered resources”.</p>
</div></blockquote>
<p>The standard behavior is <code class="docutils literal notranslate"><span class="pre">GMT_ADD_DEFAULT</span></code> (6). Next, <code class="docutils literal notranslate"><span class="pre">n_args</span></code> is 0
if <code class="docutils literal notranslate"><span class="pre">args</span></code> is the head of a linked list of options (further discussed
in <a class="reference internal" href="#sec-func"><span class="std std-ref">Prepare modules opts</span></a>); otherwise <code class="docutils literal notranslate"><span class="pre">args</span></code> is an array of <code class="docutils literal notranslate"><span class="pre">n_args</span></code>
strings (i.e., the int argc, char *argv[] model)</p>
<p>Many programs will register an export location where results of a GMT function (say, a filtered grid)
should be returned, but may then wish to use that variable as an <em>input</em> resource in a subsequent module
call. This is accomplished by re-registering the resource as an <em>input</em> source, thereby changing the
<em>direction</em> of the data set. The function returns 1 if there is an error; otherwise it returns 0. <a href="#openModal">Example</a>
<div id="openModal" class="modalDialog">
 <div>
     <a href="#close" title="Close" class="close">X</a>
     <h2>Resource initialization example</h2>
     <p>
     </p>
 </div>
</div></p>
</div>
<div class="section" id="resource-registration">
<h3>3.2.2. Resource registration<a class="headerlink" href="#resource-registration" title="Permalink to this headline">¶</a></h3>
<p>Should your program need to add additional sources (or a destination) to the list of items
to be considered you will need to register them manually.  This is considered a low-level
activity and most applications are unlikely to have to resort to this step.  We document
it here in case your situation calls for such action.
Registration involves a direct or indirect call to</p>
<blockquote id="gmt-register-io">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">GMT_Register_IO</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">method</span><span class="p">,</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">geometry</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">direction</span><span class="p">,</span> <span class="kt">double</span> <span class="n">wesn</span><span class="p">[],</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>where <a class="reference internal" href="#tbl-family"><span class="std std-ref">family</span></a> specifies what kind of resource is to be registered,
<a class="reference internal" href="#tbl-methods"><span class="std std-ref">method</span></a> specifies
how we to access this resource (see Table <a class="reference internal" href="#tbl-methods"><span class="std std-ref">methods</span></a> for recognized
methods), <a class="reference internal" href="#tbl-geometry"><span class="std std-ref">geometry</span></a> specifies the geometry of the data, <code class="docutils literal notranslate"><span class="pre">ptr</span></code> is the address of the
pointer to the named resource. If <code class="docutils literal notranslate"><span class="pre">direction</span></code> is <code class="docutils literal notranslate"><span class="pre">GMT_OUT</span></code> and the
<code class="docutils literal notranslate"><span class="pre">method</span></code> is not related to a file (filename, stream, or handle), then
<code class="docutils literal notranslate"><span class="pre">ptr</span></code> must be NULL. Note there are some limitations on when you may pass a file pointer
as the method.  Many grid file formats cannot be read via a stream (e.g., netCDF files) so in
those situations you cannot pass a file pointer [and GMT_Register_IO would have no way of knowing
this].  For grid (and image)
resources you may request to obtain a subset via the <a class="reference internal" href="#tbl-wesn"><span class="std std-ref">wesn</span></a> array; otherwise, pass NULL
(or an array with at least 4 items all set to 0) to obtain the
entire grid (or image). The <code class="docutils literal notranslate"><span class="pre">direction</span></code> indicates input or output and
is either <code class="docutils literal notranslate"><span class="pre">GMT_IN</span></code> or <code class="docutils literal notranslate"><span class="pre">GMT_OUT</span></code>. Finally, the function returns a
unique resource ID, or <code class="docutils literal notranslate"><span class="pre">GMT_NOTSET</span></code> if there was an error.</p>
<blockquote id="tbl-family">
<div><table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">family</th>
<th class="head">source points to</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>GMT_IS_DATASET</td>
<td>A [multi-segment] data file</td>
</tr>
<tr class="row-odd"><td>GMT_IS_GRID</td>
<td>A grid file</td>
</tr>
<tr class="row-even"><td>GMT_IS_IMAGE</td>
<td>An image</td>
</tr>
<tr class="row-odd"><td>GMT_IS_PALETTE</td>
<td>A color palette table [CPT]</td>
</tr>
<tr class="row-even"><td>GMT_IS_POSTSCRIPT</td>
<td>A GMT PostScript object</td>
</tr>
<tr class="row-odd"><td>GMT_IS_TEXTSET</td>
<td>A [multi-segment] text file</td>
</tr>
<tr class="row-even"><td>GMT_IS_MATRIX</td>
<td>A custom user data matrix</td>
</tr>
<tr class="row-odd"><td>GMT_IS_VECTOR</td>
<td>A custom user data vector</td>
</tr>
</tbody>
</table>
<p>GMT constants used to specify a data family.</p>
</div></blockquote>
<blockquote id="tbl-methods">
<div><table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="73%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">method</th>
<th class="head">how to read/write data</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>GMT_IS_FILE</td>
<td>Pointer to name of a file</td>
</tr>
<tr class="row-odd"><td>GMT_IS_STREAM</td>
<td>Pointer to open stream (or process)</td>
</tr>
<tr class="row-even"><td>GMT_IS_FDESC</td>
<td>Pointer to integer file descriptor</td>
</tr>
<tr class="row-odd"><td>GMT_IS_DUPLICATE</td>
<td>Pointer to memory we may <em>duplicate</em> data from</td>
</tr>
<tr class="row-even"><td>GMT_IS_REFERENCE</td>
<td>Pointer to memory we may <em>reference</em> data from</td>
</tr>
</tbody>
</table>
<p>GMT constants used to specify how data will be read or written.</p>
</div></blockquote>
<blockquote id="tbl-geometry">
<div><table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">geometry</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>GMT_IS_NONE</td>
<td>Not a geographic feature</td>
</tr>
<tr class="row-odd"><td>GMT_IS_POINT</td>
<td>Multi-dimensional point data</td>
</tr>
<tr class="row-even"><td>GMT_IS_LINE</td>
<td>Geographic or Cartesian line segments</td>
</tr>
<tr class="row-odd"><td>GMT_IS_POLYGON</td>
<td>Geographic or Cartesian closed polygons</td>
</tr>
<tr class="row-even"><td>GMT_IS_PLP</td>
<td>Either points, lines, or polygons</td>
</tr>
<tr class="row-odd"><td>GMT_IS_SURFACE</td>
<td>2-D gridded surface</td>
</tr>
</tbody>
</table>
<p>GMT constants used to specify the geometry of the data object.</p>
</div></blockquote>
<blockquote id="tbl-wesn">
<div><table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">index</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>GMT_XLO</td>
<td>x_min (west) boundary of grid subset</td>
</tr>
<tr class="row-odd"><td>GMT_XHI</td>
<td>x_max (east) boundary of grid subset</td>
</tr>
<tr class="row-even"><td>GMT_YLO</td>
<td>y_min (south) boundary of grid subset</td>
</tr>
<tr class="row-odd"><td>GMT_YHI</td>
<td>y_max (north) boundary of grid subset</td>
</tr>
<tr class="row-even"><td>GMT_ZLO</td>
<td>z_min (bottom) boundary of 3-D matrix subset</td>
</tr>
<tr class="row-odd"><td>GMT_ZHI</td>
<td>z_max (top) boundary of 3-D matrix subset</td>
</tr>
</tbody>
</table>
<p>GMT constants used for domain array indexing.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="create-empty-resources">
<span id="sec-create"></span><h2>3.3. Create empty resources<a class="headerlink" href="#create-empty-resources" title="Permalink to this headline">¶</a></h2>
<p>If your application needs to build and populate GMT resources in ways
that do not depend on external resources (files, memory locations,
etc.), or you have data read in separately and you wish to build a
GMT resource from scratch, then you can obtain an empty object by calling</p>
<blockquote id="gmt-create-data">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="o">*</span><span class="n">GMT_Create_Data</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">geometry</span><span class="p">,</span>
     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">par</span><span class="p">[],</span> <span class="kt">double</span> <span class="o">*</span><span class="n">wesn</span><span class="p">,</span> <span class="kt">double</span> <span class="o">*</span><span class="n">inc</span><span class="p">,</span>
     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">registration</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pad</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>which returns a pointer to the allocated resource. Pass a valid <a class="reference internal" href="#tbl-family"><span class="std std-ref">family</span></a> selection.
Also pass a compatible <a class="reference internal" href="#tbl-geometry"><span class="std std-ref">geometry</span></a>. Depending on the family and your particular way of
representing dimensions you may pass the additional parameters in one of
two ways:</p>
<ol class="arabic simple">
<li>Actual integer dimensions of items needed (which depends on the <code class="docutils literal notranslate"><span class="pre">family</span></code>).</li>
<li>Physical distances and increments of each dimension.</li>
</ol>
<p>For the first case you should pass both <code class="docutils literal notranslate"><span class="pre">wesn</span></code> and <code class="docutils literal notranslate"><span class="pre">inc</span></code> as NULL (or as arrays with elements all set to 0),
and pass the <code class="docutils literal notranslate"><span class="pre">par</span></code> array with contents as indicated below:</p>
<blockquote>
<div><dl class="docutils">
<dt><strong>GMT_IS_GRID</strong>.</dt>
<dd>An empty <a class="reference internal" href="#struct-grid"><span class="std std-ref">GMT_GRID</span></a> structure with a header is allocated; the data
array is NULL.  Use <code class="docutils literal notranslate"><span class="pre">registration</span></code> to choose either gridline (<code class="docutils literal notranslate"><span class="pre">GMT_GRID_PIXEL_REG</span></code>) or pixel
(<code class="docutils literal notranslate"><span class="pre">GMT_GRID_NODE_REG</span></code>) registration.  The domain can be prescribed on one of two ways:
(1) The <code class="docutils literal notranslate"><span class="pre">par</span></code> argument is NULL. Then <code class="docutils literal notranslate"><span class="pre">wesn</span></code> and <code class="docutils literal notranslate"><span class="pre">inc</span></code> can also be NULL but only if the common GMT options
<strong>-R</strong> and <strong>-I</strong> have been set because they are required to get the necessary info. If they
were not set, then <code class="docutils literal notranslate"><span class="pre">wesn</span></code> and <code class="docutils literal notranslate"><span class="pre">inc</span></code> must in fact be transmitted.  If <code class="docutils literal notranslate"><span class="pre">wesn</span></code> and <code class="docutils literal notranslate"><span class="pre">inc</span></code>
are set (directly or indirectly) then <code class="docutils literal notranslate"><span class="pre">par</span></code> is ignored, even if not NULL.
(2) The <code class="docutils literal notranslate"><span class="pre">par</span></code> argument is not NULL but both <code class="docutils literal notranslate"><span class="pre">wesn</span></code> and <code class="docutils literal notranslate"><span class="pre">inc</span></code> are NULL.
Now, <code class="docutils literal notranslate"><span class="pre">par[0]</span></code> must have the number of columns and <code class="docutils literal notranslate"><span class="pre">par[1]</span></code> must have the number of rows in the grid.  Internally,
<code class="docutils literal notranslate"><span class="pre">inc</span></code> will be set to 1/1 and <code class="docutils literal notranslate"><span class="pre">wesn</span></code> will be set to 0/n_columns/0/n_rows. As an option, add <code class="docutils literal notranslate"><span class="pre">GMT_GRID_XY</span></code> to <code class="docutils literal notranslate"><span class="pre">mode</span></code>
and we also allocate the grids’s <em>x</em> and <em>y</em> coordinate vectors.</dd>
<dt><strong>GMT_IS_IMAGE</strong>.</dt>
<dd>Same procedure as for <strong>GMT_IS_GRID</strong> but we return an empty <a class="reference internal" href="#struct-image"><span class="std std-ref">GMT_IMAGE</span></a> object.  In either
way of specification you may use <code class="docutils literal notranslate"><span class="pre">par[2]</span></code> to pass the number of image bands [1].</dd>
<dt><strong>GMT_IS_DATASET</strong>.</dt>
<dd>We allocate an empty <a class="reference internal" href="#struct-dataset"><span class="std std-ref">GMT_DATASET</span></a> structure consisting of <code class="docutils literal notranslate"><span class="pre">par[0]</span></code> tables,
each with <code class="docutils literal notranslate"><span class="pre">par[1]</span></code> segments, each with <code class="docutils literal notranslate"><span class="pre">par[2]</span></code> rows, all with <code class="docutils literal notranslate"><span class="pre">par[3]</span></code> columns.
The <code class="docutils literal notranslate"><span class="pre">wesn</span></code>, <code class="docutils literal notranslate"><span class="pre">inc</span></code>, and <code class="docutils literal notranslate"><span class="pre">registration</span></code> argument are ignored.  The <code class="docutils literal notranslate"><span class="pre">data</span></code> argument should be NULL.</dd>
<dt><strong>GMT_IS_TEXTSET</strong>.</dt>
<dd>We allocate an empty <a class="reference internal" href="#struct-textset"><span class="std std-ref">GMT_TEXTSET</span></a> structure consisting of <code class="docutils literal notranslate"><span class="pre">par[0]</span></code> tables,
each with <code class="docutils literal notranslate"><span class="pre">par[1]</span></code> segments, all with <code class="docutils literal notranslate"><span class="pre">par[2]</span></code> text records (rows).
The <code class="docutils literal notranslate"><span class="pre">wesn</span></code>, <code class="docutils literal notranslate"><span class="pre">inc</span></code>, and <code class="docutils literal notranslate"><span class="pre">registration</span></code> arguments are ignored and should be NULL/0.  The <code class="docutils literal notranslate"><span class="pre">data</span></code> argument should be NULL.</dd>
<dt><strong>GMT_IS_PALETTE</strong>.</dt>
<dd>We allocate an empty <a class="reference internal" href="#struct-palette"><span class="std std-ref">GMT_PALETTE</span></a> structure with <code class="docutils literal notranslate"><span class="pre">par[0]</span></code> palette entries.
The <code class="docutils literal notranslate"><span class="pre">wesn</span></code>, <code class="docutils literal notranslate"><span class="pre">inc</span></code>, and <code class="docutils literal notranslate"><span class="pre">registration</span></code> arguments are ignored and should be NULL/0.  The <code class="docutils literal notranslate"><span class="pre">data</span></code> argument should be NULL.</dd>
<dt><strong>GMT_IS_POSTSCRIPT</strong>.</dt>
<dd>We allocate an empty <a class="reference internal" href="#struct-postscript"><span class="std std-ref">GMT_POSTSCRIPT</span></a> structure with a text buffer of length <code class="docutils literal notranslate"><span class="pre">par[0]</span></code>.
Give <code class="docutils literal notranslate"><span class="pre">par[0]</span></code> = 0 if the PostScript string is allocated or obtained by other means.
The <code class="docutils literal notranslate"><span class="pre">wesn</span></code>, <code class="docutils literal notranslate"><span class="pre">inc</span></code>, and <code class="docutils literal notranslate"><span class="pre">registration</span></code> arguments are ignored and should be NULL/0.  The <code class="docutils literal notranslate"><span class="pre">data</span></code> argument should be NULL.</dd>
<dt><strong>GMT_IS_VECTOR</strong>.</dt>
<dd>We allocate an empty <a class="reference internal" href="#struct-vector"><span class="std std-ref">GMT_VECTOR</span></a> structure with <code class="docutils literal notranslate"><span class="pre">par[0]</span></code> column entries.
The number of rows can be specified in one of two ways: (1) Set the number of rows via <code class="docutils literal notranslate"><span class="pre">par[1]</span></code>. Then,
<code class="docutils literal notranslate"><span class="pre">wesn</span></code>, <code class="docutils literal notranslate"><span class="pre">inc</span></code>, and <code class="docutils literal notranslate"><span class="pre">registration</span></code> arguments are ignored.
(2) Specify <code class="docutils literal notranslate"><span class="pre">wesn</span></code>, <code class="docutils literal notranslate"><span class="pre">inc</span></code>, and <code class="docutils literal notranslate"><span class="pre">registration</span></code> and the number of rows will be computed form these
parameters instead.  The <code class="docutils literal notranslate"><span class="pre">data</span></code> argument should be NULL.  If you have custom vectors you wish to use then pass <code class="docutils literal notranslate"><span class="pre">par[1]</span></code> = 0
to avoid any allocation and use <a class="reference internal" href="#gmt-put-vector">GMT_Put_Vector</a> to hook up your vectors.</dd>
<dt><strong>GMT_IS_MATRIX</strong>.</dt>
<dd>We allocate an empty <a class="reference internal" href="#struct-matrix"><span class="std std-ref">GMT_MATRIX</span></a> structure. The domain can be prescribed on one of two ways:
(1) Here, <code class="docutils literal notranslate"><span class="pre">par[0]</span></code> is the number of columns while <code class="docutils literal notranslate"><span class="pre">par[1]</span></code> has the number of rows.  Also,
<code class="docutils literal notranslate"><span class="pre">par[2]</span></code> indicates the number of layers for a 3-D matrix, or pass 0, 1, or NULL for a 2-D matrix.
(2) Pass <code class="docutils literal notranslate"><span class="pre">wesn</span></code>, <code class="docutils literal notranslate"><span class="pre">inc</span></code>, <code class="docutils literal notranslate"><span class="pre">registration</span></code> and we compute the dimensions of the matrix.
The <code class="docutils literal notranslate"><span class="pre">data</span></code> argument should be NULL.  As for vectors, give dimensions as 0 and hook your custom matrix in
via a call to <a class="reference internal" href="#gmt-put-matrix">GMT_Put_Matrix</a>.</dd>
</dl>
</div></blockquote>
<p>For grids and images you may pass <code class="docutils literal notranslate"><span class="pre">pad</span></code> to set the padding, or -1 to
accept the prevailing GMT default. The <code class="docutils literal notranslate"><span class="pre">mode</span></code> determines what is actually
allocated when you have chosen grids or images. As for <a class="reference internal" href="#gmt-read-data">GMT_Read_Data</a>
you can pass <code class="docutils literal notranslate"><span class="pre">GMT_CONTAINER_AND_DATA</span></code> to initialize the header <em>and</em> allocate
space for the array; here <code class="docutils literal notranslate"><span class="pre">data</span></code> must be NULL. Alternatively, you can pass
<code class="docutils literal notranslate"><span class="pre">GMT_CONTAINER_ONLY</span></code> to just initialize the grid or image header,
and later call GMT_Create_Data a second time, now passing <code class="docutils literal notranslate"><span class="pre">GMT_DATA_ONLY</span></code>, to allocate
space for the array. In that second call you pass the pointer returned
by the first call as <code class="docutils literal notranslate"><span class="pre">data</span></code> and specify the family; all other
arguments should be NULL or 0. Normally, resources created by this
function are considered to be input (i.e., have a direction that is <code class="docutils literal notranslate"><span class="pre">GMT_IN</span></code>).
The exception to this is for containers to hold results from GMT which need have a direction
set to <code class="docutils literal notranslate"><span class="pre">GMT_OUT</span></code>.   Such empty containers are requested by passing mode = <code class="docutils literal notranslate"><span class="pre">GMT_IS_OUTPUT</span></code>
and setting all dimension arguments to 0 or NULL.
The function returns a pointer to the
data container. In case of an error we return a NULL pointer and pass an
error code via <code class="docutils literal notranslate"><span class="pre">API-&gt;error</span></code>.</p>
<div class="section" id="hooking-user-arrays-to-objects">
<h3>3.3.1. Hooking user arrays to objects<a class="headerlink" href="#hooking-user-arrays-to-objects" title="Permalink to this headline">¶</a></h3>
<p>If you have custom column vector or matrices and you want them to be used as
input to GMT modules, you will need to create a <a class="reference internal" href="#struct-vector"><span class="std std-ref">GMT_VECTOR</span></a> or <a class="reference internal" href="#struct-matrix"><span class="std std-ref">GMT_MATRIX</span></a> container
and hook your items to them.  Likewise, if you want to receive the output of GMT modules
into user arrays or matrices then you will need to access those data.
The following utility functions are used for these tasks:</p>
<blockquote id="gmt-put-matrix">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">GMT_Put_Matrix</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="k">struct</span> <span class="n">GMT_MATRIX</span> <span class="o">*</span><span class="n">M</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">matrix</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>where <code class="docutils literal notranslate"><span class="pre">M</span></code> is a <a class="reference internal" href="#struct-matrix"><span class="std std-ref">GMT_MATRIX</span></a> created by <a class="reference internal" href="#gmt-create-data">GMT_Create_Data</a>, the <code class="docutils literal notranslate"><span class="pre">type</span></code> is one of the
recognized data <a class="reference internal" href="#tbl-types"><span class="std std-ref">types</span></a>, and <code class="docutils literal notranslate"><span class="pre">matrix</span></code> is your custom matrix.
To extract a custom matrix from an output <a class="reference internal" href="#struct-matrix"><span class="std std-ref">GMT_MATRIX</span></a> you can use</p>
<blockquote id="gmt-get-matrix">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="o">*</span><span class="nf">GMT_Get_Matrix</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="k">struct</span> <span class="n">GMT_MATRIX</span> <span class="o">*</span><span class="n">M</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>which simply returns a pointer to the right union pointer.
For vectors the same principles apply:</p>
<blockquote id="gmt-put-vector">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">GMT_Put_Vector</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="k">struct</span> <span class="n">GMT_VECTOR</span> <span class="o">*</span><span class="n">V</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">col</span><span class="p">,</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">vector</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>where <code class="docutils literal notranslate"><span class="pre">V</span></code> is the <a class="reference internal" href="#struct-vector"><span class="std std-ref">GMT_VECTOR</span></a> created by <a class="reference internal" href="#gmt-create-data">GMT_Create_Data</a>, <code class="docutils literal notranslate"><span class="pre">col</span></code> is the vector
column in question, <code class="docutils literal notranslate"><span class="pre">type</span></code> is one of the
recognized data <a class="reference internal" href="#tbl-types"><span class="std std-ref">types</span></a> used for this vector, and <code class="docutils literal notranslate"><span class="pre">vector</span></code> is
a pointer to this custom vector.
To extract a custom vector from an output <a class="reference internal" href="#struct-vector"><span class="std std-ref">GMT_VECTOR</span></a> you can use</p>
<blockquote id="gmt-get-vector">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="o">*</span><span class="nf">GMT_Get_Vector</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="k">struct</span> <span class="n">GMT_VECTOR</span> <span class="o">*</span><span class="n">V</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">col</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>where <code class="docutils literal notranslate"><span class="pre">col</span></code> is the vector number you wish to obtain a pointer to.</p>
</div>
<div class="section" id="manually-add-segments">
<h3>3.3.2. Manually add segments<a class="headerlink" href="#manually-add-segments" title="Permalink to this headline">¶</a></h3>
<p>If you do not know the number of rows in the segments or you expect different segments to have different
lengths then you should set the row dimension to zero in GMT_Create_Data and add the segments
manually with <code class="docutils literal notranslate"><span class="pre">GMT_Alloc_Segment</span></code>, which allocates a new <a class="reference internal" href="#struct-dataset"><span class="std std-ref">GMT_DATASET</span></a> or
<a class="reference internal" href="#struct-textset"><span class="std std-ref">GMT_TEXTSET</span></a> segment for such multi-segment tables.</p>
<blockquote id="gmt-alloc-segment">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="o">*</span><span class="nf">GMT_Alloc_Segment</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">family</span><span class="p">,</span>
    <span class="kt">uint64_t</span> <span class="n">n_rows</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">n_columns</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">header</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">S</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>where <code class="docutils literal notranslate"><span class="pre">header</span></code> is the segment’s desired header (or NULL) and <cite>family</cite> selects which
kind of resource is desired , which in this case should either be <code class="docutils literal notranslate"><span class="pre">GMT_IS_DATASET</span></code>
or <code class="docutils literal notranslate"><span class="pre">GMT_IS_TEXTSET</span></code>.  If <code class="docutils literal notranslate"><span class="pre">S</span></code> is not NULL then we simply reallocate the lengths
of the segment; otherwise a new segment is first allocated.</p>
<p>For a <a class="reference internal" href="#struct-dataset"><span class="std std-ref">GMT_DATASET</span></a> there is also the option of controlling the allocation of the segment
array by setting n_rows = 0.  This would allow external arrays (double-precision only) to connect to
the S-&gt;data[col] arrays and not be freed by GMT’s garbage collector.</p>
</div>
</div>
<div class="section" id="duplicate-resources">
<h2>3.4. Duplicate resources<a class="headerlink" href="#duplicate-resources" title="Permalink to this headline">¶</a></h2>
<p>Often you have read or created a data resource and then need an
identical copy, presumably to make modifications to. Or, you want a copy
with the same dimensions and allocated memory, except data values should
not be duplicated. Alternatively, perhaps you just want to duplicate the
header and skip the allocation and duplication of the data entirely. These tasks
are addressed by</p>
<blockquote id="gmt-duplicate-data">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="o">*</span><span class="nf">GMT_Duplicate_Data</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>which returns a pointer to the allocated resource. Specify which
<a class="reference internal" href="#tbl-family"><span class="std std-ref">family</span></a> and select <code class="docutils literal notranslate"><span class="pre">mode</span></code> from <code class="docutils literal notranslate"><span class="pre">GMT_DUPLICATE_DATA</span></code>,
<code class="docutils literal notranslate"><span class="pre">GMT_DUPLICATE_ALLOC</span></code>, and <code class="docutils literal notranslate"><span class="pre">GMT_DUPLICATE_NONE</span></code>, as discussed above
(also see <code class="docutils literal notranslate"><span class="pre">mode</span></code> discussion above). For <a class="reference internal" href="#struct-grid"><span class="std std-ref">GMT_GRID</span></a>
you may add <code class="docutils literal notranslate"><span class="pre">GMT_DUPLICATE_RESET</span></code> which will ensure the duplicate grid
will have normal padding (useful when the original has non-standard padding).
For <a class="reference internal" href="#struct-dataset"><span class="std std-ref">GMT_DATASET</span></a> and <a class="reference internal" href="#struct-textset"><span class="std std-ref">GMT_TEXTSET</span></a> you can
add modifiers <code class="docutils literal notranslate"><span class="pre">GMT_ALLOC_VERTICAL</span></code> or <code class="docutils literal notranslate"><span class="pre">GMT_ALLOC_HORIZONTAL</span></code> to the <code class="docutils literal notranslate"><span class="pre">mode</span></code> if you
wish to put all the data into a single long table or to paste all tables
side-by-side, respectively (thus getting one wide table instead).
Additional note for <a class="reference internal" href="#struct-dataset"><span class="std std-ref">GMT_DATASET</span></a>: Normally we allocate the output given the
corresponding input dimensions. You can override these by specifying your
alternative dimensions in the input dataset’s variable <code class="docutils literal notranslate"><span class="pre">dim[]</span></code>.
The <code class="docutils literal notranslate"><span class="pre">data</span></code> is a pointer to the resource you wish to duplicate. In case
of an error we return a NULL pointer and pass an error code via
<code class="docutils literal notranslate"><span class="pre">API-&gt;error</span></code>.</p>
</div>
<div class="section" id="convert-between-resource-types">
<h2>3.5. Convert between resource types<a class="headerlink" href="#convert-between-resource-types" title="Permalink to this headline">¶</a></h2>
<p>Having a resource in memory you may want to convert it to an alternative
representation.  For instance, you may have a <a class="reference internal" href="#struct-dataset"><span class="std std-ref">GMT_DATASET</span></a> in memory but
for an application you need the equivalent information in <a class="reference internal" href="#struct-textset"><span class="std std-ref">GMT_TEXTSET</span></a> format.
Or, you have read a <a class="reference internal" href="#struct-dataset"><span class="std std-ref">GMT_DATASET</span></a> but need to strip the information from the
data into a VECTOR format, dropping all the segment header information, so
that your custom algorithm or other non-GMT functions can be used on the data.
In this case you will use</p>
<blockquote id="gmt-convert-data">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="o">*</span><span class="nf">GMT_Convert_Data</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">In</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">family_in</span><span class="p">,</span>
            <span class="kt">void</span> <span class="o">*</span><span class="n">Out</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">family_out</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">[]);</span>
</pre></div>
</div>
</div></blockquote>
<p>which returns a pointer to the converted resource. Specify the needed
<a class="reference internal" href="#tbl-family"><span class="std std-ref">family</span></a> for both the input and output resources and set the
(up to) three flags passed via the <code class="docutils literal notranslate"><span class="pre">flag</span></code> array.  The first <code class="docutils literal notranslate"><span class="pre">flag[0]</span></code>
determines how table headers and segment headers should be handled.
By default (<code class="docutils literal notranslate"><span class="pre">flag[0]</span></code> = 0) they are preserved (to the extent possible).
E.g., converting a <a class="reference internal" href="#struct-dataset"><span class="std std-ref">GMT_DATASET</span></a> to MATRIX always means table headers are
skipped whereas segment headers are converted to NaN-records. Other
values for this flag is 1 (Table headers are not copied, segment headers are preserved),
2 (Headers are preserved, segment headers are reset to blank), or
3 (All headers headers are eliminated).  Note that this flag only
affects duplication of headers.  If the new object is written to file at
a later stage then it is up to the GMT default setting if headers are written
to file or not. The second <code class="docutils literal notranslate"><span class="pre">flag[1]</span></code> controls
how many columns to expect when converting <a class="reference internal" href="#struct-textset"><span class="std std-ref">GMT_TEXTSET</span></a> only.  If 0 then
we try to determine the number of columns from the first text record.
If <code class="docutils literal notranslate"><span class="pre">family_in</span></code> is not <code class="docutils literal notranslate"><span class="pre">GMT_IS_TEXTSET</span></code> then flag[1] is ignored.
The third <code class="docutils literal notranslate"><span class="pre">flag[2]</span></code> controls restructuring of tables and segments within
a set.  For <code class="docutils literal notranslate"><span class="pre">flag[2]</span></code> = 0 we retain the original layout.  Other selections
are <code class="docutils literal notranslate"><span class="pre">GMT_WRITE_TABLE_SEGMENT</span></code> (combine all segments into a <em>single</em> segment in a <em>single</em> table),
<code class="docutils literal notranslate"><span class="pre">GMT_WRITE_TABLE</span></code> (collect all segments into a <em>single</em> table), and <code class="docutils literal notranslate"><span class="pre">GMT_WRITE_SEGMENT</span></code>
(combine segments into <em>one</em> segment per table).
Many family combinations are simply not allowed, such as grid to color palette, dataset to image,
etc.</p>
</div>
<div class="section" id="import-data-sets">
<h2>3.6. Import Data Sets<a class="headerlink" href="#import-data-sets" title="Permalink to this headline">¶</a></h2>
<p>If your program needs to import any of the six recognized data types
(data table, grid, image, CPT, PostScript, or text table) you will use
the <a class="reference internal" href="#gmt-read-data">GMT_Read_Data</a> or <a class="reference internal" href="#gmt-read-virtualfile">GMT_Read_VirtualFile</a> functions. The former
is typically used when reading from files, streams (e.g., <code class="docutils literal notranslate"><span class="pre">stdin</span></code>), or
an open file handle, while the latter is only used to read from memory.
Because of the similarities of these six
import functions we use an generic form that covers all of them.</p>
<p>All input functions takes a parameter called <code class="docutils literal notranslate"><span class="pre">mode</span></code>. The <code class="docutils literal notranslate"><span class="pre">mode</span></code>
parameter generally has different meanings for the different data types
and will be discussed below. However, one bit setting is common to all
types: By default, you are only allowed to read a data source once; the
source is then flagged as having been read and subsequent attempts to
read from the same source will result in a warning and no reading takes
place. In the unlikely event you need to re-read a source you can
override this default behavior by adding <code class="docutils literal notranslate"><span class="pre">GMT_IO_RESET</span></code> to your <code class="docutils literal notranslate"><span class="pre">mode</span></code>
parameter. Note that this override does not apply to sources that are
streams or file handles, as it may not be possible to re-read their
contents.</p>
<div class="section" id="import-from-a-file-stream-or-handle">
<h3>3.6.1. Import from a file, stream, or handle<a class="headerlink" href="#import-from-a-file-stream-or-handle" title="Permalink to this headline">¶</a></h3>
<p>To read an entire resource from a file, stream, or file handle, use</p>
<blockquote id="gmt-read-data">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="o">*</span><span class="nf">GMT_Read_Data</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">method</span><span class="p">,</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">geometry</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">double</span> <span class="n">wesn</span><span class="p">[],</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">input</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<ul class="simple">
<li><a class="reference internal" href="#gmt-create-session"><span class="std std-ref">API</span></a></li>
<li><a class="reference internal" href="#tbl-family"><span class="std std-ref">family</span></a></li>
<li><a class="reference internal" href="#tbl-methods"><span class="std std-ref">method</span></a></li>
<li><a class="reference internal" href="#tbl-geometry"><span class="std std-ref">geometry</span></a></li>
<li>mode -- <em>see below</em></li>
<li><a class="reference internal" href="#tbl-wesn"><span class="std std-ref">wesn</span></a></li>
<li>input -- a pointer to char holding the file name to read, or NULL if <code class="docutils literal notranslate"><span class="pre">stdin</span></code></li>
<li>ptr -- NULL or the pointer returned by this function after a first call (when reading grids in two steps)</li>
<li>Return: Pointer to data container, or NULL if there were errors (passed back via API-&gt;error)</li>
</ul>
<p>where <code class="docutils literal notranslate"><span class="pre">ptr</span></code> is NULL except when reading grids in two steps (i.e.,
first get a grid structure with a header, then read the data). Most of
these arguments have been discussed earlier. This function can be called
in three different situations:</p>
<ol class="arabic simple">
<li>If you have a single source (filename, stream pointer, etc.) you can
call <a class="reference internal" href="#gmt-read-data">GMT_Read_Data</a> directly; there is no need to first register
the source with <a class="reference internal" href="#gmt-register-io">GMT_Register_IO</a> or gather the sources with
<a class="reference internal" href="#gmt-init-io">GMT_Init_IO</a>. Furthermore, for <a class="reference internal" href="#struct-dataset"><span class="std std-ref">GMT_DATASET</span></a> and <a class="reference internal" href="#struct-textset"><span class="std std-ref">GMT_TEXTSET</span></a> you can also
specify a filename that contains UNIX wildcards (e.g., “all_*_[ab]?.txt”)
and these will all be read to produce a single multi-table <a class="reference internal" href="#struct-dataset"><span class="std std-ref">GMT_DATASET</span></a> or
<a class="reference internal" href="#struct-textset"><span class="std std-ref">GMT_TEXTSET</span></a> (for other datatypes, see <a class="reference internal" href="#gmt-read-group">GMT_Read_Group</a> instead).</li>
<li>If you want to specify <code class="docutils literal notranslate"><span class="pre">stdin</span></code> as source then pass <code class="docutils literal notranslate"><span class="pre">input</span></code> as NULL.</li>
<li>If you already registered all desired sources with <a class="reference internal" href="#gmt-init-io">GMT_Init_IO</a>
then you indicate this choice by passing the invalid <code class="docutils literal notranslate"><span class="pre">geometry</span></code> = 0.</li>
</ol>
<p>Space will be allocated to hold the results, as needed, and a pointer to
the object is returned. If there are errors we simply return NULL and
report the error. The <code class="docutils literal notranslate"><span class="pre">mode</span></code> parameter has different meanings for
different data types.</p>
<dl class="docutils">
<dt><strong>Color palette table</strong>.</dt>
<dd><code class="docutils literal notranslate"><span class="pre">mode</span></code> contains bit-flags that control how the CPT’s back-,
fore-, and NaN-colors should be initialized. Select 0 to use the
CPT resource’s back-, fore-, and NaN-colors, 2 to replace these with the current
GMT default values, or 4 to replace them with the color table’s
entries for highest and lowest value.</dd>
<dt><strong>Data table</strong>.</dt>
<dd><code class="docutils literal notranslate"><span class="pre">mode</span></code> is currently not used.</dd>
<dt><strong>Text table</strong>.</dt>
<dd><code class="docutils literal notranslate"><span class="pre">mode</span></code> is currently not used.</dd>
<dt><strong>GMT grid</strong> or <strong>image</strong>.</dt>
<dd>Here, <code class="docutils literal notranslate"><span class="pre">mode</span></code> determines how we read the grid: To read the entire
grid and its header, pass <code class="docutils literal notranslate"><span class="pre">GMT_CONTAINER_AND_DATA</span></code>. However, if you may need to
extract a sub-region you must first read the header by passing
<code class="docutils literal notranslate"><span class="pre">GMT_CONTAINER_ONLY</span></code>, then examine the header structure range
attributes, specify a subset via the array <code class="docutils literal notranslate"><span class="pre">wesn</span></code>, and
finally call <a class="reference internal" href="#gmt-read-data">GMT_Read_Data</a> a second time, now with <code class="docutils literal notranslate"><span class="pre">mode</span></code> =
<code class="docutils literal notranslate"><span class="pre">GMT_DATA_ONLY</span></code>, passing your <code class="docutils literal notranslate"><span class="pre">wesn</span></code> array and the grid
structure returned from the first call as <code class="docutils literal notranslate"><span class="pre">ptr</span></code>. In the event your
data array should be allocated to hold both the real and imaginary
parts of a complex data set you must add either
<code class="docutils literal notranslate"><span class="pre">GMT_GRID_IS_COMPLEX_REAL</span></code> or <code class="docutils literal notranslate"><span class="pre">GMT_GRID_IS_COMPLEX_IMAG</span></code> to
<code class="docutils literal notranslate"><span class="pre">mode</span></code> so as to allow for the extra memory needed and to stride
the complex value-pairs correctly. If your grid is huge and you must read
it row-by-row, set <code class="docutils literal notranslate"><span class="pre">mode</span></code> to <code class="docutils literal notranslate"><span class="pre">GMT_CONTAINER_ONLY</span></code> |
<code class="docutils literal notranslate"><span class="pre">GMT_GRID_ROW_BY_ROW</span></code>. You can then access the grid row-by-row
using <a class="reference internal" href="#gmt-get-row">GMT_Get_Row</a>. By default, the rows will be automatically
processed in sequential order. To completely specify which row to be read, pass
<code class="docutils literal notranslate"><span class="pre">GMT_GRID_ROW_BY_ROW_MANUAL</span></code> instead.
Finally, as an option you may add <code class="docutils literal notranslate"><span class="pre">GMT_GRID_XY</span></code> to the mode and we also
allocate the <em>x</em> and <em>y</em> coordinate vectors for the grid or image.</dd>
<dt><strong>PostScript</strong>.</dt>
<dd><code class="docutils literal notranslate"><span class="pre">mode</span></code> is currently not used.</dd>
</dl>
<p>If you need to read the same resource more than once you should add the
bit flag <code class="docutils literal notranslate"><span class="pre">GMT_IO_RESET</span></code> to the given <code class="docutils literal notranslate"><span class="pre">mode</span></code>.</p>
</div>
<div class="section" id="import-a-group-of-data-sets">
<h3>3.6.2. Import a group of data sets<a class="headerlink" href="#import-a-group-of-data-sets" title="Permalink to this headline">¶</a></h3>
<p>To read a group of resources, you may instead use</p>
<blockquote id="gmt-read-group">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="o">*</span><span class="nf">GMT_Read_Group</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">method</span><span class="p">,</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">geometry</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">double</span> <span class="n">wesn</span><span class="p">[],</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">input</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">n_items</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<ul class="simple">
<li><a class="reference internal" href="#gmt-create-session"><span class="std std-ref">API</span></a></li>
<li><a class="reference internal" href="#tbl-family"><span class="std std-ref">family</span></a></li>
<li><a class="reference internal" href="#tbl-methods"><span class="std std-ref">method</span></a></li>
<li><a class="reference internal" href="#tbl-geometry"><span class="std std-ref">geometry</span></a></li>
<li>mode -- <em>see below</em></li>
<li><a class="reference internal" href="#tbl-wesn"><span class="std std-ref">wesn</span></a></li>
<li>input -- Contents depends on the value of <em>n_items</em>.  If it is zero then we expect
a pointer to char holding UNIX wildcard file name(s) to read, otherwise we expect
a pointer to an array of character strings (<em>n_items</em> in total) with names of all
the files to read.  If <em>n_items</em> is NULL then we assume 0 but cannot return the number
found.</li>
<li>ptr -- NULL or the pointer returned by this function after a first call (applies when reading grids or images in two steps)</li>
<li>Return: Pointer to array of data container, or NULL if there were errors (passed back via API-&gt;error)</li>
</ul>
<p>where <code class="docutils literal notranslate"><span class="pre">ptr</span></code> is NULL except when reading grids in two steps (i.e.,
first get a grid structures with a header, then read the data arrays). Most of
these arguments have been discussed earlier. It is useful when you need to read
a series of files (e.g., from a list with filenames) or want to specify the items
to read using a UNIX wildcard specification.  Note: If used with <a class="reference internal" href="#struct-dataset"><span class="std std-ref">GMT_DATASET</span></a>
or <a class="reference internal" href="#struct-textset"><span class="std std-ref">GMT_TEXTSET</span></a>
then you will receive an array of structures as well.  Typically, many data/text files
are read into separate tables that all form part of a single SET (this is what <a class="reference internal" href="#gmt-read-data">GMT_Read_Data</a> does),
but if <a class="reference internal" href="#gmt-read-group">GMT_Read_Group</a> is used on the same arguments then an array of one-table sets will
be returned instead.  The purpose of your application will dictate which form is more convenient.</p>
</div>
<div class="section" id="open-a-virtual-file-memory-location">
<h3>3.6.3. Open a virtual file (memory location)<a class="headerlink" href="#open-a-virtual-file-memory-location" title="Permalink to this headline">¶</a></h3>
<p>If you have read in or otherwise obtained a data object in memory and you
now wish for it to serve as input to a GMT module, you will have to associate
that object with a “Virtual File”.  This step assigns a special filename to the
memory location and you can then pass this filename to any module that
needs to read that data.  It is similar for writing, and you can pass
NULL as the object to have GMT automatically allocate the output resource.
The full syntax is</p>
<blockquote id="gmt-open-virtualfile">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="o">*</span><span class="nf">GMT_Open_VirtualFile</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">geometry</span><span class="p">,</span>
            <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">direction</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>Here, <code class="docutils literal notranslate"><span class="pre">data</span></code> is the pointer to your memory object.  The function returns the
desired filename via <code class="docutils literal notranslate"><span class="pre">filename</span></code>.  This string must be at least <code class="docutils literal notranslate"><span class="pre">GMT_STR16</span></code> bytes (16).
The other arguments have been discussed earlier.  Simply pass this filename in
the calling sequence to the module you want to use to indicate which file should
be used for reading or writing.</p>
</div>
<div class="section" id="import-from-a-virtual-file">
<h3>3.6.4. Import from a virtual file<a class="headerlink" href="#import-from-a-virtual-file" title="Permalink to this headline">¶</a></h3>
<p>Once the module completes it will have written its output to the virtual file
you initialized with <a class="reference internal" href="#gmt-open-virtualfile">GMT_Open_VirtualFile</a>.  To use the actual
data you will need to “read” it into your program.  Of course, the data are already
in memory but to access it you need to use <a class="reference internal" href="#gmt-read-virtualfile">GMT_Read_VirtualFile</a>, which expects
the output filename you obtained from <a class="reference internal" href="#gmt-open-virtualfile">GMT_Open_VirtualFile</a>.  The syntax is</p>
<blockquote id="gmt-read-virtualfile">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="o">*</span><span class="nf">GMT_Read_VirtualFile</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>The function requires the output filename via <code class="docutils literal notranslate"><span class="pre">filename</span></code> and then returns
the data object, similar to what <a class="reference internal" href="#gmt-read-data">GMT_Read_Data</a> does.</p>
</div>
<div class="section" id="reset-a-virtual-file-for-reuse">
<h3>3.6.5. Reset a virtual file for reuse<a class="headerlink" href="#reset-a-virtual-file-for-reuse" title="Permalink to this headline">¶</a></h3>
<p>Should you need to read a virtual file again then you must first reset
it to its original state with <a class="reference internal" href="#gmt-init-virtualfile">GMT_Init_VirtualFile</a>.  The syntax is</p>
<blockquote id="gmt-init-virtualfile">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">GMT_Init_VirtualFile</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>The function requires the virtual file’s <code class="docutils literal notranslate"><span class="pre">filename</span></code> and then resets the
internal counters (e.g., record numbers and other book-keeping parameters).
The <code class="docutils literal notranslate"><span class="pre">mode</span></code> is presently not used.</p>
</div>
<div class="section" id="close-a-virtual-file">
<h3>3.6.6. Close a virtual file<a class="headerlink" href="#close-a-virtual-file" title="Permalink to this headline">¶</a></h3>
<p>Once you have finished using a virtual file you need to close it.
This will reset its internal settings back to what it was before you
used it as a virtual file.  The syntax is</p>
<blockquote id="gmt-close-virtualfile">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">GMT_Close_VirtualFile</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>where <code class="docutils literal notranslate"><span class="pre">filename</span></code> is the name of the virtual file.</p>
</div>
</div>
<div class="section" id="record-by-record-input">
<h2>3.7. Record-by-record input<a class="headerlink" href="#record-by-record-input" title="Permalink to this headline">¶</a></h2>
<p>In the case of data and text tables you have the option of selecting
record-by-record reading or writing.  As a general rule, your program
development simplifies if you can read entire resources into memory with
<a class="reference internal" href="#gmt-read-data">GMT_Read_Data</a> or <a class="reference internal" href="#gmt-read-virtualfile">GMT_Read_VirtualFile</a>.  However, if this leads to
unacceptable memory usage or if the program logic is particularly simple,
you may obtain one data record at the time via <a class="reference internal" href="#gmt-get-record">GMT_Get_Record</a> and write
one at the time with <a class="reference internal" href="#gmt-put-record">GMT_Put_Record</a>.  For row-by-row i/o for grids there
is the corresponding function <a class="reference internal" href="#gmt-get-row">GMT_Get_Row</a>. There are additional overhead involved
in setting up record-by-record processing, which is the topic of this section.</p>
<div class="section" id="enable-data-import">
<h3>3.7.1. Enable Data Import<a class="headerlink" href="#enable-data-import" title="Permalink to this headline">¶</a></h3>
<p>Once all input resources have been registered, we signal the API that we
are done with the registration phase and are ready to start the actual
data import. This step is only required when reading one record at the
time. We initialize record-by-record reading by calling
<a class="reference internal" href="#gmt-begin-io">GMT_Begin_IO</a>. This function enables data and text
record-by-record reading and prepares the registered sources for the
upcoming import. The prototype is</p>
<blockquote id="gmt-begin-io">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">GMT_Begin_IO</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">direction</span><span class="p">,</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">header</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>where <a class="reference internal" href="#tbl-family"><span class="std std-ref">family</span></a> specifies the resource type to be read or written
(only <code class="docutils literal notranslate"><span class="pre">GMT_IS_DATASET</span></code> and <code class="docutils literal notranslate"><span class="pre">GMT_IS_TEXTSET</span></code> are
available for record-by-record handling). The <code class="docutils literal notranslate"><span class="pre">direction</span></code> is either
<code class="docutils literal notranslate"><span class="pre">GMT_IN</span></code> or <code class="docutils literal notranslate"><span class="pre">GMT_OUT</span></code>, so for import we obviously use <code class="docutils literal notranslate"><span class="pre">GMT_IN</span></code>. The
function determines the first input source and sets up procedures for
skipping to the next input source in a virtual data set. The
<a class="reference internal" href="#gmt-get-record">GMT_Get_Record</a> function will not be able to read any data before
<a class="reference internal" href="#gmt-begin-io">GMT_Begin_IO</a> has been called. As you might guess, there is a
companion <a class="reference internal" href="#gmt-end-io">GMT_End_IO</a> function that completes, then disables
record-by-record data access. You can use these several times to switch
modes between registering data resources, doing the importing/exporting,
and disabling further data access, perhaps to do more registration. We
will discuss <a class="reference internal" href="#gmt-end-io">GMT_End_IO</a> once we are done with the data import. The final
<code class="docutils literal notranslate"><span class="pre">header</span></code> argument determines if the common header-block should be
written during initialization; choose between <code class="docutils literal notranslate"><span class="pre">GMT_HEADER_ON</span></code> and
<code class="docutils literal notranslate"><span class="pre">GMT_HEADER_OFF</span></code>. The function returns 1 if there is an
error; otherwise it returns 0.</p>
</div>
<div class="section" id="set-data-geometry">
<h3>3.7.2. Set data geometry<a class="headerlink" href="#set-data-geometry" title="Permalink to this headline">¶</a></h3>
<p>Typically only done for output data written record by record, we designate
the data set’s geometry by calling</p>
<blockquote id="gmt-set-geometry">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">_GMT_Set_Geometry</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">direction</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">geometry</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>where <code class="docutils literal notranslate"><span class="pre">direction</span></code> is either <code class="docutils literal notranslate"><span class="pre">GMT_IN</span></code> or <code class="docutils literal notranslate"><span class="pre">GMT_OUT</span></code> and <a class="reference internal" href="#tbl-geometry"><span class="std std-ref">geometry</span></a>
sets the geometry that will be produced (or read).</p>
</div>
<div class="section" id="importing-a-data-record">
<h3>3.7.3. Importing a data record<a class="headerlink" href="#importing-a-data-record" title="Permalink to this headline">¶</a></h3>
<p>If your program will read data table records one-by-one you must first
enable this input mechanism with <a class="reference internal" href="#gmt-begin-io">GMT_Begin_IO</a> and then read the
records within a loop, repeatedly using</p>
<blockquote id="gmt-get-record">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="o">*</span><span class="nf">GMT_Get_Record</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nfields</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>where the returned value is either a pointer to a double array with the
current row values or to a character string with the current row,
depending on <code class="docutils literal notranslate"><span class="pre">mode</span></code>. In either case these pointers point to ephemeral memory
internal to GMT and should be considered read-only. When we reach
end-of-file, encounter conversion problems, read header comments, or
identify segment headers we instead return a NULL pointer. The <code class="docutils literal notranslate"><span class="pre">nfields</span></code>
integer pointer will return the number of fields returned; pass NULL if your
program should ignore this information.</p>
<p>Normally (i.e., <code class="docutils literal notranslate"><span class="pre">mode</span></code> = <code class="docutils literal notranslate"><span class="pre">GMT_READ_DATA</span></code>), we return a pointer to
a double array. To read text records, supply instead <code class="docutils literal notranslate"><span class="pre">mode</span></code> =
<code class="docutils literal notranslate"><span class="pre">GMT_READ_TEXT</span></code> and we will return a pointer to the text
record. However, if you have input records that mixes organized
floating-point columns with text items you could pass <code class="docutils literal notranslate"><span class="pre">mode</span></code> =
<code class="docutils literal notranslate"><span class="pre">GMT_READ_MIXED</span></code>. Then, GMT will attempt to extract the
floating-point values from as many columns as needed; you can still access the original record string, as
discussed below. Finally, if your application needs to be notified when
GMT closes one file and opens the next, add <code class="docutils literal notranslate"><span class="pre">GMT_FILE_BREAK</span></code> to
<code class="docutils literal notranslate"><span class="pre">mode</span></code> and check for the status code <code class="docutils literal notranslate"><span class="pre">GMT_IO_NEXT_FILE</span></code> (by default,
we treat the concatenation of many input files as a single virtual
file). Using <a class="reference internal" href="#gmt-get-record">GMT_Get_Record</a> requires you to first initialize the
source(s) with <a class="reference internal" href="#gmt-init-io">GMT_Init_IO</a>. For certain records, <a class="reference internal" href="#gmt-get-record">GMT_Get_Record</a>
will return NULL and sets status codes that your program will need to
examine to take appropriate response. Table <a class="reference internal" href="#tbl-iostatus"><span class="std std-ref">IO-status</span></a> lists the
various status codes you can check for, using the <code class="docutils literal notranslate"><span class="pre">GMT_Status_IO</span></code> function (see
next section).</p>
</div>
<div class="section" id="examining-record-status">
<h3>3.7.4. Examining record status<a class="headerlink" href="#examining-record-status" title="Permalink to this headline">¶</a></h3>
<p>Programs that read record-by-record must be aware of what the current
record represents. Given the presence of headers, data gaps, NaN-record,
etc., the developer may want to check the status after reading the current
record. The internal i/o status mode can be interrogated with the function</p>
<blockquote id="gmt-status-io">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">GMT_Status_IO</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>which returns 0 (false) or 1 (true) if the current status is reflected
by the specified <code class="docutils literal notranslate"><span class="pre">mode</span></code>. There are 11 different modes available to
programmers; for a list see Table <a class="reference internal" href="#tbl-iostatus"><span class="std std-ref">IO-status</span></a> For an example of how
these may be used, see the test program <code class="docutils literal notranslate"><span class="pre">testgmtio.c</span></code>. Developers who plan to import
data on a record-by-record basis may also consult the source code of,
say, <a class="reference internal" href="blockmean.html"><span class="doc">blockmean</span></a> or <a class="reference internal" href="pstext.html"><span class="doc">pstext</span></a>, to see examples of working code.</p>
<blockquote id="tbl-iostatus">
<div><table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">mode</th>
<th class="head">description and return value</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>GMT_IO_DATA_RECORD</td>
<td>1 if we read a data record</td>
</tr>
<tr class="row-odd"><td>GMT_IO_TABLE_HEADER</td>
<td>1 if we read a table header</td>
</tr>
<tr class="row-even"><td>GMT_IO_SEGMENT_HEADER</td>
<td>1 if we read a segment header</td>
</tr>
<tr class="row-odd"><td>GMT_IO_ANY_HEADER</td>
<td>1 if we read either header record</td>
</tr>
<tr class="row-even"><td>GMT_IO_MISMATCH</td>
<td>1 if we read incorrect number of columns</td>
</tr>
<tr class="row-odd"><td>GMT_IO_EOF</td>
<td>1 if we reached the end of the file (EOF)</td>
</tr>
<tr class="row-even"><td>GMT_IO_NAN</td>
<td>1 if we only read NaNs</td>
</tr>
<tr class="row-odd"><td>GMT_IO_GAP</td>
<td>1 if this record implies a data gap</td>
</tr>
<tr class="row-even"><td>GMT_IO_NEW_SEGMENT</td>
<td>1 if we enter a new segment</td>
</tr>
<tr class="row-odd"><td>GMT_IO_LINE_BREAK</td>
<td>1 if we encountered a segment header, EOF, NaNs or gap</td>
</tr>
<tr class="row-even"><td>GMT_IO_NEXT_FILE</td>
<td>1 if we finished one file but not the last</td>
</tr>
</tbody>
</table>
<p>The various modes used to test the status of the record-by-record machinery.</p>
</div></blockquote>
</div>
<div class="section" id="importing-a-grid-row">
<h3>3.7.5. Importing a grid row<a class="headerlink" href="#importing-a-grid-row" title="Permalink to this headline">¶</a></h3>
<p>If your program must read a grid file row-by-row you must first enable
row-by-row reading with <a class="reference internal" href="#gmt-read-data">GMT_Read_Data</a> and then use the
<a class="reference internal" href="#gmt-get-row">GMT_Get_Row</a> function in a loop; the prototype is</p>
<blockquote id="gmt-get-row">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">GMT_Get_Row</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="kt">int</span> <span class="n">row_no</span><span class="p">,</span> <span class="k">struct</span> <span class="n">GMT_GRID</span> <span class="o">*</span><span class="n">G</span><span class="p">,</span> <span class="kt">float</span> <span class="o">*</span><span class="n">row</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>where <code class="docutils literal notranslate"><span class="pre">row</span></code> is a pointer to a pre-allocated single-precision array to receive the
current row, <code class="docutils literal notranslate"><span class="pre">G</span></code> is the grid in question, and <code class="docutils literal notranslate"><span class="pre">row_no</span></code> is the number
of the current row to be read. Note this value is only considered if the
row-by-row mode was initialized with <code class="docutils literal notranslate"><span class="pre">GMT_GRID_ROW_BY_ROW_MANUAL</span></code>.
The user must allocate enough space to hold the entire row in memory.</p>
</div>
<div class="section" id="disable-data-import">
<h3>3.7.6. Disable Data Import<a class="headerlink" href="#disable-data-import" title="Permalink to this headline">¶</a></h3>
<p>Once the record-by-record input processing has completed we disable
further input to prevent accidental reading from occurring (due to poor
program structure, bugs, etc.). We do so by calling <a class="reference internal" href="#gmt-end-io">GMT_End_IO</a>. This
function disables further record-by-record data import; its prototype is</p>
<blockquote id="gmt-end-io">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">GMT_End_IO</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">direction</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>and we specify <code class="docutils literal notranslate"><span class="pre">direction</span></code> = <code class="docutils literal notranslate"><span class="pre">GMT_IN</span></code>. At the moment, <code class="docutils literal notranslate"><span class="pre">mode</span></code> is not
used. This call will also reallocate any arrays obtained into their
proper lengths. The function returns 1 if there is an error
(whose code is passed back with <code class="docutils literal notranslate"><span class="pre">API-&gt;error</span></code>), otherwise it returns 0 (<code class="docutils literal notranslate"><span class="pre">GMT_NOERROR</span></code>).</p>
</div>
</div>
<div class="section" id="manipulate-data">
<span id="sec-manipulate"></span><h2>3.8. Manipulate data<a class="headerlink" href="#manipulate-data" title="Permalink to this headline">¶</a></h2>
<p>Once you have created and allocated empty resources, or read in
resources from the outside, you may wish to manipulate their contents.
This section discusses how to set up loops and access the important
variables for each of the supported families. For grids and images it may in addition
be required to determine what the coordinates are at each node point. This information
can be obtained via arrays of coordinates for each dimension, obtained by</p>
<blockquote id="gmt-get-coord">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span> <span class="o">*</span><span class="nf">GMT_Get_Coord</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dim</span><span class="p">,</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>where <a class="reference internal" href="#tbl-family"><span class="std std-ref">family</span></a> must be <code class="docutils literal notranslate"><span class="pre">GMT_IS_GRID</span></code> or <code class="docutils literal notranslate"><span class="pre">GMT_IS_DATASET</span></code>, <code class="docutils literal notranslate"><span class="pre">dim</span></code> is either
<code class="docutils literal notranslate"><span class="pre">GMT_IS_X</span></code> or <code class="docutils literal notranslate"><span class="pre">GMT_IS_Y</span></code>, and <code class="docutils literal notranslate"><span class="pre">data</span></code> is the grid or image pointer.  This
function will be used below in our example on grid manipulation.</p>
<p>Another aspect of dealing with grids and images is to convert a row and column
2-D reference to our 1-D array index.  Because of grid and image boundary padding
the relationship is not straightforward, hence we supply</p>
<blockquote id="gmt-get-index">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int64_t</span> <span class="nf">GMT_Get_Index</span> <span class="p">(</span><span class="k">struct</span> <span class="n">GMT_GRID_HEADER</span> <span class="o">*</span><span class="n">header</span><span class="p">,</span> <span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>where the <code class="docutils literal notranslate"><span class="pre">header</span></code> is the header of either a grid or image, and <code class="docutils literal notranslate"><span class="pre">row</span></code> and
<code class="docutils literal notranslate"><span class="pre">col</span></code> is the 2-D position in the grid or image.  We return the 1-D array
position; again this function is used below in our example.  Likewise, for images
with many layers we also define</p>
<blockquote id="gmt-get-pixel">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int64_t</span> <span class="nf">GMT_Get_Pixel</span> <span class="p">(</span><span class="k">struct</span> <span class="n">GMT_GRID_HEADER</span> <span class="o">*</span><span class="n">header</span><span class="p">,</span> <span class="kt">int</span> <span class="n">row</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">col</span><span class="p">,</span> <span class="kt">int</span> <span class="n">layer</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>where the <code class="docutils literal notranslate"><span class="pre">header</span></code> is the header of an image, and <code class="docutils literal notranslate"><span class="pre">row</span></code>, <code class="docutils literal notranslate"><span class="pre">col</span></code> and
<code class="docutils literal notranslate"><span class="pre">layer</span></code> (= 1 for grids) is the position in the grid or image.</p>
<div class="section" id="manipulate-grids">
<h3>3.8.1. Manipulate grids<a class="headerlink" href="#manipulate-grids" title="Permalink to this headline">¶</a></h3>
<p>Most applications wishing to manipulate grids will want to loop over all
the nodes, typically in a manner organized by rows and columns. In doing
so, the coordinates at each node may also be required for a calculation.
Below is a snippet of code that shows how to do visit all nodes in a
grid and assign each node the product x * y:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">node</span><span class="p">;</span>
<span class="kt">double</span> <span class="o">*</span><span class="n">x_coord</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">y_coord</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cm">/*... create a grid G or read one ... */</span>
<span class="n">x_coord</span> <span class="o">=</span> <span class="n">GMT_Get_Coord</span> <span class="p">(</span><span class="n">API</span><span class="p">,</span> <span class="n">GMT_IS_GRID</span><span class="p">,</span> <span class="n">GMT_X</span><span class="p">,</span> <span class="n">G</span><span class="p">);</span>
<span class="n">y_coord</span> <span class="o">=</span> <span class="n">GMT_Get_Coord</span> <span class="p">(</span><span class="n">API</span><span class="p">,</span> <span class="n">GMT_IS_GRID</span><span class="p">,</span> <span class="n">GMT_Y</span><span class="p">,</span> <span class="n">G</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">header</span><span class="o">-&gt;</span><span class="n">n_rows</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">header</span><span class="o">-&gt;</span><span class="n">n_columns</span><span class="p">;</span> <span class="n">col</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">GMT_Get_Index</span> <span class="p">(</span><span class="n">G</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">);</span>
        <span class="n">G</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_coord</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">*</span> <span class="n">y_coord</span><span class="p">[</span><span class="n">row</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>Note the use of <a class="reference internal" href="#gmt-get-index">GMT_Get_Index</a> to get the grid node number associated
with the <code class="docutils literal notranslate"><span class="pre">row</span></code> and <code class="docutils literal notranslate"><span class="pre">col</span></code> we are visiting. Because GMT grids have
padding (for boundary conditions) the relationship between rows,
columns, and node indices is more complicated and hence we hide that
complexity in <a class="reference internal" href="#gmt-get-index">GMT_Get_Index</a>. Note that for trivial procedures such
setting all grid nodes to a constant (e.g., -9999.0) where the row and
column does not enter you can instead do a single loop:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">node</span><span class="p">;</span>
<span class="cm">/*... create a grid G or read one ... */</span>
<span class="k">for</span> <span class="p">(</span><span class="n">node</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">node</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">header</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">9999.0</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
<p>Note we must use <code class="docutils literal notranslate"><span class="pre">G-&gt;header-&gt;size</span></code> (size of allocated array) and not
<code class="docutils literal notranslate"><span class="pre">G-&gt;header-&gt;nm</span></code> (number of nodes in grid) since the latter is smaller
due to the padding and a single loop like the above treats the pad as
part of the “inside” grid. Replacing <code class="docutils literal notranslate"><span class="pre">size</span></code> by <code class="docutils literal notranslate"><span class="pre">nm</span></code> would be a bug.</p>
</div>
<div class="section" id="manipulate-data-tables">
<h3>3.8.2. Manipulate data tables<a class="headerlink" href="#manipulate-data-tables" title="Permalink to this headline">¶</a></h3>
<p>Another common application is to process the records in a data table.
Because GMT considers the <a class="reference internal" href="#struct-dataset"><span class="std std-ref">GMT_DATASET</span></a> resources to contain one or more
tables, each of which may contain one or more segments, all of which may
contain one or more columns, you will need to have multiple nested loops to
visit all entries. The following code snippet will visit all data
records and add 1 to all columns beyond the first two (x and y):</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint64_t</span> <span class="n">tbl</span><span class="p">,</span> <span class="n">seg</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">GMT_DATATABLE</span> <span class="o">*</span><span class="n">T</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">GMT_DATASEGMENT</span> <span class="o">*</span><span class="n">S</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="cm">/* ... create a dataset D or read one ... */</span>
<span class="k">for</span> <span class="p">(</span><span class="n">tbl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tbl</span> <span class="o">&lt;</span> <span class="n">D</span><span class="o">-&gt;</span><span class="n">n_tables</span><span class="p">;</span> <span class="n">tbl</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>       <span class="cm">/* For each table */</span>
  <span class="n">T</span> <span class="o">=</span> <span class="n">D</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">tbl</span><span class="p">];</span>       <span class="cm">/* Convenient shorthand for current table */</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">seg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">seg</span> <span class="o">&lt;</span> <span class="n">T</span><span class="o">-&gt;</span><span class="n">n_segments</span><span class="p">;</span> <span class="n">seg</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>   <span class="cm">/* For all segments */</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">T</span><span class="o">-&gt;</span><span class="n">segment</span><span class="p">[</span><span class="n">seg</span><span class="p">];</span>   <span class="cm">/* Convenient shorthand for current segment */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">S</span><span class="o">-&gt;</span><span class="n">n_rows</span><span class="p">;</span> <span class="n">row</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* For all rows in segment */</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">col</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">T</span><span class="o">-&gt;</span><span class="n">n_columns</span><span class="p">;</span> <span class="n">col</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>    <span class="cm">/* For all cols &gt; 1 */</span>
        <span class="n">S</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">col</span><span class="p">][</span><span class="n">row</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1.0</span><span class="p">;</span>   <span class="cm">/* Just add one */</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="manipulate-text-tables">
<h3>3.8.3. Manipulate text tables<a class="headerlink" href="#manipulate-text-tables" title="Permalink to this headline">¶</a></h3>
<p>When the data files contain text mixed in with numbers you must open the file
as a <a class="reference internal" href="#struct-textset"><span class="std std-ref">GMT_TEXTSET</span></a> and do your own parsing of the data records. The
following code snippet will visit all text records and print them out with some counters:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint64_t</span> <span class="n">tbl</span><span class="p">,</span> <span class="n">seg</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">GMT_TEXTTABLE</span> <span class="o">*</span><span class="n">T</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">GMT_TEXTSEGMENT</span> <span class="o">*</span><span class="n">S</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="cm">/* ... create a textset D or read one ... */</span>
<span class="k">for</span> <span class="p">(</span><span class="n">tbl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tbl</span> <span class="o">&lt;</span> <span class="n">D</span><span class="o">-&gt;</span><span class="n">n_tables</span><span class="p">;</span> <span class="n">tbl</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>   <span class="cm">/* For each table */</span>
  <span class="n">T</span> <span class="o">=</span> <span class="n">D</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">tbl</span><span class="p">];</span>        <span class="cm">/* Convenient shorthand for current table */</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">seg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">seg</span> <span class="o">&lt;</span> <span class="n">T</span><span class="o">-&gt;</span><span class="n">n_segments</span><span class="p">;</span> <span class="n">seg</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>   <span class="cm">/* For all segments */</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">T</span><span class="o">-&gt;</span><span class="n">segment</span><span class="p">[</span><span class="n">seg</span><span class="p">];</span>    <span class="cm">/* Convenient shorthand for current segment */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">S</span><span class="o">-&gt;</span><span class="n">n_rows</span><span class="p">;</span> <span class="n">row</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* For each text record */</span>
      <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;T=%d S=%d R=%d : %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tbl</span><span class="p">,</span> <span class="n">seg</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">S</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">row</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</div>
</div>
<div class="section" id="message-and-verbose-reporting">
<h2>3.9. Message and Verbose Reporting<a class="headerlink" href="#message-and-verbose-reporting" title="Permalink to this headline">¶</a></h2>
<p>The API provides two functions for your program to present information
to the user during the run of the program. One is used for messages that
are always written (optionally with a time stamp) while the other is used
for reports whose verbosity level must exceed the verbosity settings specified via <strong>-V</strong>.</p>
<div class="section" id="verbose-reporting">
<h3>3.9.1. Verbose reporting<a class="headerlink" href="#verbose-reporting" title="Permalink to this headline">¶</a></h3>
<blockquote id="gmt-report">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">GMT_Report</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">,</span> <span class="p">...);</span>
</pre></div>
</div>
</div></blockquote>
<p>This function takes a verbosity level and a multi-part message (e.g., a
format statement and zero or more variables as required by the format string). The verbosity <code class="docutils literal notranslate"><span class="pre">level</span></code> is
an integer in the 0–5 range; these levels are listed in Table <a class="reference internal" href="#tbl-verbosity"><span class="std std-ref">timemodes</span></a>
You assign an appropriate verbosity level to your message, and depending
on the chosen run-time verbosity level set via <strong>-V</strong> your message may
or may not be reported. Only messages whose stated verbosity level is
lower or equal to the <strong>-V</strong><em>level</em> will be printed.  These messages are typically
progress reports, etc., and are sent to standard error.</p>
<blockquote id="tbl-verbosity">
<div><table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">constant</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>GMT_MSG_QUIET</td>
<td>No messages whatsoever</td>
</tr>
<tr class="row-odd"><td>GMT_MSG_NORMAL</td>
<td>Default output, e.g., warnings and errors only</td>
</tr>
<tr class="row-even"><td>GMT_MSG_COMPAT</td>
<td>Compatibility warnings</td>
</tr>
<tr class="row-odd"><td>GMT_MSG_VERBOSE</td>
<td>Verbose level</td>
</tr>
<tr class="row-even"><td>GMT_MSG_LONG_VERBOSE</td>
<td>Longer verbose</td>
</tr>
<tr class="row-odd"><td>GMT_MSG_DEBUG</td>
<td>Debug messages for developers mostly</td>
</tr>
</tbody>
</table>
<p>The different levels of verbosity that can be selected.</p>
</div></blockquote>
</div>
<div class="section" id="user-messages">
<h3>3.9.2. User messages<a class="headerlink" href="#user-messages" title="Permalink to this headline">¶</a></h3>
<p>For custom messages to the user that should always be printed, we use</p>
<blockquote id="gmt-message">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">GMT_Message</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...);</span>
</pre></div>
</div>
</div></blockquote>
<p>This function always prints its message to the standard output. Use the
<code class="docutils literal notranslate"><span class="pre">mode</span></code> value to control if a time stamp should preface the message,
and if selected how the time information should be formatted. See
Table <a class="reference internal" href="#tbl-timemodes"><span class="std std-ref">timemodes</span></a> for the various modes.</p>
<blockquote id="tbl-timemodes">
<div><table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">constant</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>GMT_TIME_NONE</td>
<td>Display no time information</td>
</tr>
<tr class="row-odd"><td>GMT_TIME_CLOCK</td>
<td>Display current local time</td>
</tr>
<tr class="row-even"><td>GMT_TIME_ELAPSED</td>
<td>Display elapsed time since last reset</td>
</tr>
<tr class="row-odd"><td>GMT_TIME_RESET</td>
<td>Reset the elapsed time to 0</td>
</tr>
</tbody>
</table>
<p>The different types of message modes.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="special-gmt-modules">
<h2>3.10. Special GMT modules<a class="headerlink" href="#special-gmt-modules" title="Permalink to this headline">¶</a></h2>
<p>There are some differences between calling
modules on the command line and using them via the API.  These are discussed here.</p>
<div class="section" id="api-only-modules">
<h3>3.10.1. API-only modules<a class="headerlink" href="#api-only-modules" title="Permalink to this headline">¶</a></h3>
<p>There are two general-purpose modules that are not part of the command-line version of
GMT.  These are the read and write modules.  Both take an option to specify what GMT
resource is being read of written: <strong>-Tc</strong>|<strong>d</strong>|<strong>g</strong>|<strong>i</strong>|<strong>p</strong>|<strong>t</strong>,
which selects CPT, dataset, grid, image, PostScript, or textset, respectively.  In addition
both modules accept the <em>infile</em> and <em>outfile</em> argument for source and destination.  These
may be actual files of memory locations, of course.</p>
</div>
<div class="section" id="postscript-access">
<h3>3.10.2. PostScript Access<a class="headerlink" href="#postscript-access" title="Permalink to this headline">¶</a></h3>
<p>The GMT module <a class="reference internal" href="psconvert.html"><span class="doc">psconvert</span></a> is normally given one or more PostScript files that may be
converted to other formats.  When accessed by the API it may also be given the special
file name “=”, which means we are to use the internal PostScript string produced by
the latest GMT plotting instead of any actual file name.  The module can access this
string which must be a complete plot (i.e., it must have header, middle, and trailer
and thus be a valid PostScript file).  This allows the API to convert plots to a
suitable image format without any duplication and manipulation of the PostScript
itself.</p>
</div>
</div>
<div class="section" id="adjusting-headers-and-comments">
<h2>3.11. Adjusting headers and comments<a class="headerlink" href="#adjusting-headers-and-comments" title="Permalink to this headline">¶</a></h2>
<p>All header records in incoming datasets are stored in memory. You may
wish to replace these records with new information, or append new
information to the existing headers. This is achieved with</p>
<blockquote id="gmt-set-comment">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">GMT_Set_Comment</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>Again, <a class="reference internal" href="#tbl-family"><span class="std std-ref">family</span></a> selects which kind of resource is passed via <code class="docutils literal notranslate"><span class="pre">data</span></code>.
The <code class="docutils literal notranslate"><span class="pre">mode</span></code> determines what kind of comment is being considered, how it
should be included, and in what form the comment passed via <code class="docutils literal notranslate"><span class="pre">arg</span></code> is provided.
Table <a class="reference internal" href="#tbl-comments"><span class="std std-ref">comments</span></a> lists the available options, which may be combined
by adding (bitwise “or”). The <a class="reference internal" href="#gmt-set-comment">GMT_Set_Comment</a> function does not actually
output anything but sets the relevant comment and header records in the
relevant structure. When a file is written out the information will be
output as well (Note: Users can always decide if they wish to turn
header output on or off via the common GMT option <code class="docutils literal notranslate"><span class="pre">-h</span></code>. For
record-by-record writing you must enable the header block output when
you call <a class="reference internal" href="#gmt-begin-io">GMT_Begin_IO</a>.</p>
<blockquote id="tbl-comments">
<div><table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">constant</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>GMT_COMMENT_IS_TEXT</td>
<td>Comment is a text string</td>
</tr>
<tr class="row-odd"><td>GMT_COMMENT_IS_OPTION</td>
<td>Comment is a linked list of GMT_OPTION structures</td>
</tr>
<tr class="row-even"><td>GMT_COMMENT_IS_COMMAND</td>
<td>Comment is the command</td>
</tr>
<tr class="row-odd"><td>GMT_COMMENT_IS_REMARK</td>
<td>Comment is the remark</td>
</tr>
<tr class="row-even"><td>GMT_COMMENT_IS_TITLE</td>
<td>Comment is the title</td>
</tr>
<tr class="row-odd"><td>GMT_COMMENT_IS_NAME_X</td>
<td>Comment is the x variable name (grids only)</td>
</tr>
<tr class="row-even"><td>GMT_COMMENT_IS_NAME_Y</td>
<td>Comment is the y variable name (grids only)</td>
</tr>
<tr class="row-odd"><td>GMT_COMMENT_IS_NAME_Z</td>
<td>Comment is the z variable name (grids only)</td>
</tr>
<tr class="row-even"><td>GMT_COMMENT_IS_COLNAMES</td>
<td>Comment is the column names header</td>
</tr>
<tr class="row-odd"><td>GMT_COMMENT_IS_RESET</td>
<td>Comment replaces existing information</td>
</tr>
</tbody>
</table>
<p>The modes for setting various comment types.</p>
</div></blockquote>
<p>The named modes (<em>command</em>, <em>remark</em>, <em>title</em>, <em>name_x,y,z</em> and
<em>colnames</em> are used to distinguish regular text comments from specific
fields in the header structures of the data resources, such as
<a class="reference internal" href="#struct-grid"><span class="std std-ref">GMT_GRID</span></a>. For the various table resources (e.g., <a class="reference internal" href="#struct-dataset"><span class="std std-ref">GMT_DATASET</span></a>)
these modifiers result in a specially formatted comments beginning with
“Command: ” or “Remark: “, reflecting how this type of information is
encoded in the headers.</p>
</div>
<div class="section" id="export-data-sets">
<h2>3.12. Export Data Sets<a class="headerlink" href="#export-data-sets" title="Permalink to this headline">¶</a></h2>
<p>If your program needs to write any of the six recognized data types
(CPTs, data tables, text tables, grids, images, or PostScript) you can use the
<a class="reference internal" href="#gmt-write-data">GMT_Write_Data</a> function.</p>
<p>Both of these output functions takes a parameter called <code class="docutils literal notranslate"><span class="pre">mode</span></code>. The
<code class="docutils literal notranslate"><span class="pre">mode</span></code> parameter generally takes on different meanings for the
different data types and will be discussed below. However, one bit
setting is common to all types: By default, you are only allowed to
write a data resource once; the resource is then flagged to have been
written and subsequent attempts to write to the same resource will
quietly be ignored. In the unlikely event you need to re-write a
resource you can override this default behavior by adding <code class="docutils literal notranslate"><span class="pre">GMT_IO_RESET</span></code>
to your <code class="docutils literal notranslate"><span class="pre">mode</span></code> parameter.</p>
<div class="section" id="exporting-a-data-set">
<h3>3.12.1. Exporting a data set<a class="headerlink" href="#exporting-a-data-set" title="Permalink to this headline">¶</a></h3>
<p>To have your program accept results from GMT modules and write them
separately requires you to use the <a class="reference internal" href="#gmt-write-data">GMT_Write_Data</a> function. It is very similar to the
<a class="reference internal" href="#gmt-read-data">GMT_Read_Data</a> function encountered earlier.</p>
<div class="section" id="exporting-a-data-set-to-a-file-stream-or-handle">
<h4>3.12.1.1. Exporting a data set to a file, stream, or handle<a class="headerlink" href="#exporting-a-data-set-to-a-file-stream-or-handle" title="Permalink to this headline">¶</a></h4>
<p>The prototype for writing to a file (via name, stream, or file handle) is</p>
<blockquote id="gmt-write-data">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">GMT_Write_Data</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">method</span><span class="p">,</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">geometry</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">double</span> <span class="n">wesn</span><span class="p">[],</span> <span class="kt">void</span> <span class="o">*</span><span class="n">output</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<ul class="simple">
<li><a class="reference internal" href="#gmt-create-session"><span class="std std-ref">API</span></a></li>
<li><a class="reference internal" href="#tbl-family"><span class="std std-ref">family</span></a></li>
<li><a class="reference internal" href="#tbl-methods"><span class="std std-ref">method</span></a></li>
<li><a class="reference internal" href="#tbl-geometry"><span class="std std-ref">geometry</span></a></li>
<li>mode -- specific to each data type (<em>see below</em>)</li>
<li><a class="reference internal" href="#tbl-wesn"><span class="std std-ref">wesn</span></a></li>
<li>output --</li>
<li>data -- A pointer to any of the six families.</li>
<li>Return: 0 on success, otherwise return -1 and set API-&gt;error to reflect to cause.</li>
</ul>
<p>where <code class="docutils literal notranslate"><span class="pre">data</span></code> is a pointer to any of the four structures discussed previously.</p>
<dl class="docutils">
<dt><strong>Color palette table</strong></dt>
<dd><code class="docutils literal notranslate"><span class="pre">mode</span></code> controls if the CPT’s back-, fore-, and NaN-colors
should be written (1) or not (0).</dd>
<dt><strong>Data table</strong></dt>
<dd><p class="first">If <code class="docutils literal notranslate"><span class="pre">method</span></code> is <code class="docutils literal notranslate"><span class="pre">GMT_IS_FILE</span></code>, then the value of <code class="docutils literal notranslate"><span class="pre">mode</span></code> affects
how the data set is written:</p>
<dl class="last docutils">
<dt><strong>GMT_WRITE_SET</strong></dt>
<dd>The entire data set will be written to the single file [0].</dd>
<dt><strong>GMT_WRITE_TABLE</strong></dt>
<dd>Each table in the data set is written to individual files [1].
You can either specify an output file name that <em>must</em> contain
one C-style format specifier for a int variable (e.g.,
“New_Table_%06d.txt”), which will be replaced with the table
number (a running number from 0) <em>or</em> you must assign to each
table <em>i</em> a unique output file name via the
<code class="docutils literal notranslate"><span class="pre">D-&gt;table[i]-&gt;file[GMT_OUT]</span></code> variables prior to calling the
function.</dd>
<dt><strong>GMT_WRITE_SEGMENT</strong></dt>
<dd>Each segment in the data set is written to an individual file
[2]. Same setup as for <code class="docutils literal notranslate"><span class="pre">GMT_WRITE_TABLE</span></code> except we use
sequential segment numbers to build the file names.</dd>
<dt><strong>GMT_WRITE_TABLE_SEGMENT</strong></dt>
<dd>Each segment in the data set is written to an individual file
[3]. You can either specify an output file name that <em>must</em>
contain two C-style format specifiers for two int variables
(e.g., “New_Table_%06d_Segment_%03d.txt”), which will be
replaced with the table and segment numbers, <em>or</em> you must
assign to each segment <em>j</em> in each table <em>i</em> a unique output
file name via the <code class="docutils literal notranslate"><span class="pre">D-&gt;table[i]-&gt;segment[j]-&gt;file[GMT_OUT]</span></code>
variables prior to calling the function.</dd>
<dt><strong>GMT_WRITE_OGR</strong></dt>
<dd>Writes the dataset in OGR/GMT format in conjunction with the
<code class="docutils literal notranslate"><span class="pre">-a</span></code> setting [4].</dd>
</dl>
</dd>
<dt><strong>Text table</strong></dt>
<dd>The <code class="docutils literal notranslate"><span class="pre">mode</span></code> is used the same way as for data tables.</dd>
<dt><strong>GMT grid</strong></dt>
<dd>Here, <code class="docutils literal notranslate"><span class="pre">mode</span></code> may be <code class="docutils literal notranslate"><span class="pre">GMT_CONTAINER_ONLY</span></code> to only update a
file’s header structure, but normally it is simply <code class="docutils literal notranslate"><span class="pre">GMT_CONTAINER_AND_DATA</span></code>
so the entire grid and its header will be exported (a subset is
not allowed during export). However, in the event your data array
holds both the real and imaginary parts of a complex data set you
must add either <code class="docutils literal notranslate"><span class="pre">GMT_GRID_IS_COMPLEX_REAL</span></code> or
<code class="docutils literal notranslate"><span class="pre">GMT_GRID_IS_COMPLEX_IMAG</span></code> to <code class="docutils literal notranslate"><span class="pre">mode</span></code> so as to export the
corresponding grid values correctly. Finally, for native binary
grids you may skip writing the grid header by adding
<code class="docutils literal notranslate"><span class="pre">GMT_GRID_NO_HEADER</span></code>; this setting is ignored for all other grid
formats. If your output grid is huge and you are building it
row-by-row, set <code class="docutils literal notranslate"><span class="pre">mode</span></code> to <code class="docutils literal notranslate"><span class="pre">GMT_CONTAINER_ONLY</span></code> |
<code class="docutils literal notranslate"><span class="pre">GMT_GRID_ROW_BY_ROW</span></code>. You can then write the grid row-by-row
using <a class="reference internal" href="#gmt-put-row">GMT_Put_Row</a>. By default the rows will be automatically
processed in order. To completely specify which row to be written,
use <code class="docutils literal notranslate"><span class="pre">GMT_GRID_ROW_BY_ROW_MANUAL</span></code> instead; this requires a file format
that supports direct writes, such as netCDF.  Finally, if you are
preparing a geographic grid outside of GMT you need to add the mode
<code class="docutils literal notranslate"><span class="pre">GMT_GRID_IS_GEO</span></code> to ensure that the proper metadata will be written
to the netCDF header, thus letting the grid be recognized as such.</dd>
</dl>
<p>Note: If <code class="docutils literal notranslate"><span class="pre">method</span></code> is GMT_IS_FILE, <a class="reference internal" href="#tbl-family"><span class="std std-ref">family</span></a> is <code class="docutils literal notranslate"><span class="pre">GMT_IS_GRID</span></code>,
and the filename implies a change from NaN to another value then the grid is
modified accordingly. If you continue to use that grid after writing please be
aware that the changes you specified were applied to the grid.</p>
</div>
</div>
</div>
<div class="section" id="record-by-record-output">
<h2>3.13. Record-by-record output<a class="headerlink" href="#record-by-record-output" title="Permalink to this headline">¶</a></h2>
<p>In the case of data and text tables, you may also
consider the <a class="reference internal" href="#gmt-put-record">GMT_Put_Record</a> function for record-by-record writing. As a general rule, your
program organization may simplify if you can write the entire
resource with <a class="reference internal" href="#gmt-write-data">GMT_Write_Data</a>. However, if the program logic is simple
or already involves using <a class="reference internal" href="#gmt-get-record">GMT_Get_Record</a>, it may be better to export
one data record at the time via <a class="reference internal" href="#gmt-put-record">GMT_Put_Record</a>.  For grids there is the
corresponding <a class="reference internal" href="#gmt-put-row">GMT_Put_Row</a> function.</p>
<div class="section" id="enable-data-export">
<h3>3.13.1. Enable Data Export<a class="headerlink" href="#enable-data-export" title="Permalink to this headline">¶</a></h3>
<p>Similar to the data import procedures, once all output destinations have
been registered, we signal the API that we are done with the
registration phase and are ready to start the actual data export. As for
input, this step is only needed when dealing with record-by-record
writing. Again, we enable record-by-record writing by calling
<a class="reference internal" href="#gmt-begin-io">GMT_Begin_IO</a>, this time with <code class="docutils literal notranslate"><span class="pre">direction</span></code> = <code class="docutils literal notranslate"><span class="pre">GMT_OUT</span></code>. This function
enables data export and prepares the registered destinations for the
upcoming writing.</p>
<div class="section" id="specifying-the-number-of-output-columns">
<h4>3.13.1.1. Specifying the number of output columns<a class="headerlink" href="#specifying-the-number-of-output-columns" title="Permalink to this headline">¶</a></h4>
<p>For record-based input/output you will need to specify the number of output
columns, unless it equals the number of input columns.  This is done with
the <a class="reference internal" href="#gmt-set-columns">GMT_Set_Columns</a> function:</p>
<blockquote id="gmt-set-columns">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="o">*</span><span class="nf">GMT_Set_Columns</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n_columns</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">n_columns</span></code> is a number related to the number of output columns you plan to write, while
<code class="docutils literal notranslate"><span class="pre">mode</span></code> controls what that number means.  Here, <code class="docutils literal notranslate"><span class="pre">mode</span></code> = <code class="docutils literal notranslate"><span class="pre">GMT_COL_FIX</span></code> means it is the actual
number of output columns,  <code class="docutils literal notranslate"><span class="pre">mode</span></code> = <code class="docutils literal notranslate"><span class="pre">GMT_COL_ADD</span></code> means it should be added to the known number
of input columns to arrive at the number of final output columns, while <code class="docutils literal notranslate"><span class="pre">mode</span></code> = <code class="docutils literal notranslate"><span class="pre">GMT_COL_SUB</span></code>
means this value should be subtracted from the number of input columns to find the number of
output columns.</p>
</div>
</div>
<div class="section" id="exporting-a-data-record">
<h3>3.13.2. Exporting a data record<a class="headerlink" href="#exporting-a-data-record" title="Permalink to this headline">¶</a></h3>
<p>If your program must write data table records one-by-one you must first
enable record-by-record writing with <a class="reference internal" href="#gmt-begin-io">GMT_Begin_IO</a> and then use the
<code class="docutils literal notranslate"><span class="pre">GMT_Put_Record</span></code> function in a loop; the prototype is</p>
<blockquote id="gmt-put-record">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">GMT_Put_Record</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">rec</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>where <code class="docutils literal notranslate"><span class="pre">rec</span></code> is a pointer to either (a) a double-precision array with
the current row. Then, <code class="docutils literal notranslate"><span class="pre">rec</span></code> is expected to hold at least as many
items as the current output column setting, which represents the
number of columns in the output destination. Alternatively (b), <code class="docutils literal notranslate"><span class="pre">rec</span></code>
points to a text string. The <code class="docutils literal notranslate"><span class="pre">mode</span></code> parameter must be set to reflect
what is passed. Using <a class="reference internal" href="#gmt-put-record">GMT_Put_Record</a> requires you to first
initialize the destination with <a class="reference internal" href="#gmt-init-io">GMT_Init_IO</a>. Note that for families
<code class="docutils literal notranslate"><span class="pre">GMT_IS_DATASET</span></code> and <code class="docutils literal notranslate"><span class="pre">GMT_IS_TEXTSET</span></code> the methods <code class="docutils literal notranslate"><span class="pre">GMT_IS_DUPLICATE</span></code> and
<code class="docutils literal notranslate"><span class="pre">GMT_IS_REFERENCE</span></code> are not supported since you can simply populate the
<a class="reference internal" href="#struct-dataset"><span class="std std-ref">GMT_DATASET</span></a> structure directly. As mentioned, <code class="docutils literal notranslate"><span class="pre">mode</span></code> affects what is
actually written:</p>
<dl class="docutils">
<dt><strong>GMT_WRITE_DATA</strong>.</dt>
<dd>Normal operation that builds the current output record from the numerical values in <code class="docutils literal notranslate"><span class="pre">rec</span></code>.</dd>
<dt><strong>GMT_WRITE_TEXT</strong>.</dt>
<dd>For ASCII output mode we write the text string <code class="docutils literal notranslate"><span class="pre">rec</span></code>. If <code class="docutils literal notranslate"><span class="pre">rec</span></code>
is NULL then we use the current (last imported) text record. If
binary output mode we quietly skip writing this record.</dd>
<dt><strong>GMT_WRITE_TABLE_HEADER</strong>.</dt>
<dd>For ASCII output mode we write the text string <code class="docutils literal notranslate"><span class="pre">rec</span></code>. If <code class="docutils literal notranslate"><span class="pre">rec</span></code>
is NULL then we write the last read header record (and ensures it
starts with #). If binary output mode we quietly skip writing this record.</dd>
<dt><strong>GMT_WRITE_SEGMENT_HEADER</strong>.</dt>
<dd>For ASCII output mode we use the text string <code class="docutils literal notranslate"><span class="pre">rec</span></code> as the
segment header. If <code class="docutils literal notranslate"><span class="pre">rec</span></code> is NULL then we use the current (last
read) segment header record. If binary output mode instead we write
a record composed of NaNs.</dd>
</dl>
<p>The function returns 1 if there was an error associated with the
writing (which is passed back with <code class="docutils literal notranslate"><span class="pre">API-&gt;error</span></code>), otherwise it returns
0 (<code class="docutils literal notranslate"><span class="pre">GMT_NOERROR</span></code>).</p>
</div>
<div class="section" id="exporting-a-grid-row">
<h3>3.13.3. Exporting a grid row<a class="headerlink" href="#exporting-a-grid-row" title="Permalink to this headline">¶</a></h3>
<p>If your program must write a grid file row-by-row you must first enable
row-by-row writing with <a class="reference internal" href="#gmt-read-data">GMT_Read_Data</a> and then use the
<a class="reference internal" href="#gmt-put-row">GMT_Put_Row</a> function in a loop; the prototype is</p>
<blockquote id="gmt-put-row">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">GMT_Put_Row</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="kt">int</span> <span class="n">row_no</span><span class="p">,</span> <span class="k">struct</span> <span class="n">GMT_GRID</span> <span class="o">*</span><span class="n">G</span><span class="p">,</span> <span class="kt">float</span> <span class="o">*</span><span class="n">row</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>where <code class="docutils literal notranslate"><span class="pre">row</span></code> is a pointer to a single-precision array with the current
row, <code class="docutils literal notranslate"><span class="pre">G</span></code> is the grid in question, and <code class="docutils literal notranslate"><span class="pre">row_no</span></code> is the number of the
current row to be written. Note this value is only considered if the
row-by-row mode was initialized with <code class="docutils literal notranslate"><span class="pre">GMT_GRID_ROW_BY_ROW_MANUAL</span></code>.</p>
</div>
<div class="section" id="disable-data-export">
<h3>3.13.4. Disable Data Export<a class="headerlink" href="#disable-data-export" title="Permalink to this headline">¶</a></h3>
<p>Once the record-by-record output has completed we disable further output
to prevent accidental writing from occurring (due to poor program
structure, bugs, etc.). We do so by calling <a class="reference internal" href="#gmt-end-io">GMT_End_IO</a>. This
function disables further record-by-record data export; here, we
obviously pass <code class="docutils literal notranslate"><span class="pre">direction</span></code> as <code class="docutils literal notranslate"><span class="pre">GMT_OUT</span></code>.</p>
</div>
</div>
<div class="section" id="destroy-allocated-resources">
<h2>3.14. Destroy allocated resources<a class="headerlink" href="#destroy-allocated-resources" title="Permalink to this headline">¶</a></h2>
<p>If your session imported any data sets into memory then you may
explicitly free this memory once it is no longer needed and before
terminating the session. This is done with the <a class="reference internal" href="#gmt-destroy-data">GMT_Destroy_Data</a>
function, whose prototype is</p>
<blockquote id="gmt-destroy-data">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">GMT_Destroy_Data</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>where <code class="docutils literal notranslate"><span class="pre">data</span></code> is the address of the pointer to a data container, i.e., not
the pointer to the container but the <em>address</em> of that pointer (e.g. &amp;pointer).  Note that
when each module completes it will automatically free memory created by
the API; similarly, when the session is destroyed we also automatically
free up memory. Thus, <code class="docutils literal notranslate"><span class="pre">GMT_Destroy_Data</span></code> is therefore generally only
needed when you wish to directly free up memory to avoid running out of
it. The function returns 1 if there is an error when trying to
free the memory (the error code is passed back with <code class="docutils literal notranslate"><span class="pre">API-&gt;error</span></code>),
otherwise it returns 0 (<code class="docutils literal notranslate"><span class="pre">GMT_NOERROR</span></code>).</p>
</div>
<div class="section" id="destroy-groups-of-allocated-resources">
<h2>3.15. Destroy groups of allocated resources<a class="headerlink" href="#destroy-groups-of-allocated-resources" title="Permalink to this headline">¶</a></h2>
<p>If you obtained an array of resources via <a class="reference internal" href="#gmt-read-group">GMT_Read_Group</a> then
you will need to destroy these resources with <a class="reference internal" href="#gmt-destroy-group">GMT_Destroy_Group</a> instead,
whose prototype is</p>
<blockquote id="gmt-destroy-group">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">GMT_Destroy_Group</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>where <code class="docutils literal notranslate"><span class="pre">data</span></code> is the address of the array with data containers, i.e., not
the array to the containers but the <em>address</em> of that array (e.g. &amp;array),
and <code class="docutils literal notranslate"><span class="pre">n</span></code> is the number of containers.</p>
</div>
<div class="section" id="terminate-a-gmt-session">
<h2>3.16. Terminate a GMT session<a class="headerlink" href="#terminate-a-gmt-session" title="Permalink to this headline">¶</a></h2>
<p>Before your program exits it should properly terminate the
GMT session, which involves a call to</p>
<blockquote id="gmt-destroy-session">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">GMT_Destroy_Session</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>which simply takes the pointer to the GMT API control structure as its
only arguments. It terminates the GMT machinery and deallocates all
memory used by the GMT API book-keeping. It also unregisters any
remaining resources previously registered with the session. The
GMT API will only close files that it was responsible for opening in
the first place. Finally, the API structure itself is freed so your main
program does not need to do so. The function returns 1 if there
is an error when trying to free the memory (the error code is passed
back with <code class="docutils literal notranslate"><span class="pre">API-&gt;error</span></code>), otherwise it returns 0 (<code class="docutils literal notranslate"><span class="pre">GMT_NOERROR</span></code>).</p>
</div>
<div class="section" id="presenting-and-accessing-gmt-options">
<span id="sec-parsopt"></span><h2>3.17. Presenting and accessing GMT options<a class="headerlink" href="#presenting-and-accessing-gmt-options" title="Permalink to this headline">¶</a></h2>
<p>As you develop a program you may wish to rely on some of
the GMT common options. For instance, you may wish to have your
program present the <code class="docutils literal notranslate"><span class="pre">-R</span></code> option to the user, let GMT handle the
parsing, and examine the values. You may also wish to encode your own
custom options that may require you to parse user text into the
corresponding floating point dimensions, constants, coordinates, absolute time, etc.
The API provides several functions to simplify these tedious parsing
tasks. This section is intended to show how the programmer will obtain
information from the user that is necessary to do the task at hand
(e.g., special options to provide values and settings for the program).
In the following section we will concern ourselves with preparing
arguments for calling any of the GMT modules.</p>
<div class="section" id="display-usage-syntax-for-gmt-common-options">
<h3>3.17.1. Display usage syntax for GMT common options<a class="headerlink" href="#display-usage-syntax-for-gmt-common-options" title="Permalink to this headline">¶</a></h3>
<p>You can have your program menu display the standard usage message for a
GMT common option by calling the function</p>
<blockquote id="gmt-option">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">GMT_Option</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">options</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>where <code class="docutils literal notranslate"><span class="pre">options</span></code> is a comma-separated list of GMT common options
(e.g., “R,J,O,X”). You can repeat this function with different sets of
options in order to intersperse your own custom options within an
overall alphabetical order; see any GMT module for examples of typical
layouts.</p>
</div>
<div class="section" id="parsing-the-gmt-common-options">
<h3>3.17.2. Parsing the GMT common options<a class="headerlink" href="#parsing-the-gmt-common-options" title="Permalink to this headline">¶</a></h3>
<p>The parsing of all GMT common option is done by on call to</p>
<blockquote id="gmt-parse-common">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">GMT_Parse_Common</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="k">struct</span> <span class="n">GMT_OPTION</span> <span class="o">*</span><span class="n">list</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>where <code class="docutils literal notranslate"><span class="pre">args</span></code> is a string of the common GMT options your program is allowed to use.
An error will be reported if any of the common GMT options fail
to parse, and if so we return 1; if no errors we return 0. All
other options, including file names, will be silently ignored. The
parsing will update the internal GMT information structure that
affects module operations.</p>
</div>
<div class="section" id="inquiring-about-the-gmt-common-options">
<h3>3.17.3. Inquiring about the GMT common options<a class="headerlink" href="#inquiring-about-the-gmt-common-options" title="Permalink to this headline">¶</a></h3>
<p>The API provide only a limited window into the full GMT machinery
accessible to the modules. You can determine if a particular common
option has been parsed and in some cases determine the values that were set with</p>
<blockquote id="gmt-get-common">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">GMT_Get_Common</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">option</span><span class="p">,</span> <span class="kt">double</span> <span class="o">*</span><span class="n">par</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>where <code class="docutils literal notranslate"><span class="pre">option</span></code> is a single option character (e.g., ‘R’) and <code class="docutils literal notranslate"><span class="pre">par</span></code> is
a double array with at least a length of 6. If the particular option has
been parsed then the function returns the number of parameters passed
back via <code class="docutils literal notranslate"><span class="pre">par</span></code>; otherwise we return -1. For instance, to determine if
the <code class="docutils literal notranslate"><span class="pre">-R</span></code> was set and to obtain the specified region you may call</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">GMT_Get_Common</span> <span class="p">(</span><span class="n">API</span><span class="p">,</span> <span class="sc">&#39;R&#39;</span><span class="p">,</span> <span class="n">wesn</span><span class="p">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* wesn now contains the boundary information */</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">wesn</span></code> array could now be passed to the various read and create
functions for GMT resources.</p>
</div>
<div class="section" id="parsing-text-values">
<h3>3.17.4. Parsing text values<a class="headerlink" href="#parsing-text-values" title="Permalink to this headline">¶</a></h3>
<p>Your program may need to request values from the user, such as
distances, plot dimensions, coordinates, date/time strings and other data. The conversion
from such text to actual distances, taking units into account, is
tedious to program. You can simplify this by using</p>
<blockquote id="gmt-get-values">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">GMT_Get_Values</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">double</span> <span class="n">par</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">maxpar</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>where <code class="docutils literal notranslate"><span class="pre">arg</span></code> is the text item with one or more values that are
separated by commas, spaces, tabs, semi-colons, or slashes, and <code class="docutils literal notranslate"><span class="pre">par</span></code> is an array of length <code class="docutils literal notranslate"><span class="pre">maxpar</span></code> long
enough to hold all the items you are parsing. The function returns the
number of items parsed with a maximum of <code class="docutils literal notranslate"><span class="pre">maxpar</span></code>, or -1 if there is an error. For instance, assume
the character string <code class="docutils literal notranslate"><span class="pre">origin</span></code> was given by the user as two geographic
coordinates separated by a slash (e.g., <code class="docutils literal notranslate"><span class="pre">&quot;35:45W/19:30:55.3S&quot;</span></code>). We
obtain the two coordinates in decimal degrees by calling</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="n">GMT_Get_Values</span> <span class="p">(</span><span class="n">API</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>Your program can now check that <code class="docutils literal notranslate"><span class="pre">n</span></code> equals 2 and then use the values
in <code class="docutils literal notranslate"><span class="pre">pairs</span></code> separately. Note: Dimensions given with units of inches, cm, or points
are converted to the current default unit set via <a class="reference internal" href="gmt.conf.html#proj-length-unit"><span class="std std-ref">PROJ_LENGTH_UNIT</span></a>,
while distances given in km, nautical miles, miles, feet, or
survey feet are returned in meters. Arc lengths in minutes and seconds
are returned in decimal degrees, and date/time values are returned in
seconds since the current epoch [1970].</p>
</div>
<div class="section" id="get-or-set-an-api-or-gmt-default-parameter">
<h3>3.17.5. Get or set an API or GMT default parameter<a class="headerlink" href="#get-or-set-an-api-or-gmt-default-parameter" title="Permalink to this headline">¶</a></h3>
<p>If your program needs to determine one or more of the current
API or GMT default settings you can do so via</p>
<blockquote id="gmt-get-default">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">GMT_Get_Default</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">keyword</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">value</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>where <code class="docutils literal notranslate"><span class="pre">keyword</span></code> is one such keyword (e.g., <a class="reference internal" href="gmt.conf.html#proj-length-unit"><span class="std std-ref">PROJ_LENGTH_UNIT</span></a>) and
<code class="docutils literal notranslate"><span class="pre">value</span></code> must be a character string long enough to hold the answer.  In
addition to the long list of GMT defaults you can also inquire about the
API parameters <code class="docutils literal notranslate"><span class="pre">API_PAD</span></code> (the current pad setting), <code class="docutils literal notranslate"><span class="pre">API_IMAGE_LAYOUT</span></code> (the
order and structure of image memory storage), <code class="docutils literal notranslate"><span class="pre">API_GRID_LAYOUT</span></code> (order of
grid memory storage), <code class="docutils literal notranslate"><span class="pre">API_VERSION</span></code> (the API version string),
<code class="docutils literal notranslate"><span class="pre">API_CORES</span></code> (the number of cores seen by the API),
<code class="docutils literal notranslate"><span class="pre">API_BINDIR</span></code> (the API (GMT) executable path),
<code class="docutils literal notranslate"><span class="pre">API_SHAREDIR</span></code> (the API (GMT) shared directory path),
<code class="docutils literal notranslate"><span class="pre">API_DATADIR</span></code> (the API (GMT) data directory path), and
<code class="docutils literal notranslate"><span class="pre">API_PLUGINDIR</span></code> (the API (GMT) plugin path).
Depending on what parameter you selected you could further convert it to
a numerical value with <a class="reference internal" href="#gmt-get-values">GMT_Get_Values</a> or just use it in a text comparison.</p>
<p>To change any of the API or
GMT default settings programmatically you would use</p>
<blockquote id="gmt-set-default">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">GMT_Set_Default</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">keyword</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">value</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>where as before <code class="docutils literal notranslate"><span class="pre">keyword</span></code> is one such keyword (e.g., <a class="reference internal" href="gmt.conf.html#proj-length-unit"><span class="std std-ref">PROJ_LENGTH_UNIT</span></a>) and
<code class="docutils literal notranslate"><span class="pre">value</span></code> must be a character string with the new setting.
Note that all settings must be passed as text strings even if many are
inherently integers or floats.</p>
<p>For indexed access to custom grids and images we may need to know the internal matrix layout.
You can change this information via</p>
<blockquote id="gmt-set-index">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int64_t</span> <span class="nf">GMT_Set_Index</span> <span class="p">(</span><span class="k">struct</span> <span class="n">GMT_GRID_HEADER</span> <span class="o">*</span><span class="n">header</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">code</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>where the <code class="docutils literal notranslate"><span class="pre">header</span></code> is the header of either a grid or image, and <code class="docutils literal notranslate"><span class="pre">code</span></code> is a three-character
code indication …</p>
</div>
</div>
<div class="section" id="call-a-module">
<span id="sec-func"></span><h2>3.18. Call a module<a class="headerlink" href="#call-a-module" title="Permalink to this headline">¶</a></h2>
<p>One of the advantages of programming with the API is that you
have access to the high-level GMT modules. For example, if your
program must compute the distance from a node to all other nodes in the grid
then you can simply set up options and call <a class="reference internal" href="grdmath.html"><span class="doc">grdmath</span></a> to do it
for you and accept the result back as an input grid. All the module
interfaces are identical and are called via</p>
<blockquote id="gmt-call-module">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">GMT_Call_Module</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">module</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>Here, <code class="docutils literal notranslate"><span class="pre">module</span></code> is the name of any of the GMT modules, such as
<a class="reference internal" href="psxy.html"><span class="doc">psxy</span></a> or <a class="reference internal" href="grdvolume.html"><span class="doc">grdvolume</span></a>.  All GMT modules may be called with one of
three sets of <code class="docutils literal notranslate"><span class="pre">args</span></code> depending on <code class="docutils literal notranslate"><span class="pre">mode</span></code>. The three modes differ in
how the options are passed to the module:</p>
<blockquote>
<div><dl class="docutils">
<dt><em>mode</em> = <code class="docutils literal notranslate"><span class="pre">GMT_MODULE_EXIST</span></code>.</dt>
<dd>Return GMT_NOERROR (0) if the module exists, nonzero otherwise.</dd>
<dt><em>mode</em> = <code class="docutils literal notranslate"><span class="pre">GMT_MODULE_PURPOSE</span></code>.</dt>
<dd>Just print the one-line purpose of the module; args must be NULL.</dd>
<dt><em>mode</em> = <code class="docutils literal notranslate"><span class="pre">GMT_MODULE_LIST</span></code>.</dt>
<dd>Just prints a list of all modules (including those given as plugins); args must be NULL.</dd>
<dt><em>mode</em> = <code class="docutils literal notranslate"><span class="pre">GMT_MODULE_OPT</span></code>.</dt>
<dd>Expects <code class="docutils literal notranslate"><span class="pre">args</span></code> to be a pointer to a doubly-linked list of objects with individual
options for the current program. We will see
how API functions can help prepare and maintain such lists.</dd>
<dt><em>mode</em> = <code class="docutils literal notranslate"><span class="pre">GMT_MODULE_CMD</span></code>.</dt>
<dd>Expects <code class="docutils literal notranslate"><span class="pre">args</span></code> to be a single text string with all needed options.</dd>
<dt><em>mode &gt; 0</em>.</dt>
<dd>Expects <code class="docutils literal notranslate"><span class="pre">args</span></code> to be an array of text strings and <code class="docutils literal notranslate"><span class="pre">mode</span></code> to be a count of how many
options are passed (i.e., the <code class="docutils literal notranslate"><span class="pre">argc,</span> <span class="pre">argv[]</span></code> model used by the GMT programs themselves).</dd>
</dl>
</div></blockquote>
<div class="section" id="set-program-options-via-text-array-arguments">
<h3>3.18.1. Set program options via text array arguments<a class="headerlink" href="#set-program-options-via-text-array-arguments" title="Permalink to this headline">¶</a></h3>
<p>When <code class="docutils literal notranslate"><span class="pre">mode</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> we expect an array <code class="docutils literal notranslate"><span class="pre">args</span></code> of character
strings that each holds a single command line option (e.g.,
“-R120:30/134:45/8S/3N”) and interpret <code class="docutils literal notranslate"><span class="pre">mode</span></code> to be the count of how
many options are passed. This, of course, is almost exactly how the
stand-alone GMT programs are called (and reflects how they themselves
are activated internally). We call this the “argc-argv” mode. Depending
on how your program obtains the necessary options you may find that this
interface offers all you need.</p>
</div>
<div class="section" id="set-program-options-via-text-command">
<h3>3.18.2. Set program options via text command<a class="headerlink" href="#set-program-options-via-text-command" title="Permalink to this headline">¶</a></h3>
<p>If <code class="docutils literal notranslate"><span class="pre">mode</span> <span class="pre">=</span></code> 0 then <code class="docutils literal notranslate"><span class="pre">args</span></code> will be examined to see if it contains
several options within a single command string. If so we will break
these into separate options. This is useful if you wish to pass a single
string such as “-R120:30/134:45/8S/3N -JM6i mydata.txt -Sc0.2c”. We call
this the “command” mode and it is extensively used by the modules themselves.</p>
</div>
<div class="section" id="set-program-options-via-linked-structures">
<h3>3.18.3. Set program options via linked structures<a class="headerlink" href="#set-program-options-via-linked-structures" title="Permalink to this headline">¶</a></h3>
<p>The third, linked-list interface allows developers using higher-level
programming languages to pass all command options via a pointer to a
NULL-terminated, doubly-linked list of option structures, each
containing information about a single option. Here, instead of text
arguments we pass the pointer to the linked list of options mentioned
above, and <code class="docutils literal notranslate"><span class="pre">mode</span></code> must be passed as <code class="docutils literal notranslate"><span class="pre">GMT_MODULE_OPT</span></code>. Using
this interface can be more involved since you need to generate the
linked list of program options; however, utility functions exist to
simplify its use. This interface is intended for programs whose internal
workings are better suited to generate such arguments -- we call this the
“options” mode. The order in the list is not important as GMT will
sort it internally according to need. The option structure is defined below.</p>
<blockquote id="options">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">GMT_OPTION</span> <span class="p">{</span>
    <span class="kt">char</span>               <span class="n">option</span><span class="p">;</span>  <span class="cm">/* Single option character (e.g., &#39;G&#39; for -G) */</span>
    <span class="kt">char</span>              <span class="o">*</span><span class="n">arg</span><span class="p">;</span>     <span class="cm">/* String with arguments (NULL if not used) */</span>
    <span class="k">struct</span> <span class="n">GMT_OPTION</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>    <span class="cm">/* Next option pointer (NULL for last option) */</span>
    <span class="k">struct</span> <span class="n">GMT_OPTION</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>    <span class="cm">/* Previous option (NULL for first option) */</span>
<span class="p">};</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="convert-between-text-and-linked-structures">
<h3>3.18.4. Convert between text and linked structures<a class="headerlink" href="#convert-between-text-and-linked-structures" title="Permalink to this headline">¶</a></h3>
<p>To assist programmers there are also two convenience functions that
allow you to convert between the two argument formats. They are</p>
<blockquote id="gmt-create-options">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">GMT_OPTION</span> <span class="o">*</span><span class="nf">GMT_Create_Options</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>This function accepts your array of text arguments (cast via a void
pointer), allocates the necessary space, performs the conversion, and
returns a pointer to the head of the linked list of program options.
However, in case of an error we return a NULL pointer and set
<code class="docutils literal notranslate"><span class="pre">API-&gt;error</span></code> to indicate the nature of the problem. Otherwise, the
pointer may now be passed to the relevant GMT module. Note that if
your list of text arguments were obtained from a C <code class="docutils literal notranslate"><span class="pre">main()</span></code> function
then <code class="docutils literal notranslate"><span class="pre">argv[0]</span></code> will contain the name of the calling program. To avoid
passing this as a bad file name option, call <a class="reference internal" href="#gmt-create-options">GMT_Create_Options</a> with
<code class="docutils literal notranslate"><span class="pre">argc-1</span></code> and <code class="docutils literal notranslate"><span class="pre">argv+1</span></code> instead. If you wish to pass a single text string with
multiple options (in lieu of an array of text strings), then pass
<code class="docutils literal notranslate"><span class="pre">argc</span></code> = 0. When no longer needed you can remove the entire list by calling</p>
<blockquote id="gmt-destroy-options">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">GMT_Destroy_Options</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="k">struct</span> <span class="n">GMT_OPTION</span> <span class="o">**</span><span class="n">list</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>The function returns 1 if there is an error (which is passed back
with <code class="docutils literal notranslate"><span class="pre">API-&gt;error</span></code>), otherwise it returns 0 (<code class="docutils literal notranslate"><span class="pre">GMT_NOERROR</span></code>).</p>
<p>The inverse function prototype is</p>
<blockquote id="gmt-create-args">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span> <span class="o">**</span><span class="nf">GMT_Create_Args</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">argc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">GMT_OPTION</span> <span class="o">*</span><span class="n">list</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>which allocates space for the text strings and performs the conversion;
it passes back the count of the arguments via <code class="docutils literal notranslate"><span class="pre">argc</span></code> and returns a
pointer to the text array. In the case of an error we return a NULL
pointer and set <code class="docutils literal notranslate"><span class="pre">API-&gt;error</span></code> to reflect the error type. Note that
<code class="docutils literal notranslate"><span class="pre">argv[0]</span></code> will not contain the name of the program as is the case the
arguments presented by a C <code class="docutils literal notranslate"><span class="pre">main()</span></code> function. When you no longer have
any use for the text array, call</p>
<blockquote id="gmt-destroy-args">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">GMT_Destroy_Args</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">[]);</span>
</pre></div>
</div>
</div></blockquote>
<p>to deallocate the space used. This function returns 1 if there is
an error (which is passed back with <code class="docutils literal notranslate"><span class="pre">API-&gt;error</span></code>), otherwise it returns 0 (<code class="docutils literal notranslate"><span class="pre">GMT_NOERROR</span></code>).</p>
<p>Finally, to convert the linked list of option structures to a single
text string command, use</p>
<blockquote id="gmt-create-cmd">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span> <span class="o">*</span><span class="nf">GMT_Create_Cmd</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="k">struct</span> <span class="n">GMT_OPTION</span> <span class="o">*</span><span class="n">list</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>Developers who plan to import and export GMT shell scripts might find
it convenient to use these functions. In case of an error we return a
NULL pointer and set <code class="docutils literal notranslate"><span class="pre">API-&gt;error</span></code>, otherwise a pointer to an allocated
string is returned.  When you no longer have
any use for the text string, call</p>
<blockquote id="gmt-destroy-cmd">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">GMT_Destroy_Cmd</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">string</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>to deallocate the space used. This function returns 1 if there is
an error (which is passed back with <code class="docutils literal notranslate"><span class="pre">API-&gt;error</span></code>), otherwise it
returns 0  (<code class="docutils literal notranslate"><span class="pre">GMT_NOERROR</span></code>).</p>
</div>
<div class="section" id="manage-the-linked-list-of-options">
<h3>3.18.5. Manage the linked list of options<a class="headerlink" href="#manage-the-linked-list-of-options" title="Permalink to this headline">¶</a></h3>
<p>Several additional utility functions are available for programmers who
wish to manipulate program option structures within their own programs.
These allow you to create new option structures, append them to the
linked list, replace existing options with new values, find a particular
option, and remove options from the list. Note: The order in which the
options appear in the linked list is of no consequence to GMT.
Internally, GMT will sort and process the options in the manner
required. Externally, you are free to maintain your own order.</p>
<div class="section" id="make-a-new-option-structure">
<h4>3.18.5.1. Make a new option structure<a class="headerlink" href="#make-a-new-option-structure" title="Permalink to this headline">¶</a></h4>
<p><a class="reference internal" href="#gmt-make-option">GMT_Make_Option</a> will allocate a new option structure, assign
values given the <code class="docutils literal notranslate"><span class="pre">option</span></code> and <code class="docutils literal notranslate"><span class="pre">arg</span></code> parameters (pass NULL if there is
no argument for this option), and return a pointer to the allocated
structure. The prototype is</p>
<blockquote id="gmt-make-option">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">GMT_OPTION</span> <span class="o">*</span><span class="nf">GMT_Make_Option</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="kt">char</span> <span class="n">option</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>Should memory allocation fail the function will print an error message
pass an error code via <code class="docutils literal notranslate"><span class="pre">API-&gt;error</span></code>, and return NULL.</p>
</div>
<div class="section" id="append-an-option-to-the-linked-list">
<h4>3.18.5.2. Append an option to the linked list<a class="headerlink" href="#append-an-option-to-the-linked-list" title="Permalink to this headline">¶</a></h4>
<p><a class="reference internal" href="#gmt-append-option">GMT_Append_Option</a> will append the specified <code class="docutils literal notranslate"><span class="pre">option</span></code> to the end of
the doubly-linked <code class="docutils literal notranslate"><span class="pre">list</span></code>. The prototype is</p>
<blockquote id="gmt-append-option">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">GMT_OPTION</span> <span class="o">*</span><span class="nf">GMT_Append_Option</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="k">struct</span> <span class="n">GMT_OPTION</span> <span class="o">*</span><span class="n">option</span><span class="p">,</span>
    <span class="k">struct</span> <span class="n">GMT_OPTION</span> <span class="o">*</span><span class="n">list</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>We return the list back, and if <code class="docutils literal notranslate"><span class="pre">list</span></code> is given as NULL we return
<code class="docutils literal notranslate"><span class="pre">option</span></code> as the start of the new list. Any errors result in a NULL
pointer with <code class="docutils literal notranslate"><span class="pre">API-&gt;error</span></code> holding the error type.</p>
</div>
<div class="section" id="find-an-option-in-the-linked-list">
<h4>3.18.5.3. Find an option in the linked list<a class="headerlink" href="#find-an-option-in-the-linked-list" title="Permalink to this headline">¶</a></h4>
<p><a class="reference internal" href="#gmt-find-option">GMT_Find_Option</a> will return a pointer <code class="docutils literal notranslate"><span class="pre">ptr</span></code> to the first option in
the linked list starting at <code class="docutils literal notranslate"><span class="pre">list</span></code> whose option character equals
<code class="docutils literal notranslate"><span class="pre">option</span></code>. If not found we return NULL. While this is not necessarily
an error we still set <code class="docutils literal notranslate"><span class="pre">API-&gt;error</span></code> accordingly. The prototype is</p>
<blockquote id="gmt-find-option">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">GMT_OPTION</span> <span class="o">*</span><span class="nf">GMT_Find_Option</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="kt">char</span> <span class="n">option</span><span class="p">,</span>
    <span class="k">struct</span> <span class="n">GMT_OPTION</span> <span class="o">*</span><span class="n">list</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>If you need to look for multiple occurrences of a certain option you
will need to call <a class="reference internal" href="#gmt-find-option">GMT_Find_Option</a> again, passing the option
following the previously found option as the <code class="docutils literal notranslate"><span class="pre">list</span></code> entry, i.e.,</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">list</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="update-an-existing-option-in-the-list">
<h4>3.18.5.4. Update an existing option in the list<a class="headerlink" href="#update-an-existing-option-in-the-list" title="Permalink to this headline">¶</a></h4>
<p><a class="reference internal" href="#gmt-update-option">GMT_Update_Option</a> will replace the argument of <code class="docutils literal notranslate"><span class="pre">current</span></code> with the
new argument <code class="docutils literal notranslate"><span class="pre">arg</span></code> and otherwise leave the option at its place in the
list. The prototype is</p>
<blockquote id="gmt-update-option">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">GMT_Update_Option</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="k">struct</span> <span class="n">GMT_OPTION</span> <span class="o">*</span><span class="n">current</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>An error will be reported if (a) <code class="docutils literal notranslate"><span class="pre">current</span></code> is NULL or (b) <code class="docutils literal notranslate"><span class="pre">arg</span></code> is
NULL. The function returns 1 if there is an error, otherwise it returns 0 (<code class="docutils literal notranslate"><span class="pre">GMT_NOERROR</span></code>).</p>
</div>
<div class="section" id="delete-an-existing-option-in-the-linked-list">
<h4>3.18.5.5. Delete an existing option in the linked list<a class="headerlink" href="#delete-an-existing-option-in-the-linked-list" title="Permalink to this headline">¶</a></h4>
<p>You may use <a class="reference internal" href="#gmt-delete-option">GMT_Delete_Option</a> to remove the <code class="docutils literal notranslate"><span class="pre">current</span></code> option from the linked
<code class="docutils literal notranslate"><span class="pre">list</span></code>. The prototype is</p>
<blockquote id="gmt-delete-option">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">GMT_Delete_Option</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="k">struct</span> <span class="n">GMT_OPTION</span> <span class="o">*</span><span class="n">current</span><span class="p">,</span> <span class="k">struct</span> <span class="n">GMT_OPTION</span> <span class="o">**</span><span class="n">head</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>We return 1 if the option is not found in the list and set
<code class="docutils literal notranslate"><span class="pre">API-&gt;error</span></code> accordingly. Note: Only the first occurrence of the
specified option will be deleted. If you need to delete all such options
you will need to call this function in a loop until it returns a
non-zero status.</p>
</div>
<div class="section" id="specify-a-file-via-a-linked-option">
<h4>3.18.5.6. Specify a file via a linked option<a class="headerlink" href="#specify-a-file-via-a-linked-option" title="Permalink to this headline">¶</a></h4>
<p>To specify an input file name via an option, simply use &lt; as the
option (this is what <a class="reference internal" href="#gmt-create-options">GMT_Create_Options</a> does when it finds filenames
on the command line). Likewise, &gt; can be used to explicitly
indicate an output file. In order to append to an existing file, use
). For example the following command would read from file.A and
append to file.B:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">gmt</span> <span class="n">convert</span> <span class="o">-&lt;</span><span class="n">file</span><span class="p">.</span><span class="n">A</span> <span class="o">-</span><span class="p">)</span><span class="n">file</span><span class="p">.</span><span class="n">B</span>
</pre></div>
</div>
</div></blockquote>
<p>These options also work on the command line but usually one would have
to escape the special characters &lt;, &gt; and ) as they are normally
used for file redirection.</p>
</div>
<div class="section" id="encode-option-arguments-for-external-interfaces">
<h4>3.18.5.7. Encode option arguments for external interfaces<a class="headerlink" href="#encode-option-arguments-for-external-interfaces" title="Permalink to this headline">¶</a></h4>
<p>Developers writing interfaces between GMT and external platforms such
as other languages (Python, Java, Julia, etc.) or tools (MATLAB, Octave,
etc.) need to manipulate linked options in a special way.  For instance,
a GMT call in the MATLAB or Octave application might look like</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>table = gmt(&#39;blockmean -R30W/30E/10S/10N -I2m&#39;, [x y z]);
grid  = gmt(&#39;surface -R -I2m -Lu&#39;, table, high_limit_grid);
grid2 = gmt(&#39;grdmath ? LOG10 ? MUL&#39;, grid, grid);
</pre></div>
</div>
<p>Most of the time our implicit rules will take care of the ordering.  The
rule says that all required input data items must be listed before any
secondary input data items, and all primary output items must be listed
on the left hand side before any secondary output items.
There are three situations where the parsing will need further help;
(1) Specifying the positions of memory arguments given to <a class="reference internal" href="gmtmath.html"><span class="doc">gmtmath</span></a>,
(2) specifying the positions of memory arguments given to <a class="reference internal" href="grdmath.html"><span class="doc">grdmath</span></a>,
and (3) using -R? when passing a memory grid to the -R option (since just -R
means use the previous region in the command history).
Thus, in the <a class="reference internal" href="gmtmath.html"><span class="doc">gmtmath</span></a> call we we needed to specify where
the specific arguments should be placed among the operators.
API developers will rely on <a class="reference internal" href="#gmt-open-virtualfile">GMT_Open_VirtualFile</a> to convert the
above syntax to correct options for <a class="reference internal" href="#gmt-call-module">GMT_Call_Module</a>.
The prototype is</p>
<blockquote id="gmt-encode-options">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">GMT_RESOURCE</span> <span class="o">*</span><span class="nf">GMT_Encode_Options</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">module</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n_in</span><span class="p">,</span>
                                           <span class="k">struct</span> <span class="n">GMT_OPTION</span> <span class="o">**</span><span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">n_items</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>where <code class="docutils literal notranslate"><span class="pre">module</span></code> is the name of the module whose linked options are
pointed to by <code class="docutils literal notranslate"><span class="pre">*head</span></code>, <code class="docutils literal notranslate"><span class="pre">n_in</span></code> contains the number of <em>input</em>
objects we have to connect (or -1 if not known) and we return an array
that contains specific information for those options that
(after processing) contain explicit memory references.  The number of
items in the array is returned via the <code class="docutils literal notranslate"><span class="pre">n_items</span></code> variable.  The function
returns NULL if there are errors and sets <code class="docutils literal notranslate"><span class="pre">API-&gt;error</span></code> to the corresponding
error number.  The GMT_RESOURCE structure is defined below:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">GMT_RESOURCE</span> <span class="p">{</span>        <span class="cm">/* Information for passing external resources */</span>
    <span class="k">enum</span> <span class="n">GMT_enum_family</span> <span class="n">family</span><span class="p">;</span>     <span class="cm">/* GMT data family */</span>
    <span class="k">enum</span> <span class="n">GMT_enum_geometry</span> <span class="n">geometry</span><span class="p">;</span> <span class="cm">/* One of the recognized GMT geometries */</span>
    <span class="k">enum</span> <span class="n">GMT_enum_std</span> <span class="n">direction</span><span class="p">;</span>     <span class="cm">/* Either GMT_IN or GMT_OUT */</span>
    <span class="k">struct</span> <span class="n">GMT_OPTION</span> <span class="o">*</span><span class="n">option</span><span class="p">;</span>       <span class="cm">/* Pointer to the corresponding module option */</span>
    <span class="kt">int</span> <span class="n">object_ID</span><span class="p">;</span>                   <span class="cm">/* Object ID returned by GMT_Register_IO */</span>
    <span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>                         <span class="cm">/* Index into external object in|out arrays */</span>
    <span class="kt">int</span> <span class="n">mode</span><span class="p">;</span>                        <span class="cm">/* 0 means primary i/o object, 1 means secondary */</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">;</span>                    <span class="cm">/* Pointer to the registered GMT object */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>API developers will need to provide specific code to handle the registration of native
structures in their language or application and to translate between the GMT resources
and the corresponding native items.  Developers should look at an existing and working
interface such as the GMT/MATLAB toolbox to see the required steps.</p>
</div>
<div class="section" id="expand-an-option-with-explicit-memory-references">
<h4>3.18.5.8. Expand an option with explicit memory references<a class="headerlink" href="#expand-an-option-with-explicit-memory-references" title="Permalink to this headline">¶</a></h4>
<p>When the external tool or application knows the name of the special file names
used for memory references the developer should replace the place-holder <code class="docutils literal notranslate"><span class="pre">?</span></code> character
in any option string with the actual reference name.  This is accomplished by
calling <a class="reference internal" href="#gmt-expand-option">GMT_Expand_Option</a>, with prototype</p>
<blockquote id="gmt-expand-option">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">GMT_Expand_Option</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="k">struct</span> <span class="n">GMT_OPTION</span> <span class="o">*</span><span class="n">option</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>where <code class="docutils literal notranslate"><span class="pre">option</span></code> is the current option and <code class="docutils literal notranslate"><span class="pre">name</span></code>
is the special file name for the memory reference.</p>
</div>
</div>
</div>
</div>
<div class="section" id="the-gmt-fft-interface">
<h1>4. The GMT FFT Interface<a class="headerlink" href="#the-gmt-fft-interface" title="Permalink to this headline">¶</a></h1>
<p>While the i/o options presented so far lets you easily read in a data
table or grid and manipulate them, if you need to do the manipulation in the
wavenumber domain then this chapter is for you. Here, we outline how to
take the Fourier transform of such data, perform calculations in the
wavenumber domain, and take the inverse transform before writing the
results. To assist programmers we also distribute fully functioning
demonstration programs that takes you through the steps we are about to
discuss; these demo programs may be used as your starting point for
further development and can be found in the gmt-custom repository.</p>
<div class="section" id="presenting-and-parsing-the-fft-options">
<h2>4.1. Presenting and parsing the FFT options<a class="headerlink" href="#presenting-and-parsing-the-fft-options" title="Permalink to this headline">¶</a></h2>
<p>Several GMT programs that use the FFTs present the same unified option and
modifier sets to the user. The API makes these available as well. If
your program needs to present the FFT option usage you can call</p>
<blockquote id="gmt-fft-option">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">GMT_FFT_Option</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="kt">char</span> <span class="n">option</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dim</span><span class="p">,</span>
                               <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>Here, <code class="docutils literal notranslate"><span class="pre">option</span></code> is the unique character used for this particular
program option (most GMT programs have standardized on using ‘N’ but
you are free to choose whatever letter you want except existing GMT common
options). The <code class="docutils literal notranslate"><span class="pre">dim</span></code> sets the dimension of the transform; currently you
must choose 1 or 2, while <code class="docutils literal notranslate"><span class="pre">string</span></code> is a one-line message that
states what the option does; you should tailor this to your program. If
NULL then a generic message is placed instead.</p>
<p>To parse the user’s selection you call</p>
<blockquote id="gmt-fft-parse">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="o">*</span><span class="nf">GMT_FFT_Parse</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="kt">char</span> <span class="n">option</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dim</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>which accepts the user’s string option via <code class="docutils literal notranslate"><span class="pre">arg</span></code>; the other arguments
are the same as those above. The function returns an opaque pointer to a
structure with the chosen parameters.</p>
</div>
<div class="section" id="initializing-the-fft-machinery">
<h2>4.2. Initializing the FFT machinery<a class="headerlink" href="#initializing-the-fft-machinery" title="Permalink to this headline">¶</a></h2>
<p>Before your can take any transforms you must initialize the FFT
machinery. This process involves a series of preparatory steps that are
conveniently performed for you by</p>
<blockquote id="gmt-fft-create">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="o">*</span><span class="nf">GMT_FFT_Create</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">X</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dim</span><span class="p">,</span>
                        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">F</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>Here, <code class="docutils literal notranslate"><span class="pre">X</span></code> is either your dataset or grid pointer, <code class="docutils literal notranslate"><span class="pre">dim</span></code> is the
dimension of the transform (1 or 2 only), <code class="docutils literal notranslate"><span class="pre">mode</span></code> passes various flags to the setup, such as whether
the data is real, imaginary, or complex, and <code class="docutils literal notranslate"><span class="pre">F</span></code> is the opaque pointer
previously returned by <a class="reference internal" href="#gmt-fft-parse">GMT_FFT_Parse</a>. Depending on the option string you passed to
<a class="reference internal" href="#gmt-fft-parse">GMT_FFT_Parse</a>, the data may have a constant level or a trend
removed, mirror reflected and extended by various symmetries, padded and
tapered to desired transform dimensions, and possibly
temporary files are written out before the transform takes place. See the <a class="reference internal" href="grdfft.html"><span class="doc">grdfft</span></a>
man page for a full explanation of the options presented by <a class="reference internal" href="#gmt-fft-option">GMT_FFT_Option</a>.</p>
</div>
<div class="section" id="taking-the-fft">
<h2>4.3. Taking the FFT<a class="headerlink" href="#taking-the-fft" title="Permalink to this headline">¶</a></h2>
<p>Now that everything has been set up you can perform the transform with</p>
<blockquote id="gmt-fft">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="o">*</span><span class="nf">GMT_FFT</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">X</span><span class="p">,</span> <span class="kt">int</span> <span class="n">direction</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">K</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>which takes as <code class="docutils literal notranslate"><span class="pre">direction</span></code> either <code class="docutils literal notranslate"><span class="pre">GMT_FFT_FWD</span></code> or <code class="docutils literal notranslate"><span class="pre">GMT_FFT_INV</span></code>. The
<code class="docutils literal notranslate"><span class="pre">mode</span></code> is used to specify if we pass a real (<code class="docutils literal notranslate"><span class="pre">GMT_FFT_REAL</span></code>) or complex
(<code class="docutils literal notranslate"><span class="pre">GMT_FFT_COMPLEX</span></code>) data set, and <code class="docutils literal notranslate"><span class="pre">K</span></code> is the opaque pointer returned
by <a class="reference internal" href="#gmt-fft-create">GMT_FFT_Create</a>. The transform is performed in place and returned
via <code class="docutils literal notranslate"><span class="pre">X</span></code>. When done with your manipulations (below) you can call it
again with the inverse direction to recover the corresponding space-domain
version of your data. The FFT is fully normalized so that calling
forward followed by inverse yields the original data set. The information
passed via <code class="docutils literal notranslate"><span class="pre">K</span></code> determines if a 1-D or 2-D transform takes place; the
key work is done via <code class="docutils literal notranslate"><span class="pre">GMT_FFT_1D</span></code> or <code class="docutils literal notranslate"><span class="pre">GMT_FFT_2D</span></code>, as explained below.</p>
</div>
<div class="section" id="taking-the-1-d-fft">
<h2>4.4. Taking the 1-D FFT<a class="headerlink" href="#taking-the-1-d-fft" title="Permalink to this headline">¶</a></h2>
<p>A lower-level 1-D FFT is also available via the API, i.e.,</p>
<blockquote id="gmt-fft-1d">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">GMT_FFT_1D</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="kt">float</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">direction</span><span class="p">,</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>which takes as <code class="docutils literal notranslate"><span class="pre">direction</span></code> either <code class="docutils literal notranslate"><span class="pre">GMT_FFT_FWD</span></code> or <code class="docutils literal notranslate"><span class="pre">GMT_FFT_INV</span></code>. The
<code class="docutils literal notranslate"><span class="pre">mode</span></code> is used to specify if we pass a real (<code class="docutils literal notranslate"><span class="pre">GMT_FFT_REAL</span></code>) or complex
(<code class="docutils literal notranslate"><span class="pre">GMT_FFT_COMPLEX</span></code>) data set, and <code class="docutils literal notranslate"><span class="pre">data</span></code> is the 1-D data array of length
<code class="docutils literal notranslate"><span class="pre">n</span></code> that we wish
to transform. The transform is performed in place and returned
via <code class="docutils literal notranslate"><span class="pre">data</span></code>. When done with your manipulations (below) you can call it
again with the inverse direction to recover the corresponding space-domain
version of your data. The 1-D FFT is fully normalized so that calling
forward followed by inverse yields the original data set.</p>
</div>
<div class="section" id="taking-the-2-d-fft">
<h2>4.5. Taking the 2-D FFT<a class="headerlink" href="#taking-the-2-d-fft" title="Permalink to this headline">¶</a></h2>
<p>A lower-level 2-D FFT is also available via</p>
<blockquote id="gmt-fft-2d">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">GMT_FFT_2D</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="kt">float</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n_columns</span><span class="p">,</span>
                  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n_rows</span><span class="p">,</span> <span class="kt">int</span> <span class="n">direction</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>which takes as <code class="docutils literal notranslate"><span class="pre">direction</span></code> either <code class="docutils literal notranslate"><span class="pre">GMT_FFT_FWD</span></code> or <code class="docutils literal notranslate"><span class="pre">GMT_FFT_INV</span></code>. The
<code class="docutils literal notranslate"><span class="pre">mode</span></code> is used to specify if we pass a real (<code class="docutils literal notranslate"><span class="pre">GMT_FFT_REAL</span></code>) or complex
(<code class="docutils literal notranslate"><span class="pre">GMT_FFT_COMPLEX</span></code>) data set, and <code class="docutils literal notranslate"><span class="pre">data</span></code> is the 2-D data array in
row-major format, with row length <code class="docutils literal notranslate"><span class="pre">n_columns</span></code> and column length <code class="docutils literal notranslate"><span class="pre">n_rows</span></code>.
The transform is performed in place and returned
via <code class="docutils literal notranslate"><span class="pre">data</span></code>. When done with your manipulations (below) you can call it
again with the inverse direction to recover the corresponding space-domain
version of your data. The 2-D FFT is fully normalized so that calling
forward followed by inverse yields the original data set.</p>
</div>
<div class="section" id="wavenumber-calculations">
<h2>4.6. Wavenumber calculations<a class="headerlink" href="#wavenumber-calculations" title="Permalink to this headline">¶</a></h2>
<p>As your data have been transformed to the wavenumber domain you may wish
to operate on the various values as a function of wavenumber. We will
show how this is done for datasets and grids separately. First, we
present the function that returns an individual wavenumber:</p>
<blockquote id="gmt-fft-wavenumber">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span> <span class="nf">GMT_FFT_Wavenumber</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">k</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">K</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>where <code class="docutils literal notranslate"><span class="pre">k</span></code> is the index into the array or grid, <code class="docutils literal notranslate"><span class="pre">mode</span></code> specifies
which wavenumber we want (it is not used for 1-D transform but for the
2-D transform we can select either the x-wavenumber (0), the
y-wavenumber (1), or the radial wavenumber (2)), and finally the opaque
vector created by <a class="reference internal" href="#gmt-fft-create">GMT_FFT_Create</a>.</p>
<div class="section" id="d-fft-manipulation">
<h3>4.6.1. 1-D FFT manipulation<a class="headerlink" href="#d-fft-manipulation" title="Permalink to this headline">¶</a></h3>
<p>[To be added after gmtfft has been added as new module, probably in 5.4.]</p>
</div>
<div class="section" id="id6">
<h3>4.6.2. 2-D FFT manipulation<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>The number of complex pairs in the grid is given by the header’s <code class="docutils literal notranslate"><span class="pre">nm</span></code>
variable, while <code class="docutils literal notranslate"><span class="pre">size</span></code> will be twice that value as it holds the number
of components. To visit all the complex values and obtain the
corresponding wavenumber we simply need to loop over <code class="docutils literal notranslate"><span class="pre">size</span></code> and call
<a class="reference internal" href="#gmt-fft-wavenumber">GMT_FFT_Wavenumber</a>. This code snippet multiples the complex grid by
the radial wavenumber:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint64_t</span> <span class="n">k</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">Grid</span><span class="o">-&gt;</span><span class="n">header</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">wave</span> <span class="o">=</span> <span class="n">GMT_FFT_Wavenumber</span> <span class="p">(</span><span class="n">API</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">K</span><span class="p">);</span>
    <span class="n">Grid</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*=</span> <span class="n">wave</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>Alternatively, you may choose to be more specific about which components
are real and imaginary (especially if they are to be treated
differently), and set up the loop this way:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint64_t</span> <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">re</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">im</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">re</span> <span class="o">&lt;</span> <span class="n">Grid</span><span class="o">-&gt;</span><span class="n">header</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span> <span class="n">re</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">im</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">wave</span> <span class="o">=</span> <span class="n">GMT_FFT_Wavenumber</span> <span class="p">(</span><span class="n">API</span><span class="p">,</span> <span class="n">re</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">K</span><span class="p">);</span>
    <span class="n">Grid</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">re</span><span class="p">]</span> <span class="o">*=</span> <span class="n">wave</span><span class="p">;</span>
    <span class="n">Grid</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">im</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">wave</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</div>
</div>
<div class="section" id="destroying-the-fft-machinery">
<h2>4.7. Destroying the FFT machinery<a class="headerlink" href="#destroying-the-fft-machinery" title="Permalink to this headline">¶</a></h2>
<p>When done you terminate the FFT machinery with</p>
<blockquote id="gmt-fft-destroy">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span> <span class="nf">GMT_FFT_Destroy</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">API</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">K</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>which simply frees up the memory allocated by the FFT machinery with <a class="reference internal" href="#gmt-fft-create">GMT_FFT_Create</a>.</p>
</div>
</div>
<div class="section" id="fortran-support">
<h1>5. FORTRAN Support<a class="headerlink" href="#fortran-support" title="Permalink to this headline">¶</a></h1>
<p>FORTRAN 90 developers who wish to use the GMT API may use the same
API functions as discussed in Chapter 2. As we do not have much (i.e., any) experience
with modern Fortran we are not sure to what extent you are able to access
the members of the various structures, such as the <a class="reference internal" href="#struct-grid"><span class="std std-ref">GMT_GRID</span></a> structure. Thus,
this part will depend on feedback and for the time being is to be considered
preliminary and subject to change.  We encourage you to take contact should you
wish to use the API with your Fortran 90 programs.</p>
<div class="section" id="fortran-77-grid-i-o">
<h2>5.1. FORTRAN 77 Grid i/o<a class="headerlink" href="#fortran-77-grid-i-o" title="Permalink to this headline">¶</a></h2>
<p>Because of a lack of structure pointers we can only provide a low level of
support for Fortran 77. This API is limited to help you inquire, read and write
GMT grids directly from Fortran 77.
To inquire about the range of information in a grid, use</p>
<blockquote id="gmt-f77-readgrdinfo">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">gmt_f77_readgrdinfo</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dim</span><span class="p">[],</span> <span class="kt">double</span> <span class="n">limits</span><span class="p">[],</span> <span class="kt">double</span> <span class="n">inc</span><span class="p">[],</span>
                           <span class="kt">char</span> <span class="o">*</span><span class="n">title</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">remark</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>where <code class="docutils literal notranslate"><span class="pre">dim</span></code> returns the grid width, height, and registration, <code class="docutils literal notranslate"><span class="pre">limits</span></code> returns the min and max values for x, y, and z
as three consecutive pairs, <code class="docutils literal notranslate"><span class="pre">inc</span></code> returns the x and y increments, while the <code class="docutils literal notranslate"><span class="pre">title</span></code> and <code class="docutils literal notranslate"><span class="pre">remark</span></code>
return the values of these strings. The <code class="docutils literal notranslate"><span class="pre">file</span></code>
argument is the name of the file we wish to inquire about. The function returns 0 unless there is an error.
Note that you must declare your variables so that <code class="docutils literal notranslate"><span class="pre">limits</span></code> has at least 6 elements, <code class="docutils literal notranslate"><span class="pre">inc</span></code> has at least 2, and <code class="docutils literal notranslate"><span class="pre">dim</span></code> has at least 4.</p>
<p>To actually read the grid, we use</p>
<blockquote id="gmt-f77-readgrd">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">gmt_f77_readgrd</span> <span class="p">(</span><span class="kt">float</span> <span class="o">*</span><span class="n">array</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dim</span><span class="p">[],</span> <span class="kt">double</span> <span class="n">wesn</span><span class="p">[],</span>
                       <span class="kt">double</span> <span class="n">inc</span><span class="p">[],</span> <span class="kt">char</span> <span class="o">*</span><span class="n">title</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">remark</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>where <code class="docutils literal notranslate"><span class="pre">array</span></code> is the 1-D grid data array, <code class="docutils literal notranslate"><span class="pre">dim</span></code> returns the grid width, height, and registration,
<code class="docutils literal notranslate"><span class="pre">limits</span></code> returns the min and max values for x, y, and z, <code class="docutils literal notranslate"><span class="pre">inc</span></code> returns the x and y increments, and
the <code class="docutils literal notranslate"><span class="pre">title</span></code> and <code class="docutils literal notranslate"><span class="pre">remark</span></code> return the values of the corresponding strings.  The <code class="docutils literal notranslate"><span class="pre">file</span></code>
argument is the name of the file we wish to read from.  The function returns 0 unless there is an error.
Note on input, <code class="docutils literal notranslate"><span class="pre">dim[2]</span></code> can be set to 1, which means we will allocate the array for you; otherwise
we assume space has already been secured.  Also, if <code class="docutils literal notranslate"><span class="pre">dim[3]</span></code> is set to 1 we will in-place transpose
the array from C-style row-major array order to Fortran column-major array order.</p>
<p>Finally, to write a grid to file you can use</p>
<blockquote id="gmt-f77-writegrd">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">gmt_f77_writegrd_</span><span class="p">(</span><span class="kt">float</span> <span class="o">*</span><span class="n">array</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dim</span><span class="p">[],</span> <span class="kt">double</span> <span class="n">wesn</span><span class="p">[],</span> <span class="kt">double</span> <span class="n">inc</span><span class="p">[],</span>
                        <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">title</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">remark</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>where <code class="docutils literal notranslate"><span class="pre">array</span></code> is the 1-D grid data array, <code class="docutils literal notranslate"><span class="pre">dim</span></code> specifies the grid width, height, and registration,
<code class="docutils literal notranslate"><span class="pre">limits</span></code> may be used to specify a subset (normally, just pass zeros), <code class="docutils literal notranslate"><span class="pre">inc</span></code> specifies the x and y increments,
while the <code class="docutils literal notranslate"><span class="pre">title</span></code> and <code class="docutils literal notranslate"><span class="pre">remark</span></code> supply the values of these strings.  The <code class="docutils literal notranslate"><span class="pre">file</span></code>
argument is the name of the file we wish to write to.  The function returns 0 unless there is an error.
If <code class="docutils literal notranslate"><span class="pre">dim[3]</span></code> is set to 1 we will in-place transpose
the array from Fortran column-major array order to C-style row-major array order before writing. Note
this means <code class="docutils literal notranslate"><span class="pre">array</span></code> will have been transposed when the function returns.</p>
</div>
</div>
<div class="section" id="external-interfaces">
<h1>6. External Interfaces<a class="headerlink" href="#external-interfaces" title="Permalink to this headline">¶</a></h1>
<p>Developers may want to access GMT modules from external programming environments, such as MATLAB,
Octave, Julia, Python, R, IDL, etc., etc.  These all face similar challenges and hence this section
will speak in somewhat abstract terms.  Specific language addressing the challenges for some of
the above-mentioned environments will follow below.</p>
<p>The C/C++ API for GMT makes it possible to call any of the ~100 core modules, the 40 or so supplemental
modules, and any number of custom modules provided via shared libraries (e.g., the gsfml modules).  Many
of the external interfaces come equipped with methods to call C functions directly.
The key challenges pertain to specifying the input to use in the module and to receive
what is produced by the module.
As we know from GMT command line usage, all GMT modules expect input to be given via input files (or stdin, except for sources like grids and images).  Similarly, output will be written to a specified
output file (or stdout if the data type supports it).  Clearly, external interfaces
could do the same thing.  The problem is that most of the time we already will have the input data in
memory and would prefer the output to be returned back to memory, thus avoiding using temporary files.
Here, we will outline the general approach for using the GMT API.  We will describe a relatively low-level approach
to calling GMT modules.  Once such an interface exists it is simpler to build a more flexible and user-friendly
layer on top that can handle argument parsing in a form that makes the interface seem more of a natural
extension of your external environment than a forced fit to GMT’s command-line heritage.
Before we describe the interface it is important to understand that the GMT modules, since the beginning
or time, have done the i/o inside the modules.  While these steps are helped by i/o library functions, the
i/o activities all take place <em>inside</em> the modules.  This means that external environments in which the desired
input data already reside in memory and the desired results should be returned back to memory pose a
trickier challenge.  We will see the solution to this involves the concept of <em>virtual</em> files.</p>
<div class="figure align-center" id="id15">
<a class="reference internal image-reference" href="_images/GMT_API_use.png"><img alt="_images/GMT_API_use.png" src="_images/GMT_API_use.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-text">GMT Modules can read and write information in may ways.  The GMT command line modules
can only access the methods in white, while all methods are available via the C API.
External interfaces will preferentially want the methods in orange.</span></p>
</div>
<div class="section" id="plain-interface">
<h2>6.1. Plain interface<a class="headerlink" href="#plain-interface" title="Permalink to this headline">¶</a></h2>
<p>While the syntax of your external environment’s language will dictate the details of the implementation, we will in general
need to build a function (or class, or method) that allows you to issue a call like this:</p>
<p>[<em>results</em>] = <strong>gmt</strong> (<em>module</em>, <em>options</em>, <em>inputs</em>)</p>
<p>where <em>results</em> (i.e., objects returned back to memory) is optional and may be one or more items grouped
together, depending on language syntax.  If no output is required then no left-hand side
assignment will be present.  Likewise, <em>inputs</em> is optional and may be one or more comma-separated
objects present in memory.  In most cases, <em>options</em> will be required and this is a string with
options very similar to the arguments given on the GMT command line.  Finally, <em>module</em> is required since you
must specify which one you want to call. The coding of the <strong>gmt</strong> method, class, or function above may be written entirely in
C, partly in C and the external scripting language, or entirely in the scripting language, depending on
restrictions on what needs to be done and where this is most easily accomplished.
How this is accomplished may vary from environment to environment.</p>
<div class="figure align-center" id="id16">
<a class="reference internal image-reference" href="_images/GMT_API_flow.png"><img alt="_images/GMT_API_flow.png" src="_images/GMT_API_flow.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-text">Data pass in and out of the <strong>gmt</strong> interface which may be written in the scripting language used
by the external interface.  The native data will need to be encapsulated by GMT containers and this
step may be done by a C <strong>parser</strong> but could also be done by the <strong>gmt</strong> interface directly.  Either
of these communicate directly with the C functions in the GMT API.</span></p>
</div>
</div>
<div class="section" id="data-containers">
<h2>6.2. Data containers<a class="headerlink" href="#data-containers" title="Permalink to this headline">¶</a></h2>
<p>The external interface developer will need to create native data classes or structures that are capable of
containing the information associated with the 6 GMT objects: data tables, grids, images, color palette tables,
PostScript documents, and text tables.  In other words, how your external environment will represent these
data in memory.  Some of these “containers” may already exist, while others may need to be designed.  Most likely, you will end up with
a set of six containers that can hold the various GMT data objects and related metadata.  In addition, it may
be convenient to also consider the two GMT helper objects MATRIX and VECTOR, which may be closer to the native
representation of your data than, for instance, the native GMT_DATASET.</p>
</div>
<div class="section" id="input-from-memory">
<h2>6.3. Input from memory<a class="headerlink" href="#input-from-memory" title="Permalink to this headline">¶</a></h2>
<p>Whether input comes from memory or from external files, the call to a GMT module is the same: we have to specify
<em>filenames</em> to provide the input data.  Thus, the game is to provide <em>virtual</em> file names that represent our in-memory
data.  The process is relatively simple and may need to be done in a snippet of C
code that can be called by a function written in your environments scripting language. The steps go like this:</p>
<ol class="arabic simple">
<li>Create a GMT C container marked for input and copy or reference your data provided by
your external environment into this container.</li>
<li>Open a virtual file using this container to represent the input source.</li>
<li>Insert this virtual file name in the appropriate location in the GMT option string.  If the
module imports data from <em>stdin</em> then we can use the hidden option -&lt;filename.</li>
</ol>
<p>When the GMT module is run it will know how to make the connections between the virtual file names and
the actual data via information stored inside the C API.  When the module completes you should close any
open virtual files that were used by the module.</p>
</div>
<div class="section" id="output-to-memory">
<h2>6.4. Output to memory<a class="headerlink" href="#output-to-memory" title="Permalink to this headline">¶</a></h2>
<p>As the case for selecting input, GMT modules only know about writing results to a file (or stdout).  Hence, we must follow the same paradigm as we did for input
and identify virtual files to represent the output destinations.  The steps are:</p>
<ol class="arabic simple">
<li>Create an empty GMT C container of the right type marked for output.</li>
<li>Create a virtual file name to represent this output destination.</li>
<li>Place this file name in the appropriate location in the GMT option string.  If the
module exports data to <em>stdout</em> then we can use the hidden option -&gt;filename.</li>
</ol>
<p>When the GMT module is run it will know how to make the connections between the memory allocated by the
module and the virtual file names stored inside the C API.  Once the module call has completed you can access the
results in the external environment by using <a class="reference internal" href="#gmt-read-virtualfile">GMT_Read_VirtualFile</a> with the virtual filename you created earlier.  This will return a GMT C container with the results, and
you can now populate you external data containers with data produced by the GMT module.</p>
</div>
<div class="section" id="the-magic-of-knowing">
<h2>6.5. The magic of knowing<a class="headerlink" href="#the-magic-of-knowing" title="Permalink to this headline">¶</a></h2>
<p>External developers have access to the two extra API functions <a class="reference internal" href="#gmt-encode-options">GMT_Encode_Options</a> and <a class="reference internal" href="#gmt-expand-option">GMT_Expand_Option</a>.
Your <strong>gmt</strong> will need to call <a class="reference internal" href="#gmt-encode-options">GMT_Encode_Options</a> to obtain information about what the selected
module expects, what its options are, which were selected, and what data types are expected.  It may
possibly modify the options, such as adding the filename “?” to options that set
<em>required</em> input and output files and returns an array of structures with specific information about
all inputs and outputs.  If sources and destinations were missing from your <em>options</em> string it is taken
to mean that you want to associate these sources and destinations
with memory locations rather than actual files.  The second function <a class="reference internal" href="#gmt-expand-option">GMT_Expand_Option</a> can then then
used to replace these place-holder names with the virtual filenames you created earlier.</p>
<div class="section" id="the-matlab-interface">
<h3>6.5.1. The MATLAB interface<a class="headerlink" href="#the-matlab-interface" title="Permalink to this headline">¶</a></h3>
<p>We have built a MATLAB/Octave interface to GMT called the toolbox.  It was our first attempt to use the C API from an
external environment and its development influenced
how we designed the final GMT C API.  MATLAB represents most data as matrices but there are also structures that
can hold many different items, including several matrices and text strings.  Thus, we designed several native mex structures
that represent the six GMT objects.  The main <strong>gmt</strong> function available in MATLAB derives from a small MATLAB script
(gmt.m) which handles basic argument testing and then passes the arguments to our C function gmtmex.c.
Most of the high-level parsing of options and arguments is done in this function, but we also rely on
a C library (gmtmex_parser.c) that hides the details of the implementation.  It is this library that
does most of the work in translating between the GMT and MATLAB object layouts.  Knowing what types are
represented by the different sources and destinations is provided by the array of structures returned
by <a class="reference internal" href="#gmt-encode-options">GMT_Encode_Options</a>.</p>
</div>
<div class="section" id="the-julia-interface">
<h3>6.5.2. The Julia interface<a class="headerlink" href="#the-julia-interface" title="Permalink to this headline">¶</a></h3>
<p>Unlike the MATLAB interface, the Julia interface is written entirely in the Julia language.</p>
</div>
<div class="section" id="the-python-interface">
<h3>6.5.3. The Python interface<a class="headerlink" href="#the-python-interface" title="Permalink to this headline">¶</a></h3>
<p>To be defined shortly.</p>
</div>
</div>
<div class="section" id="appendix-a-gmt-resources">
<h2>6.6. Appendix A: GMT resources<a class="headerlink" href="#appendix-a-gmt-resources" title="Permalink to this headline">¶</a></h2>
<p>We earlier introduced the six standard GMT resources (dataset, grid, image, color palette table, PostScript, textset)
as well as the user vector and matrix.  Here are the complete definitions of these structures, including
all variables accessible via the structures.</p>
<div class="section" id="data-set">
<h3>6.6.1. Data set<a class="headerlink" href="#data-set" title="Permalink to this headline">¶</a></h3>
<p>Each data set is represented by a <a class="reference internal" href="#struct-dataset"><span class="std std-ref">GMT_DATASET</span></a> that consists of one or more data
tables represented by a <a class="reference internal" href="#struct-datatable"><span class="std std-ref">GMT_DATATABLE</span></a>, and each table consists of one or more
segments represented by a <a class="reference internal" href="#struct-datasegment"><span class="std std-ref">GMT_DATASEGMENT</span></a>, and each segment contains one or
more rows of a fixed number of columns.  If the dataset originated from an OGR/GMT file then there
will be items such as an <a class="reference internal" href="#struct-ogr"><span class="std std-ref">GMT_OGR</span></a> structure per table and a <a class="reference internal" href="#struct-ogr-seg"><span class="std std-ref">GMT_OGR_SEG</span></a>
structure per segment.</p>
<div class="highlight-c notranslate" id="struct-dataset"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">GMT_DATASET</span> <span class="p">{</span> <span class="cm">/* Single container for an array of GMT tables (files) */</span>
    <span class="cm">/* Variables we document for the API: */</span>
    <span class="kt">uint64_t</span>               <span class="n">n_tables</span><span class="p">;</span>     <span class="cm">/* Total number of tables (files) contained */</span>
    <span class="kt">uint64_t</span>               <span class="n">n_columns</span><span class="p">;</span>    <span class="cm">/* Number of data columns */</span>
    <span class="kt">uint64_t</span>               <span class="n">n_segments</span><span class="p">;</span>   <span class="cm">/* Total number of segments across all tables */</span>
    <span class="kt">uint64_t</span>               <span class="n">n_records</span><span class="p">;</span>    <span class="cm">/* Total number of data records across all tables */</span>
    <span class="kt">double</span>                <span class="o">*</span><span class="n">min</span><span class="p">;</span>          <span class="cm">/* Minimum coordinate for each column */</span>
    <span class="kt">double</span>                <span class="o">*</span><span class="n">max</span><span class="p">;</span>          <span class="cm">/* Maximum coordinate for each column */</span>
    <span class="k">struct</span> <span class="n">GMT_DATATABLE</span> <span class="o">**</span><span class="n">table</span><span class="p">;</span>        <span class="cm">/* Pointer to array of tables */</span>
    <span class="cm">/* ---- Variables &quot;hidden&quot; from the API ---- */</span>
    <span class="kt">uint64_t</span>               <span class="n">id</span><span class="p">;</span>           <span class="cm">/* The internal number of the data set */</span>
    <span class="kt">size_t</span>                 <span class="n">n_alloc</span><span class="p">;</span>      <span class="cm">/* The current allocation length of tables */</span>
    <span class="kt">uint64_t</span>               <span class="n">dim</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>       <span class="cm">/* Used by GMT_Duplicate_Data to override dimensions */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>           <span class="n">geometry</span><span class="p">;</span>     <span class="cm">/* The geometry of this dataset */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>           <span class="n">alloc_level</span><span class="p">;</span>  <span class="cm">/* The level it was allocated at */</span>
    <span class="k">enum</span> <span class="n">GMT_enum_dest</span>     <span class="n">io_mode</span><span class="p">;</span>      <span class="cm">/* -1: write OGR format (requires proper -a),</span>
<span class="cm">                                            0: write everything to one destination [Default],</span>
<span class="cm">                                            1: use table-&gt;file[GMT_OUT] to write separate table,</span>
<span class="cm">                                            2: use segment-&gt;file[GMT_OUT] to write separate segments.</span>
<span class="cm">                                            3: as 2 but with no filenames we create filenames from</span>
<span class="cm">                                              tbl and seg numbers */</span>
    <span class="k">enum</span> <span class="n">GMT_enum_alloc</span>    <span class="n">alloc_mode</span><span class="p">;</span>   <span class="cm">/* Allocation mode [GMT_ALLOCATED_BY_GMT] */</span>
    <span class="kt">char</span>                  <span class="o">*</span><span class="n">file</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>      <span class="cm">/* Name of file or source [0 = in, 1 = out] */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Here is the full definition of the <code class="docutils literal notranslate"><span class="pre">GMT_DATATABLE</span></code> structure:</p>
<div class="highlight-c notranslate" id="struct-datatable"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">GMT_DATATABLE</span> <span class="p">{</span>  <span class="cm">/* To hold an array of line segment structures and header information in one container */</span>
    <span class="cm">/* Variables we document for the API: */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n_headers</span><span class="p">;</span>    <span class="cm">/* Number of file header records (0 if no header) */</span>
    <span class="kt">uint64_t</span>     <span class="n">n_columns</span><span class="p">;</span>    <span class="cm">/* Number of columns (fields) in each record */</span>
    <span class="kt">uint64_t</span>     <span class="n">n_segments</span><span class="p">;</span>   <span class="cm">/* Number of segments in the array */</span>
    <span class="kt">uint64_t</span>     <span class="n">n_records</span><span class="p">;</span>    <span class="cm">/* Total number of data records across all segments */</span>
    <span class="kt">double</span>      <span class="o">*</span><span class="n">min</span><span class="p">;</span>          <span class="cm">/* Minimum coordinate for each column */</span>
    <span class="kt">double</span>      <span class="o">*</span><span class="n">max</span><span class="p">;</span>          <span class="cm">/* Maximum coordinate for each column */</span>
    <span class="kt">char</span>       <span class="o">**</span><span class="n">header</span><span class="p">;</span>       <span class="cm">/* Array with all file header records, if any) */</span>
    <span class="k">struct</span> <span class="n">GMT_DATASEGMENT</span> <span class="o">**</span><span class="n">segment</span><span class="p">;</span> <span class="cm">/* Pointer to array of segments */</span>
    <span class="cm">/* ---- Variables &quot;hidden&quot; from the API ---- */</span>
    <span class="kt">uint64_t</span>     <span class="n">id</span><span class="p">;</span>           <span class="cm">/* The internal number of the table */</span>
    <span class="kt">size_t</span>       <span class="n">n_alloc</span><span class="p">;</span>      <span class="cm">/* The current allocation length of segments */</span>
    <span class="kt">double</span>       <span class="n">dist</span><span class="p">;</span>         <span class="cm">/* Distance from a point to this feature */</span>
    <span class="k">enum</span> <span class="n">GMT_enum_write</span> <span class="n">mode</span><span class="p">;</span>  <span class="cm">/* 0 = output table, 1 = output header only, 2 = skip table */</span>
    <span class="k">struct</span> <span class="n">GMT_OGR</span> <span class="o">*</span><span class="n">ogr</span><span class="p">;</span>       <span class="cm">/* Pointer to struct with all things GMT/OGR</span>
<span class="cm">                                                                  (if MULTI-geometry and not MULTIPOINT)  */</span>
    <span class="kt">char</span>        <span class="o">*</span><span class="n">file</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>      <span class="cm">/* Name of file or source [0 = in, 1 = out] */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Here is the full definition of the <code class="docutils literal notranslate"><span class="pre">GMT_DATASEGMENT</span></code> structure:</p>
<div class="highlight-c notranslate" id="struct-datasegment"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">GMT_DATASEGMENT</span> <span class="p">{</span>       <span class="cm">/* For holding segment lines in memory */</span>
    <span class="cm">/* Variables we document for the API: */</span>
    <span class="kt">uint64_t</span> <span class="n">n_rows</span><span class="p">;</span>           <span class="cm">/* Number of points in this segment */</span>
    <span class="kt">uint64_t</span> <span class="n">n_columns</span><span class="p">;</span>        <span class="cm">/* Number of fields in each record (&gt;= 2) */</span>
    <span class="kt">double</span>  <span class="o">*</span><span class="n">min</span><span class="p">;</span>              <span class="cm">/* Minimum coordinate for each column */</span>
    <span class="kt">double</span>  <span class="o">*</span><span class="n">max</span><span class="p">;</span>              <span class="cm">/* Maximum coordinate for each column */</span>
    <span class="kt">double</span> <span class="o">**</span><span class="n">data</span><span class="p">;</span>             <span class="cm">/* Data x,y, and possibly other columns */</span>
    <span class="kt">char</span>    <span class="o">*</span><span class="n">label</span><span class="p">;</span>            <span class="cm">/* Label string (if applicable) */</span>
    <span class="kt">char</span>    <span class="o">*</span><span class="n">header</span><span class="p">;</span>           <span class="cm">/* Segment header (if applicable) */</span>
    <span class="cm">/* ---- Variables &quot;hidden&quot; from the API ---- */</span>
    <span class="k">enum</span> <span class="n">GMT_enum_write</span> <span class="n">mode</span><span class="p">;</span>  <span class="cm">/* 0 = output segment, 1 = output header only, 2 = skip segment */</span>
    <span class="k">enum</span> <span class="n">GMT_enum_pol</span> <span class="n">pol_mode</span><span class="p">;</span><span class="cm">/* GMT_IS_PERIMETER [-Pp] or GMT_IS_HOLE [-Ph] (for polygons only) */</span>
    <span class="kt">uint64_t</span> <span class="n">id</span><span class="p">;</span>               <span class="cm">/* The internal number of the segment */</span>
    <span class="kt">size_t</span>   <span class="n">n_alloc</span><span class="p">;</span>          <span class="cm">/* The current allocation length of each data column */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">range</span><span class="p">;</span>        <span class="cm">/* Longitude reporting scheme, e.g. GMT_IS_GIVEN_RANGE [0] */</span>
    <span class="kt">int</span>      <span class="n">pole</span><span class="p">;</span>             <span class="cm">/* Spherical polygons only: If it encloses the S (-1)</span>
<span class="cm">                                                                      or N (+1) pole, or none (0) */</span>
    <span class="kt">double</span>   <span class="n">dist</span><span class="p">;</span>             <span class="cm">/* Distance from a point to this feature */</span>
    <span class="kt">double</span>   <span class="n">lat_limit</span><span class="p">;</span>        <span class="cm">/* For polar caps: the latitude of the point closest to the pole */</span>
    <span class="k">struct</span> <span class="n">GMT_OGR_SEG</span> <span class="o">*</span><span class="n">ogr</span><span class="p">;</span>   <span class="cm">/* NULL unless OGR/GMT metadata exist for this segment */</span>
    <span class="k">struct</span> <span class="n">GMT_DATASEGMENT</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span> <span class="cm">/* NULL unless polygon has holes and pointing to next hole */</span>
    <span class="kt">char</span>    <span class="o">*</span><span class="n">file</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>          <span class="cm">/* Name of file or source [0 = in, 1 = out] */</span>
 <span class="p">};</span>
</pre></div>
</div>
<p>The definition of the <code class="docutils literal notranslate"><span class="pre">GMT_OGR</span></code> structure (not part of the API):</p>
<div class="highlight-c notranslate" id="struct-ogr"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">GMT_OGR</span> <span class="p">{</span>  <span class="cm">/* Struct with all things GMT/OGR for a table */</span>
    <span class="cm">/* The first parameters are usually set once per data set and do not change */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">geometry</span><span class="p">;</span>    <span class="cm">/* @G: Geometry of this data set, if known [0 otherwise] */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">n_aspatial</span><span class="p">;</span>  <span class="cm">/* @T: Number of aspatial fields */</span>
    <span class="kt">char</span>         <span class="o">*</span><span class="n">region</span><span class="p">;</span>      <span class="cm">/* @R: Region textstring [NULL if not set] */</span>
    <span class="kt">char</span>         <span class="o">*</span><span class="n">proj</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>     <span class="cm">/* @J: The 1-4 projection strings [NULL if not set] */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">type</span><span class="p">;</span>        <span class="cm">/* @T: Data types of the aspatial fields [NULL if not set]  */</span>
    <span class="kt">char</span>        <span class="o">**</span><span class="n">name</span><span class="p">;</span>        <span class="cm">/* @N: Names of the aspatial fields [NULL if not set]  */</span>
    <span class="cm">/* The following are for OGR data only. It is filled during parsing (current segment)</span>
<span class="cm">               but is then copied to the segment header so it can be accessed later */</span>
    <span class="k">enum</span> <span class="n">GMT_enum_pol</span> <span class="n">pol_mode</span><span class="p">;</span><span class="cm">/* @P: GMT_IS_PERIMETER or GMT_IS_HOLE (for polygons only) */</span>
    <span class="kt">char</span>        <span class="o">**</span><span class="n">tvalue</span><span class="p">;</span>      <span class="cm">/* @D: The text values of the current aspatial fields */</span>
    <span class="kt">double</span>       <span class="o">*</span><span class="n">dvalue</span><span class="p">;</span>      <span class="cm">/* @D: Same but converted to double (assumed possible) */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The definition of the <code class="docutils literal notranslate"><span class="pre">GMT_OGR_SEG</span></code> structure (not part of the API):</p>
<div class="highlight-c notranslate" id="struct-ogr-seg"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">GMT_OGR_SEG</span> <span class="p">{</span>           <span class="cm">/* Struct with GMT/OGR aspatial data for a segment */</span>
    <span class="k">enum</span> <span class="n">GMT_enum_pol</span> <span class="n">pol_mode</span><span class="p">;</span><span class="cm">/* @P: GMT_IS_PERIMETER or GMT_IS_HOLE (for polygons only) */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">n_aspatial</span><span class="p">;</span> <span class="cm">/* @T: Number of aspatial fields */</span>
    <span class="kt">char</span>         <span class="o">**</span><span class="n">tvalue</span><span class="p">;</span>     <span class="cm">/* @D: Values of current aspatial fields */</span>
    <span class="kt">double</span> <span class="o">*</span><span class="n">dvalue</span><span class="p">;</span>            <span class="cm">/* @D: Same but converted to double (assumed possible) */</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="gmt-grid">
<h3>6.6.2. GMT grid<a class="headerlink" href="#gmt-grid" title="Permalink to this headline">¶</a></h3>
<p>A grid is represented by a <a class="reference internal" href="#struct-grid"><span class="std std-ref">GMT_GRID</span></a> that consists of a header structure
represented by a <a class="reference internal" href="#struct-gridheader"><span class="std std-ref">GMT_GRID_HEADER</span></a> and an float array <code class="docutils literal notranslate"><span class="pre">data</span></code> that
contains the grid values.</p>
<div class="highlight-c notranslate" id="struct-grid"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">GMT_GRID</span> <span class="p">{</span>                        <span class="cm">/* To hold a GMT float grid and its header in one container */</span>
    <span class="k">struct</span> <span class="n">GMT_GRID_HEADER</span> <span class="o">*</span><span class="n">header</span><span class="p">;</span>      <span class="cm">/* Pointer to full GMT header for the grid */</span>
    <span class="kt">float</span>                  <span class="o">*</span><span class="n">data</span><span class="p">;</span>        <span class="cm">/* Pointer to the float grid */</span>
    <span class="cm">/* ---- Variables &quot;hidden&quot; from the API ---- */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>            <span class="n">id</span><span class="p">;</span>          <span class="cm">/* Internal number of the grid */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>            <span class="n">alloc_level</span><span class="p">;</span> <span class="cm">/* Level it was allocated at */</span>
    <span class="k">enum</span> <span class="n">GMT_enum_alloc</span>     <span class="n">alloc_mode</span><span class="p">;</span>  <span class="cm">/* Allocation mode [GMT_ALLOCATED_BY_GMT] */</span>
    <span class="kt">double</span>                 <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">y</span><span class="p">;</span>       <span class="cm">/* Vector of coordinates */</span>
    <span class="kt">void</span>                   <span class="o">*</span><span class="n">extra</span><span class="p">;</span>       <span class="cm">/* Row-by-row machinery information [NULL] */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The full definition of the <code class="docutils literal notranslate"><span class="pre">GMT_GRID_HEADER</span></code> structure.  Most of these members are only used internally:</p>
<div class="highlight-c notranslate" id="struct-gridheader"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">GMT_GRID_HEADER</span> <span class="p">{</span>
    <span class="cm">/* Variables we document for the API:</span>
<span class="cm">     * They are copied verbatim to the native grid header and must be 4-byte unsigned ints. */</span>
    <span class="kt">uint32_t</span> <span class="n">n_columns</span><span class="p">;</span>                   <span class="cm">/* Number of columns */</span>
    <span class="kt">uint32_t</span> <span class="n">n_rows</span><span class="p">;</span>                      <span class="cm">/* Number of rows */</span>
    <span class="kt">uint32_t</span> <span class="n">registration</span><span class="p">;</span>                <span class="cm">/* GMT_GRID_NODE_REG (0) or GMT_GRID_PIXEL_REG (1) */</span>

    <span class="cm">/* == The types of the following 12 elements must not be changed.</span>
<span class="cm">     * == They are also copied verbatim to the native grid header. */</span>
    <span class="kt">double</span> <span class="n">wesn</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>                         <span class="cm">/* Min/max x and y coordinates */</span>
    <span class="kt">double</span> <span class="n">z_min</span><span class="p">;</span>                           <span class="cm">/* Minimum z value */</span>
    <span class="kt">double</span> <span class="n">z_max</span><span class="p">;</span>                           <span class="cm">/* Maximum z value */</span>
    <span class="kt">double</span> <span class="n">inc</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>                          <span class="cm">/* x and y increment */</span>
    <span class="kt">double</span> <span class="n">z_scale_factor</span><span class="p">;</span>                  <span class="cm">/* grd values must be multiplied by this */</span>
    <span class="kt">double</span> <span class="n">z_add_offset</span><span class="p">;</span>                    <span class="cm">/* After scaling, add this */</span>
    <span class="kt">char</span>   <span class="n">x_units</span><span class="p">[</span><span class="n">GMT_GRID_UNIT_LEN80</span><span class="p">];</span>    <span class="cm">/* units in x-direction */</span>
    <span class="kt">char</span>   <span class="n">y_units</span><span class="p">[</span><span class="n">GMT_GRID_UNIT_LEN80</span><span class="p">];</span>    <span class="cm">/* units in y-direction */</span>
    <span class="kt">char</span>   <span class="n">z_units</span><span class="p">[</span><span class="n">GMT_GRID_UNIT_LEN80</span><span class="p">];</span>    <span class="cm">/* grid value units */</span>
    <span class="kt">char</span>   <span class="n">title</span><span class="p">[</span><span class="n">GMT_GRID_TITLE_LEN80</span><span class="p">];</span>     <span class="cm">/* name of data set */</span>
    <span class="kt">char</span>   <span class="n">command</span><span class="p">[</span><span class="n">GMT_GRID_COMMAND_LEN320</span><span class="p">];</span><span class="cm">/* name of generating command */</span>
    <span class="kt">char</span>   <span class="n">remark</span><span class="p">[</span><span class="n">GMT_GRID_REMARK_LEN160</span><span class="p">];</span>  <span class="cm">/* comments re this data set */</span>
    <span class="cm">/* == End of &quot;untouchable&quot; header.       */</span>

    <span class="cm">/* ---- Variables &quot;hidden&quot; from the API ----</span>
<span class="cm">     * This section is flexible.  It is not copied to any grid header</span>
<span class="cm">     * or stored in any file. It is considered private */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">;</span>               <span class="cm">/* Grid format */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">;</span>               <span class="cm">/* Bits per value (e.g., 32 for ints/floats; 8 for bytes) */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">complex_mode</span><span class="p">;</span>       <span class="cm">/* 0 = normal, GMT_GRID_IS_COMPLEX_REAL = real part of complex</span>
<span class="cm">                                                                                grid, GMT_GRID_IS_COMPLEX_IMAG = imag part of complex grid */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mx</span><span class="p">,</span> <span class="n">my</span><span class="p">;</span>             <span class="cm">/* Actual dimensions of the grid in memory, allowing for the padding */</span>
    <span class="kt">size_t</span>       <span class="n">nm</span><span class="p">;</span>                 <span class="cm">/* Number of data items in this grid (n_columns * n_rows) [padding is excluded] */</span>
    <span class="kt">size_t</span>       <span class="n">size</span><span class="p">;</span>               <span class="cm">/* Actual number of items (not bytes) required to hold this grid (= mx * my) */</span>
    <span class="kt">size_t</span>       <span class="n">n_alloc</span><span class="p">;</span>            <span class="cm">/* Bytes allocated for this grid */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">trendmode</span><span class="p">;</span>          <span class="cm">/* Holds status for detrending of grids. 0 if not detrended, 1 if mean, 2 if mid-value, and 3 if LS plane removed */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">arrangement</span><span class="p">;</span>        <span class="cm">/* Holds status for complex grid as how the read/imag is placed in the grid (interleaved, R only, etc.) */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n_bands</span><span class="p">;</span>            <span class="cm">/* Number of bands [1]. Used with IMAGE containers and macros to get ij index from row,col, band */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pad</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>             <span class="cm">/* Padding on west, east, south, north sides [2,2,2,2] */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">BC</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>              <span class="cm">/* Boundary condition applied on each side via pad [0 = not set, 1 = natural, 2 = periodic, 3 = data] */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">grdtype</span><span class="p">;</span>            <span class="cm">/* 0 for Cartesian, &gt; 0 for geographic and depends on 360 periodicity [see GMT_enum_grdtype above] */</span>
    <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">GMT_GRID_NAME_LEN256</span><span class="p">];</span> <span class="cm">/* Actual name of the file after any ?&lt;varname&gt; and =&lt;stuff&gt; has been removed */</span>
    <span class="kt">char</span> <span class="n">varname</span><span class="p">[</span><span class="n">GMT_GRID_VARNAME_LEN80</span><span class="p">];</span><span class="cm">/* NetCDF: variable name */</span>
    <span class="k">const</span> <span class="kt">char</span>  <span class="o">*</span><span class="n">ProjRefPROJ4</span><span class="p">;</span>       <span class="cm">/* To store a referencing system string in PROJ.4 format */</span>
    <span class="k">const</span> <span class="kt">char</span>  <span class="o">*</span><span class="n">ProjRefWKT</span><span class="p">;</span>         <span class="cm">/* To store a referencing system string in WKT format */</span>
    <span class="kt">int</span>          <span class="n">row_order</span><span class="p">;</span>          <span class="cm">/* NetCDF: k_nc_start_south if S-&gt;N, k_nc_start_north if N-&gt;S */</span>
    <span class="kt">int</span>          <span class="n">z_id</span><span class="p">;</span>               <span class="cm">/* NetCDF: id of z field */</span>
    <span class="kt">int</span>          <span class="n">ncid</span><span class="p">;</span>               <span class="cm">/* NetCDF: file ID */</span>
    <span class="kt">int</span>          <span class="n">xy_dim</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>          <span class="cm">/* NetCDF: dimension order of x and y; normally {1, 0} */</span>
    <span class="kt">size_t</span>       <span class="n">t_index</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>         <span class="cm">/* NetCDF: index of higher coordinates */</span>
    <span class="kt">size_t</span>       <span class="n">data_offset</span><span class="p">;</span>        <span class="cm">/* NetCDF: distance from the beginning of the in-memory grid */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stride</span><span class="p">;</span>             <span class="cm">/* NetCDF: distance between two rows in the in-memory grid */</span>
    <span class="kt">float</span>        <span class="n">nan_value</span><span class="p">;</span>          <span class="cm">/* Missing value as stored in grid file */</span>
    <span class="kt">double</span>       <span class="n">xy_off</span><span class="p">;</span>             <span class="cm">/* 0.0 (registration == GMT_GRID_NODE_REG) or 0.5 ( == GMT_GRID_PIXEL_REG) */</span>
    <span class="kt">double</span>       <span class="n">r_inc</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>           <span class="cm">/* Reciprocal incs, i.e. 1/inc */</span>
    <span class="kt">char</span>         <span class="n">flags</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>           <span class="cm">/* Flags used for ESRI grids */</span>
    <span class="kt">char</span>        <span class="o">*</span><span class="n">pocket</span><span class="p">;</span>             <span class="cm">/* GDAL: A working variable handy to transmit info between funcs e.g. +b&lt;band_info&gt; to gdalread */</span>
    <span class="kt">char</span>         <span class="n">mem_layout</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>      <span class="cm">/* 3 or 4 char code T|B R|C S|R|S (grd) or B|L|P + A|a (img) describing mem layout and interleaving */</span>
    <span class="kt">double</span>       <span class="n">bcr_threshold</span><span class="p">;</span>      <span class="cm">/* sum of cardinals must &gt;= threshold in bilinear; else NaN */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bcr_interpolant</span><span class="p">;</span>    <span class="cm">/* Interpolation function used (0, 1, 2, 3) */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bcr_n</span><span class="p">;</span>              <span class="cm">/* Width of the interpolation function */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nxp</span><span class="p">;</span>                <span class="cm">/* if X periodic, nxp &gt; 0 is the period in pixels  */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nyp</span><span class="p">;</span>                <span class="cm">/* if Y periodic, nxp &gt; 0 is the period in pixels  */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">no_BC</span><span class="p">;</span>              <span class="cm">/* If true we skip BC stuff entirely */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gn</span><span class="p">;</span>                 <span class="cm">/* true if top    edge will be set as N pole  */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gs</span><span class="p">;</span>                 <span class="cm">/* true if bottom edge will be set as S pole  */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">is_netcdf4</span><span class="p">;</span>         <span class="cm">/* true if netCDF-4/HDF5 format */</span>
    <span class="kt">size_t</span>       <span class="n">z_chunksize</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>     <span class="cm">/* chunk size (lat,lon) */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">z_shuffle</span><span class="p">;</span>          <span class="cm">/* if shuffle filter is turned on */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">z_deflate_level</span><span class="p">;</span>    <span class="cm">/* if deflate filter is in use */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">z_scale_autoadjust</span><span class="p">;</span> <span class="cm">/* if z_scale_factor should be auto-detected */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">z_offset_autoadjust</span><span class="p">;</span><span class="cm">/* if z_add_offset should be auto-detected */</span>
                                     <span class="cm">/* xy_*[] is separate settings for GMT_IN and GMT_OUT */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">xy_adjust</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>       <span class="cm">/* 1 if +u&lt;unit&gt; was parsed and scale set, 3 if xy has been adjusted, 0 otherwise */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">xy_mode</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>         <span class="cm">/* 1 if +U&lt;unit&gt; was parsed, 0 otherwise */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">xy_unit</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>         <span class="cm">/* Unit enum specified via +u&lt;unit&gt; */</span>
    <span class="kt">double</span>       <span class="n">xy_unit_to_meter</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="cm">/* Scale, given xy_unit, to convert xy from &lt;unit&gt; to meters */</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="gmt-image">
<h3>6.6.3. GMT image<a class="headerlink" href="#gmt-image" title="Permalink to this headline">¶</a></h3>
<p>An image is similar to a grid except it may have more than one layer (i.e., band).
It is represented by a <a class="reference internal" href="#struct-image"><span class="std std-ref">GMT_IMAGE</span></a> structure that consists of the
<a class="reference internal" href="#struct-gridheader"><span class="std std-ref">GMT_GRID_HEADER</span></a> structure and an char array <code class="docutils literal notranslate"><span class="pre">data</span></code> that
contains the image values.  The type of the array is determined by the value of <code class="docutils literal notranslate"><span class="pre">type</span></code>.</p>
<div class="highlight-c notranslate" id="struct-image"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">GMT_IMAGE</span> <span class="p">{</span>
    <span class="k">enum</span> <span class="n">GMT_enum_type</span>      <span class="n">type</span><span class="p">;</span>             <span class="cm">/* Data type, e.g. GMT_FLOAT */</span>
    <span class="kt">int</span>                    <span class="o">*</span><span class="n">colormap</span><span class="p">;</span>         <span class="cm">/* Array with color lookup values */</span>
    <span class="kt">int</span>                     <span class="n">n_indexed_colors</span><span class="p">;</span> <span class="cm">/* Number of colors in a color-mapped image */</span>
    <span class="k">struct</span> <span class="n">GMT_GRID_HEADER</span> <span class="o">*</span><span class="n">header</span><span class="p">;</span>           <span class="cm">/* Pointer to full GMT header for the image */</span>
    <span class="kt">unsigned</span> <span class="kt">char</span>          <span class="o">*</span><span class="n">data</span><span class="p">;</span>             <span class="cm">/* Pointer to actual image */</span>
    <span class="cm">/* ---- Variables &quot;hidden&quot; from the API ---- */</span>
    <span class="kt">uint64_t</span>                <span class="n">id</span><span class="p">;</span>               <span class="cm">/* The internal number of the data set */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>            <span class="n">alloc_level</span><span class="p">;</span>      <span class="cm">/* Level of initial allocation */</span>
    <span class="k">enum</span> <span class="n">GMT_enum_alloc</span>     <span class="n">alloc_mode</span><span class="p">;</span>       <span class="cm">/* Allocation info [0] */</span>
    <span class="k">const</span> <span class="kt">char</span>             <span class="o">*</span><span class="n">color_interp</span><span class="p">;</span>     <span class="cm">/* Color interpretation name */</span>
    <span class="kt">double</span>                 <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">y</span><span class="p">;</span>            <span class="cm">/* Vector of coordinates */</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="cpt-palette-table">
<h3>6.6.4. CPT palette table<a class="headerlink" href="#cpt-palette-table" title="Permalink to this headline">¶</a></h3>
<p>A CPT is represented by a <a class="reference internal" href="#struct-palette"><span class="std std-ref">GMT_PALETTE</span></a> structure that contains several
items, such as a <a class="reference internal" href="#struct-lut"><span class="std std-ref">GMT_LUT</span></a> structure <code class="docutils literal notranslate"><span class="pre">data</span></code> that
contains the color information per interval.  The background, foreground and Nan-color values have
colors specified by the <a class="reference internal" href="#struct-bnf"><span class="std std-ref">GMT_BFN</span></a> array structure <code class="docutils literal notranslate"><span class="pre">bfn</span></code>.  As each actual
color may be specified in different ways, including as an image, each color slice is represented by
the <a class="reference internal" href="#struct-fill"><span class="std std-ref">GMT_FILL</span></a> structure.</p>
<div class="highlight-c notranslate" id="struct-palette"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">GMT_PALETTE</span> <span class="p">{</span>         <span class="cm">/* Holds all pen, color, and fill-related parameters */</span>
    <span class="cm">/* Variables we document for the API: */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>          <span class="n">n_headers</span><span class="p">;</span>          <span class="cm">/* Number of CPT header records (0 if no header) */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>          <span class="n">n_colors</span><span class="p">;</span>           <span class="cm">/* Number of colors in CPT lookup table */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>          <span class="n">mode</span><span class="p">;</span>               <span class="cm">/* Flags controlling use of BFN colors */</span>
    <span class="k">struct</span> <span class="n">GMT_LUT</span>       <span class="o">*</span><span class="n">data</span><span class="p">;</span>               <span class="cm">/* CPT lookup data read by GMT_read_cpt */</span>
    <span class="k">struct</span> <span class="n">GMT_BFN</span>        <span class="n">bfn</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>             <span class="cm">/* Structures with back/fore/nan fills */</span>
    <span class="kt">char</span>                <span class="o">**</span><span class="n">header</span><span class="p">;</span>             <span class="cm">/* Array with all CPT header records, if any) */</span>
    <span class="cm">/* ---- Variables &quot;hidden&quot; from the API ---- */</span>
    <span class="kt">uint64_t</span>              <span class="n">id</span><span class="p">;</span>                 <span class="cm">/* The internal number of the data set */</span>
    <span class="k">enum</span> <span class="n">GMT_enum_alloc</span>   <span class="n">alloc_mode</span><span class="p">;</span>         <span class="cm">/* Allocation mode [GMT_ALLOCATED_BY_GMT] */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>          <span class="n">alloc_level</span><span class="p">;</span>        <span class="cm">/* The level it was allocated at */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>          <span class="n">model</span><span class="p">;</span>              <span class="cm">/* RGB, HSV, CMYK */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>          <span class="n">is_gray</span><span class="p">;</span>            <span class="cm">/* true if only grayshades are needed */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>          <span class="n">is_bw</span><span class="p">;</span>              <span class="cm">/* true if only black and white are needed */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>          <span class="n">is_continuous</span><span class="p">;</span>      <span class="cm">/* true if continuous color tables have been given */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>          <span class="n">has_pattern</span><span class="p">;</span>        <span class="cm">/* true if CPT contains any patterns */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>          <span class="n">skip</span><span class="p">;</span>               <span class="cm">/* true if current z-slice is to be skipped */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>          <span class="n">categorical</span><span class="p">;</span>        <span class="cm">/* true if CPT applies to categorical data */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>          <span class="n">z_adjust</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>        <span class="cm">/* 1 if +u&lt;unit&gt; was parsed and scale set, 3 if z has been adjusted, 0 otherwise */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>          <span class="n">z_mode</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>          <span class="cm">/* 1 if +U&lt;unit&gt; was parsed, 0 otherwise */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>          <span class="n">z_unit</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>          <span class="cm">/* Unit enum specified via +u&lt;unit&gt; */</span>
    <span class="kt">double</span>                <span class="n">z_unit_to_meter</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="cm">/* Scale, given z_unit, to convert z from &lt;unit&gt; to meters */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The full definition of the <code class="docutils literal notranslate"><span class="pre">GMT_LUT</span></code> structure.</p>
<div class="highlight-c notranslate" id="struct-lut"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">GMT_LUT</span> <span class="p">{</span>         <span class="cm">/* For back-, fore-, and nan-colors */</span>
    <span class="kt">double</span>                <span class="n">z_low</span><span class="p">,</span> <span class="n">z_high</span><span class="p">,</span> <span class="n">i_dz</span><span class="p">;</span>
    <span class="kt">double</span>                <span class="n">rgb_low</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">rgb_high</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">rgb_diff</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
    <span class="kt">double</span>                <span class="n">hsv_low</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">hsv_high</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">hsv_diff</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>          <span class="n">annot</span><span class="p">;</span>              <span class="cm">/* 1 for Lower, 2 for Upper, 3 for Both */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>          <span class="n">skip</span><span class="p">;</span>               <span class="cm">/* true means skip this slice */</span>
    <span class="k">struct</span> <span class="n">GMT_FILL</span>      <span class="o">*</span><span class="n">fill</span><span class="p">;</span>               <span class="cm">/* For patterns instead of color */</span>
    <span class="kt">char</span>                 <span class="o">*</span><span class="n">label</span><span class="p">;</span>              <span class="cm">/* For non-number labels */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The full definition of the <code class="docutils literal notranslate"><span class="pre">GMT_BFN</span></code> structure:</p>
<div class="highlight-c notranslate" id="struct-bnf"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">GMT_BFN</span> <span class="p">{</span>   <span class="cm">/* For back-, fore-, and nan-colors */</span>
    <span class="kt">double</span>                <span class="n">rgb</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>             <span class="cm">/* Red, green, blue, and alpha */</span>
    <span class="kt">double</span>                <span class="n">hsv</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>             <span class="cm">/* Hue, saturation, value, alpha */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>          <span class="n">skip</span><span class="p">;</span>               <span class="cm">/* true means skip this slice */</span>
    <span class="k">struct</span> <span class="n">GMT_FILL</span>      <span class="o">*</span><span class="n">fill</span><span class="p">;</span>               <span class="cm">/* For patterns instead of color */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The full definition of the <code class="docutils literal notranslate"><span class="pre">GMT_FILL</span></code> structure.  Note: Not part of the GMT API:</p>
<div class="highlight-c notranslate" id="struct-fill"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">GMT_FILL</span> <span class="p">{</span>        <span class="cm">/*! Holds fill attributes */</span>
    <span class="kt">double</span>                <span class="n">rgb</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>             <span class="cm">/* Chosen color if no pattern + Transparency 0-1 [0 = opaque] */</span>
    <span class="kt">double</span>                <span class="n">f_rgb</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">b_rgb</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span> <span class="cm">/* Colors applied to unset and set bits in 1-bit image */</span>
    <span class="kt">bool</span>                  <span class="n">use_pattern</span><span class="p">;</span>        <span class="cm">/* true if pattern rather than rgb is set */</span>
    <span class="kt">int</span>                   <span class="n">pattern_no</span><span class="p">;</span>         <span class="cm">/* Number of a predefined pattern, or -1 if not set */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>          <span class="n">dpi</span><span class="p">;</span>                <span class="cm">/* Desired dpi of image building-block if use_pattern is true */</span>
    <span class="kt">char</span>                  <span class="n">pattern</span><span class="p">[</span><span class="n">GMT_BUFSIZ</span><span class="p">];</span><span class="cm">/* Full filename of user-defined raster pattern */</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="postscript-text">
<h3>6.6.5. PostScript text<a class="headerlink" href="#postscript-text" title="Permalink to this headline">¶</a></h3>
<p>Bulk PostScript is represented by a <a class="reference internal" href="#struct-postscript"><span class="std std-ref">GMT_POSTSCRIPT</span></a> structure that contains
<code class="docutils literal notranslate"><span class="pre">data</span></code> that points to the text array containing <code class="docutils literal notranslate"><span class="pre">n_bytes</span></code> characters of raw PostScript code.  The
<code class="docutils literal notranslate"><span class="pre">mode</span></code> parameter reflects the status of the PostScript document.</p>
<div class="highlight-c notranslate" id="struct-postscript"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">GMT_POSTSCRIPT</span> <span class="p">{</span>      <span class="cm">/* Single container for a chunk of PostScript code */</span>
    <span class="cm">/* Variables we document for the API: */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n_headers</span><span class="p">;</span>          <span class="cm">/* Number of PostScript header records (0 if no header) */</span>
    <span class="kt">size_t</span> <span class="n">n_alloc</span><span class="p">;</span>                  <span class="cm">/* Length of array allocated so far */</span>
    <span class="kt">size_t</span> <span class="n">n_bytes</span><span class="p">;</span>                  <span class="cm">/* Length of data array so far */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">;</span>               <span class="cm">/* Bit-flag for header (1) and trailer (2) */</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>                      <span class="cm">/* Pointer to PostScript code */</span>
    <span class="kt">char</span> <span class="o">**</span><span class="n">header</span><span class="p">;</span>                   <span class="cm">/* Array with all PostScript header records, if any) */</span>
    <span class="cm">/* ---- Variables &quot;hidden&quot; from the API ---- */</span>
    <span class="kt">uint64_t</span> <span class="n">id</span><span class="p">;</span>                     <span class="cm">/* The internal number of the data set */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">alloc_level</span><span class="p">;</span>        <span class="cm">/* The level it was allocated at */</span>
    <span class="k">enum</span> <span class="n">GMT_enum_alloc</span> <span class="n">alloc_mode</span><span class="p">;</span>  <span class="cm">/* Allocation mode [GMT_ALLOC_INTERNALLY] */</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="text-set">
<h3>6.6.6. Text set<a class="headerlink" href="#text-set" title="Permalink to this headline">¶</a></h3>
<p>Each text set is represented by a <a class="reference internal" href="#struct-textset"><span class="std std-ref">GMT_TEXTSET</span></a> that consists of one or more text
tables represented by a <a class="reference internal" href="#struct-texttable"><span class="std std-ref">GMT_TEXTTABLE</span></a>, and each table consists of one or more
segments represented by a <a class="reference internal" href="#struct-textsegment"><span class="std std-ref">GMT_TEXTSEGMENT</span></a>, and each segment contains one or
more rows of strings.</p>
<div class="highlight-c notranslate" id="struct-textset"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">GMT_TEXTSET</span> <span class="p">{</span> <span class="cm">/* Single container for an array of GMT text tables (files) */</span>
    <span class="cm">/* Variables we document for the API: */</span>
    <span class="kt">uint64_t</span>               <span class="n">n_tables</span><span class="p">;</span>     <span class="cm">/* The total number of tables (files) contained */</span>
    <span class="kt">uint64_t</span>               <span class="n">n_segments</span><span class="p">;</span>   <span class="cm">/* The total number of segments across all tables */</span>
    <span class="kt">uint64_t</span>               <span class="n">n_records</span><span class="p">;</span>    <span class="cm">/* The total number of data records across all tables */</span>
    <span class="k">struct</span> <span class="n">GMT_TEXTTABLE</span> <span class="o">**</span><span class="n">table</span><span class="p">;</span>        <span class="cm">/* Pointer to array of tables */</span>
    <span class="cm">/* ---- Variables &quot;hidden&quot; from the API ---- */</span>
    <span class="kt">uint64_t</span>               <span class="n">id</span><span class="p">;</span>           <span class="cm">/* The internal number of the data set */</span>
    <span class="kt">size_t</span>                 <span class="n">n_alloc</span><span class="p">;</span>      <span class="cm">/* The current allocation length of tables */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>           <span class="n">geometry</span><span class="p">;</span>     <span class="cm">/* The geometry of this dataset */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>           <span class="n">alloc_level</span><span class="p">;</span>  <span class="cm">/* The level it was allocated at */</span>
    <span class="k">enum</span> <span class="n">GMT_enum_dest</span>     <span class="n">io_mode</span><span class="p">;</span>      <span class="cm">/*-1 means write OGR format (requires proper -a),</span>
<span class="cm">                                            0 means write everything to one destination [Default],</span>
<span class="cm">                                            1 means use table-&gt;file[GMT_OUT] to write separate table,</span>
<span class="cm">                                            2 means use segment-&gt;file[GMT_OUT] to write separate segments.</span>
<span class="cm">                                            3 is same as 2 but with no filenames we create filenames</span>
<span class="cm">                                              from tbl and seg numbers */</span>
    <span class="k">enum</span> <span class="n">GMT_enum_alloc</span>    <span class="n">alloc_mode</span><span class="p">;</span>   <span class="cm">/* Allocation mode [GMT_ALLOCATED_BY_GMT] */</span>
    <span class="kt">char</span>                  <span class="o">*</span><span class="n">file</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>      <span class="cm">/* Name of file or source [0 = in, 1 = out] */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The full definition of the <code class="docutils literal notranslate"><span class="pre">GMT_TEXTTABLE</span></code> structure:</p>
<div class="highlight-c notranslate" id="struct-texttable"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">GMT_TEXTTABLE</span> <span class="p">{</span>  <span class="cm">/* To hold an array of text segment structures and header information in one container */</span>
    <span class="cm">/* Variables we document for the API: */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n_headers</span><span class="p">;</span>   <span class="cm">/* Number of file header records (0 if no header) */</span>
    <span class="kt">uint64_t</span> <span class="n">n_segments</span><span class="p">;</span>      <span class="cm">/* Number of segments in the array */</span>
    <span class="kt">uint64_t</span> <span class="n">n_records</span><span class="p">;</span>       <span class="cm">/* Total number of data records across all segments */</span>
    <span class="kt">char</span>   <span class="o">**</span><span class="n">header</span><span class="p">;</span>          <span class="cm">/* Array with all file header records, if any) */</span>
    <span class="k">struct</span> <span class="n">GMT_TEXTSEGMENT</span> <span class="o">**</span><span class="n">segment</span><span class="p">;</span> <span class="cm">/* Pointer to array of segments */</span>
    <span class="cm">/* ---- Variables &quot;hidden&quot; from the API ---- */</span>
    <span class="kt">uint64_t</span> <span class="n">id</span><span class="p">;</span>              <span class="cm">/* The internal number of the table */</span>
    <span class="kt">size_t</span>   <span class="n">n_alloc</span><span class="p">;</span>         <span class="cm">/* The current allocation length of segments */</span>
    <span class="k">enum</span> <span class="n">GMT_enum_write</span> <span class="n">mode</span><span class="p">;</span> <span class="cm">/* 0 = output table, 1 = output header only, 2 = skip table */</span>
    <span class="kt">char</span>    <span class="o">*</span><span class="n">file</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>         <span class="cm">/* Name of file or source [0 = in, 1 = out] */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The full definition of the <code class="docutils literal notranslate"><span class="pre">GMT_TEXTSEGMENT</span></code> structure:</p>
<div class="highlight-c notranslate" id="struct-textsegment"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">GMT_TEXTSEGMENT</span> <span class="p">{</span>      <span class="cm">/* For holding segment text records in memory */</span>
    <span class="cm">/* Variables we document for the API: */</span>
    <span class="kt">uint64_t</span> <span class="n">n_rows</span><span class="p">;</span>          <span class="cm">/* Number of rows in this segment */</span>
    <span class="kt">char</span>   <span class="o">**</span><span class="n">data</span><span class="p">;</span>            <span class="cm">/* Array of text records */</span>
    <span class="kt">char</span>    <span class="o">*</span><span class="n">label</span><span class="p">;</span>           <span class="cm">/* Label string (if applicable) */</span>
    <span class="kt">char</span>    <span class="o">*</span><span class="n">header</span><span class="p">;</span>          <span class="cm">/* Segment header (if applicable) */</span>
    <span class="cm">/* ---- Variables &quot;hidden&quot; from the API ---- */</span>
    <span class="kt">uint64_t</span> <span class="n">id</span><span class="p">;</span>              <span class="cm">/* The internal number of the table */</span>
    <span class="k">enum</span> <span class="n">GMT_enum_write</span> <span class="n">mode</span><span class="p">;</span> <span class="cm">/* 0 = output segment, 1 = output header only, 2 = skip segment */</span>
    <span class="kt">size_t</span>   <span class="n">n_alloc</span><span class="p">;</span>         <span class="cm">/* Number of rows allocated for this segment */</span>
    <span class="kt">char</span>    <span class="o">*</span><span class="n">file</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>         <span class="cm">/* Name of file or source [0 = in, 1 = out] */</span>
    <span class="kt">char</span>   <span class="o">**</span><span class="n">tvalue</span><span class="p">;</span>          <span class="cm">/* The values of the OGR/GMT aspatial fields */</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="matrix">
<h3>6.6.7. Matrix<a class="headerlink" href="#matrix" title="Permalink to this headline">¶</a></h3>
<p>User matrices are represented by a <a class="reference internal" href="#struct-matrix"><span class="std std-ref">GMT_MATRIX</span></a> structure that contains
<code class="docutils literal notranslate"><span class="pre">data</span></code> that points to an array of size <code class="docutils literal notranslate"><span class="pre">n_columns</span></code> by <code class="docutils literal notranslate"><span class="pre">n_rows</span></code>.  The
<code class="docutils literal notranslate"><span class="pre">type</span></code> indicates the memory type of the matrix, which is represented
by the <a class="reference internal" href="#struct-univector"><span class="std std-ref">GMT_UNIVECTOR</span></a> union.</p>
<div class="highlight-c notranslate" id="struct-matrix"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">GMT_MATRIX</span> <span class="p">{</span>
    <span class="kt">uint64_t</span>             <span class="n">n_rows</span><span class="p">;</span>        <span class="cm">/* Number of rows in the matrix */</span>
    <span class="kt">uint64_t</span>             <span class="n">n_columns</span><span class="p">;</span>     <span class="cm">/* Number of columns in the matrix */</span>
    <span class="kt">uint64_t</span>             <span class="n">n_layers</span><span class="p">;</span>      <span class="cm">/* Number of layers in a 3-D matrix */</span>
    <span class="k">enum</span> <span class="n">GMT_enum_fmt</span>    <span class="n">shape</span><span class="p">;</span>         <span class="cm">/* 0 = C (rows) and 1 = Fortran (cols) */</span>
    <span class="k">enum</span> <span class="n">GMT_enum_reg</span>    <span class="n">registration</span><span class="p">;</span>  <span class="cm">/* 0 for gridline and 1 for pixel registration  */</span>
    <span class="kt">size_t</span>               <span class="n">dim</span><span class="p">;</span>           <span class="cm">/* Allocated length of longest C or Fortran dim */</span>
    <span class="kt">size_t</span>               <span class="n">size</span><span class="p">;</span>          <span class="cm">/* Byte length of data */</span>
    <span class="k">enum</span> <span class="n">GMT_enum_type</span>   <span class="n">type</span><span class="p">;</span>          <span class="cm">/* Data type, e.g. GMT_FLOAT */</span>
    <span class="kt">double</span>               <span class="n">range</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>      <span class="cm">/* Contains xmin/xmax/ymin/ymax[/zmin/zmax] */</span>
    <span class="k">union</span> <span class="n">GMT_UNIVECTOR</span>  <span class="n">data</span><span class="p">;</span>          <span class="cm">/* Union with pointer to actual matrix of the chosen type */</span>
    <span class="kt">char</span> <span class="n">command</span><span class="p">[</span><span class="n">GMT_GRID_COMMAND_LEN320</span><span class="p">];</span> <span class="cm">/* name of generating command */</span>
    <span class="kt">char</span> <span class="n">remark</span><span class="p">[</span><span class="n">GMT_GRID_REMARK_LEN160</span><span class="p">];</span>   <span class="cm">/* comments re this data set */</span>
    <span class="cm">/* ---- Variables &quot;hidden&quot; from the API ---- */</span>
    <span class="kt">uint64_t</span>             <span class="n">id</span><span class="p">;</span>            <span class="cm">/* The internal number of the data set */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>         <span class="n">alloc_level</span><span class="p">;</span>   <span class="cm">/* The level it was allocated at */</span>
    <span class="k">enum</span> <span class="n">GMT_enum_alloc</span>  <span class="n">alloc_mode</span><span class="p">;</span>    <span class="cm">/* Allocation mode [GMT_ALLOCATED_BY_GMT] */</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="vectors">
<h3>6.6.8. Vectors<a class="headerlink" href="#vectors" title="Permalink to this headline">¶</a></h3>
<p>User vectors are represented by a <a class="reference internal" href="#struct-vector"><span class="std std-ref">GMT_VECTOR</span></a> structure that contains
<code class="docutils literal notranslate"><span class="pre">data</span></code> that points to an array of <code class="docutils literal notranslate"><span class="pre">n_columns</span></code> individual vectors.  The
<code class="docutils literal notranslate"><span class="pre">type</span></code> array indicates the memory type of each vector.  Each vector is represented
by the <a class="reference internal" href="#struct-univector"><span class="std std-ref">GMT_UNIVECTOR</span></a> union which can accommodate any data type.</p>
<div class="highlight-c notranslate" id="struct-vector"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">GMT_VECTOR</span> <span class="p">{</span>
    <span class="kt">uint64_t</span>             <span class="n">n_columns</span><span class="p">;</span>     <span class="cm">/* Number of vectors */</span>
    <span class="kt">uint64_t</span>             <span class="n">n_rows</span><span class="p">;</span>        <span class="cm">/* Number of rows in each vector */</span>
    <span class="k">enum</span> <span class="n">GMT_enum_reg</span>    <span class="n">registration</span><span class="p">;</span>  <span class="cm">/* 0 for gridline and 1 for pixel registration */</span>
    <span class="k">enum</span> <span class="n">GMT_enum_type</span>  <span class="o">*</span><span class="n">type</span><span class="p">;</span>          <span class="cm">/* Array with data type for each vector */</span>
    <span class="k">union</span> <span class="n">GMT_UNIVECTOR</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>          <span class="cm">/* Array with unions for each column */</span>
    <span class="kt">double</span>               <span class="n">range</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>      <span class="cm">/* The min and max limits on t-range (or 0,0) */</span>
    <span class="kt">char</span> <span class="n">command</span><span class="p">[</span><span class="n">GMT_GRID_COMMAND_LEN320</span><span class="p">];</span> <span class="cm">/* name of generating command */</span>
    <span class="kt">char</span> <span class="n">remark</span><span class="p">[</span><span class="n">GMT_GRID_REMARK_LEN160</span><span class="p">];</span>   <span class="cm">/* comments re this data set */</span>
    <span class="cm">/* ---- Variables &quot;hidden&quot; from the API ---- */</span>
    <span class="kt">uint64_t</span>             <span class="n">id</span><span class="p">;</span>            <span class="cm">/* An identification number */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>         <span class="n">alloc_level</span><span class="p">;</span>   <span class="cm">/* Level of initial allocation */</span>
    <span class="k">enum</span> <span class="n">GMT_enum_alloc</span>  <span class="n">alloc_mode</span><span class="p">;</span>    <span class="cm">/* Determines if we may free the vectors or not */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The full definition of the <code class="docutils literal notranslate"><span class="pre">GMT_UNIVECTOR</span></code> union that holds a pointer to any array or matrix type:</p>
<div class="highlight-c notranslate" id="struct-univector"><div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">GMT_UNIVECTOR</span> <span class="p">{</span>
    <span class="kt">uint8_t</span>  <span class="o">*</span><span class="n">uc1</span><span class="p">;</span>       <span class="cm">/* Pointer for unsigned 1-byte array */</span>
    <span class="kt">int8_t</span>   <span class="o">*</span><span class="n">sc1</span><span class="p">;</span>       <span class="cm">/* Pointer for signed 1-byte array */</span>
    <span class="kt">uint16_t</span> <span class="o">*</span><span class="n">ui2</span><span class="p">;</span>       <span class="cm">/* Pointer for unsigned 2-byte array */</span>
    <span class="kt">int16_t</span>  <span class="o">*</span><span class="n">si2</span><span class="p">;</span>       <span class="cm">/* Pointer for signed 2-byte array */</span>
    <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">ui4</span><span class="p">;</span>       <span class="cm">/* Pointer for unsigned 4-byte array */</span>
    <span class="kt">int32_t</span>  <span class="o">*</span><span class="n">si4</span><span class="p">;</span>       <span class="cm">/* Pointer for signed 4-byte array */</span>
    <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">ui8</span><span class="p">;</span>       <span class="cm">/* Pointer for unsigned 8-byte array */</span>
    <span class="kt">int64_t</span>  <span class="o">*</span><span class="n">si8</span><span class="p">;</span>       <span class="cm">/* Pointer for signed 8-byte array */</span>
    <span class="kt">float</span>    <span class="o">*</span><span class="n">f4</span><span class="p">;</span>        <span class="cm">/* Pointer for float array */</span>
    <span class="kt">double</span>   <span class="o">*</span><span class="n">f8</span><span class="p">;</span>        <span class="cm">/* Pointer for double array */</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="appendix-b-gmt-constants">
<h2>6.7. Appendix B: GMT constants<a class="headerlink" href="#appendix-b-gmt-constants" title="Permalink to this headline">¶</a></h2>
<p>To increase readability we have encoded many simple integer constants as named
enum.  These are listed in the tables below and used as flags to various API
functions.</p>
<blockquote id="tbl-types">
<div><table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="75%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">constant</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>GMT_CHAR</td>
<td>int8_t, 1-byte signed integer type</td>
</tr>
<tr class="row-odd"><td>GMT_UCHAR</td>
<td>int8_t, 1-byte unsigned integer type</td>
</tr>
<tr class="row-even"><td>GMT_SHORT</td>
<td>int16_t, 2-byte signed integer type</td>
</tr>
<tr class="row-odd"><td>GMT_USHORT</td>
<td>uint16_t, 2-byte unsigned integer type</td>
</tr>
<tr class="row-even"><td>GMT_INT</td>
<td>int32_t, 4-byte signed integer type</td>
</tr>
<tr class="row-odd"><td>GMT_UINT</td>
<td>uint32_t, 4-byte unsigned integer type</td>
</tr>
<tr class="row-even"><td>GMT_LONG</td>
<td>int64_t, 8-byte signed integer type</td>
</tr>
<tr class="row-odd"><td>GMT_ULONG</td>
<td>uint64_t, 8-byte unsigned integer type</td>
</tr>
<tr class="row-even"><td>GMT_FLOAT</td>
<td>4-byte data float type</td>
</tr>
<tr class="row-odd"><td>GMT_DOUBLE</td>
<td>8-byte data float type</td>
</tr>
</tbody>
</table>
<p>The known data types in the GMT API.</p>
</div></blockquote>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>or via a very confusing and ever-changing myriad of low-level library
functions for bold programmers.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Currently, C/C++, FORTRAN, MATLAB and Julia are being tested.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>At the moment, GMT does not have native support for 3-D grids.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>This may change in later releases.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[5]</a></td><td>However, there is no thread-support yet, so you will need to manage your
own threads.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">1. Introduction</a><ul>
<li><a class="reference internal" href="#preamble">1.1. Preamble</a></li>
<li><a class="reference internal" href="#the-i-o-abstraction-layer">1.2. The i/o abstraction layer</a></li>
<li><a class="reference internal" href="#our-audience">1.3. Our audience</a></li>
<li><a class="reference internal" href="#definitions">1.4. Definitions</a></li>
<li><a class="reference internal" href="#gmt-resources">1.5. GMT resources</a><ul>
<li><a class="reference internal" href="#data-tables">1.5.1. Data tables</a></li>
<li><a class="reference internal" href="#gmt-grids">1.5.2. GMT grids</a></li>
<li><a class="reference internal" href="#gmt-images">1.5.3. GMT images</a></li>
<li><a class="reference internal" href="#color-palette-tables-cpt">1.5.4. Color palette tables (CPT)</a></li>
<li><a class="reference internal" href="#postscript-document">1.5.5. PostScript document</a></li>
<li><a class="reference internal" href="#text-tables">1.5.6. Text tables</a></li>
<li><a class="reference internal" href="#user-data-matrices">1.5.7. User data matrices</a></li>
<li><a class="reference internal" href="#user-data-columns">1.5.8. User data columns</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#overview-of-the-gmt-c-application-program-interface">2. Overview of the GMT C Application Program Interface</a><ul>
<li><a class="reference internal" href="#example-code">2.1. Example code</a></li>
<li><a class="reference internal" href="#compilation">2.2. Compilation</a></li>
<li><a class="reference internal" href="#plugins">2.3. Plugins</a></li>
<li><a class="reference internal" href="#list-of-api-functions">2.4. List of API functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-gmt-c-application-program-interface">3. The GMT C Application Program Interface</a><ul>
<li><a class="reference internal" href="#initialize-a-new-gmt-session">3.1. Initialize a new GMT session</a></li>
<li><a class="reference internal" href="#register-input-or-output-resources">3.2. Register input or output resources</a><ul>
<li><a class="reference internal" href="#resource-initialization">3.2.1. Resource initialization</a></li>
<li><a class="reference internal" href="#resource-registration">3.2.2. Resource registration</a></li>
</ul>
</li>
<li><a class="reference internal" href="#create-empty-resources">3.3. Create empty resources</a><ul>
<li><a class="reference internal" href="#hooking-user-arrays-to-objects">3.3.1. Hooking user arrays to objects</a></li>
<li><a class="reference internal" href="#manually-add-segments">3.3.2. Manually add segments</a></li>
</ul>
</li>
<li><a class="reference internal" href="#duplicate-resources">3.4. Duplicate resources</a></li>
<li><a class="reference internal" href="#convert-between-resource-types">3.5. Convert between resource types</a></li>
<li><a class="reference internal" href="#import-data-sets">3.6. Import Data Sets</a><ul>
<li><a class="reference internal" href="#import-from-a-file-stream-or-handle">3.6.1. Import from a file, stream, or handle</a></li>
<li><a class="reference internal" href="#import-a-group-of-data-sets">3.6.2. Import a group of data sets</a></li>
<li><a class="reference internal" href="#open-a-virtual-file-memory-location">3.6.3. Open a virtual file (memory location)</a></li>
<li><a class="reference internal" href="#import-from-a-virtual-file">3.6.4. Import from a virtual file</a></li>
<li><a class="reference internal" href="#reset-a-virtual-file-for-reuse">3.6.5. Reset a virtual file for reuse</a></li>
<li><a class="reference internal" href="#close-a-virtual-file">3.6.6. Close a virtual file</a></li>
</ul>
</li>
<li><a class="reference internal" href="#record-by-record-input">3.7. Record-by-record input</a><ul>
<li><a class="reference internal" href="#enable-data-import">3.7.1. Enable Data Import</a></li>
<li><a class="reference internal" href="#set-data-geometry">3.7.2. Set data geometry</a></li>
<li><a class="reference internal" href="#importing-a-data-record">3.7.3. Importing a data record</a></li>
<li><a class="reference internal" href="#examining-record-status">3.7.4. Examining record status</a></li>
<li><a class="reference internal" href="#importing-a-grid-row">3.7.5. Importing a grid row</a></li>
<li><a class="reference internal" href="#disable-data-import">3.7.6. Disable Data Import</a></li>
</ul>
</li>
<li><a class="reference internal" href="#manipulate-data">3.8. Manipulate data</a><ul>
<li><a class="reference internal" href="#manipulate-grids">3.8.1. Manipulate grids</a></li>
<li><a class="reference internal" href="#manipulate-data-tables">3.8.2. Manipulate data tables</a></li>
<li><a class="reference internal" href="#manipulate-text-tables">3.8.3. Manipulate text tables</a></li>
</ul>
</li>
<li><a class="reference internal" href="#message-and-verbose-reporting">3.9. Message and Verbose Reporting</a><ul>
<li><a class="reference internal" href="#verbose-reporting">3.9.1. Verbose reporting</a></li>
<li><a class="reference internal" href="#user-messages">3.9.2. User messages</a></li>
</ul>
</li>
<li><a class="reference internal" href="#special-gmt-modules">3.10. Special GMT modules</a><ul>
<li><a class="reference internal" href="#api-only-modules">3.10.1. API-only modules</a></li>
<li><a class="reference internal" href="#postscript-access">3.10.2. PostScript Access</a></li>
</ul>
</li>
<li><a class="reference internal" href="#adjusting-headers-and-comments">3.11. Adjusting headers and comments</a></li>
<li><a class="reference internal" href="#export-data-sets">3.12. Export Data Sets</a><ul>
<li><a class="reference internal" href="#exporting-a-data-set">3.12.1. Exporting a data set</a><ul>
<li><a class="reference internal" href="#exporting-a-data-set-to-a-file-stream-or-handle">3.12.1.1. Exporting a data set to a file, stream, or handle</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#record-by-record-output">3.13. Record-by-record output</a><ul>
<li><a class="reference internal" href="#enable-data-export">3.13.1. Enable Data Export</a><ul>
<li><a class="reference internal" href="#specifying-the-number-of-output-columns">3.13.1.1. Specifying the number of output columns</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exporting-a-data-record">3.13.2. Exporting a data record</a></li>
<li><a class="reference internal" href="#exporting-a-grid-row">3.13.3. Exporting a grid row</a></li>
<li><a class="reference internal" href="#disable-data-export">3.13.4. Disable Data Export</a></li>
</ul>
</li>
<li><a class="reference internal" href="#destroy-allocated-resources">3.14. Destroy allocated resources</a></li>
<li><a class="reference internal" href="#destroy-groups-of-allocated-resources">3.15. Destroy groups of allocated resources</a></li>
<li><a class="reference internal" href="#terminate-a-gmt-session">3.16. Terminate a GMT session</a></li>
<li><a class="reference internal" href="#presenting-and-accessing-gmt-options">3.17. Presenting and accessing GMT options</a><ul>
<li><a class="reference internal" href="#display-usage-syntax-for-gmt-common-options">3.17.1. Display usage syntax for GMT common options</a></li>
<li><a class="reference internal" href="#parsing-the-gmt-common-options">3.17.2. Parsing the GMT common options</a></li>
<li><a class="reference internal" href="#inquiring-about-the-gmt-common-options">3.17.3. Inquiring about the GMT common options</a></li>
<li><a class="reference internal" href="#parsing-text-values">3.17.4. Parsing text values</a></li>
<li><a class="reference internal" href="#get-or-set-an-api-or-gmt-default-parameter">3.17.5. Get or set an API or GMT default parameter</a></li>
</ul>
</li>
<li><a class="reference internal" href="#call-a-module">3.18. Call a module</a><ul>
<li><a class="reference internal" href="#set-program-options-via-text-array-arguments">3.18.1. Set program options via text array arguments</a></li>
<li><a class="reference internal" href="#set-program-options-via-text-command">3.18.2. Set program options via text command</a></li>
<li><a class="reference internal" href="#set-program-options-via-linked-structures">3.18.3. Set program options via linked structures</a></li>
<li><a class="reference internal" href="#convert-between-text-and-linked-structures">3.18.4. Convert between text and linked structures</a></li>
<li><a class="reference internal" href="#manage-the-linked-list-of-options">3.18.5. Manage the linked list of options</a><ul>
<li><a class="reference internal" href="#make-a-new-option-structure">3.18.5.1. Make a new option structure</a></li>
<li><a class="reference internal" href="#append-an-option-to-the-linked-list">3.18.5.2. Append an option to the linked list</a></li>
<li><a class="reference internal" href="#find-an-option-in-the-linked-list">3.18.5.3. Find an option in the linked list</a></li>
<li><a class="reference internal" href="#update-an-existing-option-in-the-list">3.18.5.4. Update an existing option in the list</a></li>
<li><a class="reference internal" href="#delete-an-existing-option-in-the-linked-list">3.18.5.5. Delete an existing option in the linked list</a></li>
<li><a class="reference internal" href="#specify-a-file-via-a-linked-option">3.18.5.6. Specify a file via a linked option</a></li>
<li><a class="reference internal" href="#encode-option-arguments-for-external-interfaces">3.18.5.7. Encode option arguments for external interfaces</a></li>
<li><a class="reference internal" href="#expand-an-option-with-explicit-memory-references">3.18.5.8. Expand an option with explicit memory references</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#the-gmt-fft-interface">4. The GMT FFT Interface</a><ul>
<li><a class="reference internal" href="#presenting-and-parsing-the-fft-options">4.1. Presenting and parsing the FFT options</a></li>
<li><a class="reference internal" href="#initializing-the-fft-machinery">4.2. Initializing the FFT machinery</a></li>
<li><a class="reference internal" href="#taking-the-fft">4.3. Taking the FFT</a></li>
<li><a class="reference internal" href="#taking-the-1-d-fft">4.4. Taking the 1-D FFT</a></li>
<li><a class="reference internal" href="#taking-the-2-d-fft">4.5. Taking the 2-D FFT</a></li>
<li><a class="reference internal" href="#wavenumber-calculations">4.6. Wavenumber calculations</a><ul>
<li><a class="reference internal" href="#d-fft-manipulation">4.6.1. 1-D FFT manipulation</a></li>
<li><a class="reference internal" href="#id6">4.6.2. 2-D FFT manipulation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#destroying-the-fft-machinery">4.7. Destroying the FFT machinery</a></li>
</ul>
</li>
<li><a class="reference internal" href="#fortran-support">5. FORTRAN Support</a><ul>
<li><a class="reference internal" href="#fortran-77-grid-i-o">5.1. FORTRAN 77 Grid i/o</a></li>
</ul>
</li>
<li><a class="reference internal" href="#external-interfaces">6. External Interfaces</a><ul>
<li><a class="reference internal" href="#plain-interface">6.1. Plain interface</a></li>
<li><a class="reference internal" href="#data-containers">6.2. Data containers</a></li>
<li><a class="reference internal" href="#input-from-memory">6.3. Input from memory</a></li>
<li><a class="reference internal" href="#output-to-memory">6.4. Output to memory</a></li>
<li><a class="reference internal" href="#the-magic-of-knowing">6.5. The magic of knowing</a><ul>
<li><a class="reference internal" href="#the-matlab-interface">6.5.1. The MATLAB interface</a></li>
<li><a class="reference internal" href="#the-julia-interface">6.5.2. The Julia interface</a></li>
<li><a class="reference internal" href="#the-python-interface">6.5.3. The Python interface</a></li>
</ul>
</li>
<li><a class="reference internal" href="#appendix-a-gmt-resources">6.6. Appendix A: GMT resources</a><ul>
<li><a class="reference internal" href="#data-set">6.6.1. Data set</a></li>
<li><a class="reference internal" href="#gmt-grid">6.6.2. GMT grid</a></li>
<li><a class="reference internal" href="#gmt-image">6.6.3. GMT image</a></li>
<li><a class="reference internal" href="#cpt-palette-table">6.6.4. CPT palette table</a></li>
<li><a class="reference internal" href="#postscript-text">6.6.5. PostScript text</a></li>
<li><a class="reference internal" href="#text-set">6.6.6. Text set</a></li>
<li><a class="reference internal" href="#matrix">6.6.7. Matrix</a></li>
<li><a class="reference internal" href="#vectors">6.6.8. Vectors</a></li>
</ul>
</li>
<li><a class="reference internal" href="#appendix-b-gmt-constants">6.7. Appendix B: GMT constants</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="api.html"
                        title="previous chapter">GMT_API</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="ml_wrapper.html"
                        title="next chapter">MATLAB Wrapper</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/GMT_API.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="ml_wrapper.html" title="MATLAB Wrapper"
             >next</a> </li>
        <li class="right" >
          <a href="api.html" title="GMT_API"
             >previous</a> </li>
  <li><a href="/projects/gmt/wiki/Documentation">Project Home</a>  &#187;</li>
  
        <li class="nav-item nav-item-0"><a href="index.html">GMT 5.4.6_c5d65a4_2019.11.05 documentation</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="api.html" >GMT_API</a> &#187;</li>
<li class="right">
<form class="search" accept-charset="UTF-8" action="search.html" method="get">
  <div style="margin:0;padding:0;display:inline"><input name="utf8" type="hidden" value="✓"></div>
  <label for="q">
    <a class="search" href="search.html" accesskey="s" original-title="">Search:</a>
  </label>
  <input accesskey="f" class="small" id="q" name="q" size="20" type="text">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form></li>
   

      </ul>
    </div>
<div class="footer">
    &copy; Copyright 2019, The GMT Team.
  Last updated on Jun 14, 2020.
  Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.8.5.
  <br />Theme based on <a href="http://readthedocs.org/">Read The Docs</a>

</div>


  </body>
</html>