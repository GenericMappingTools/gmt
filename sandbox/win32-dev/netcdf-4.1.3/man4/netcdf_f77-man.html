<!-- Creator     : groff version 1.20.1 -->
<!-- CreationDate: Thu Jun 30 17:23:47 2011 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>NETCDF</title>

</head>
<body>

<h1 align="center">NETCDF</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#LIBRARY VERSION">LIBRARY VERSION</a><br>
<a href="#RETURN VALUES">RETURN VALUES</a><br>
<a href="#FILE OPERATIONS">FILE OPERATIONS</a><br>
<a href="#DIMENSIONS">DIMENSIONS</a><br>
<a href="#VARIABLES">VARIABLES</a><br>
<a href="#WRITING AND READING WHOLE VARIABLES">WRITING AND READING WHOLE VARIABLES</a><br>
<a href="#WRITING AND READING ONE DATUM">WRITING AND READING ONE DATUM</a><br>
<a href="#WRITING AND READING AN ARRAY">WRITING AND READING AN ARRAY</a><br>
<a href="#WRITING AND READING A SLICED ARRAY">WRITING AND READING A SLICED ARRAY</a><br>
<a href="#WRITING AND READING A MAPPED ARRAY">WRITING AND READING A MAPPED ARRAY</a><br>
<a href="#ATTRIBUTES">ATTRIBUTES</a><br>
<a href="#COMMON ARGUMENT DESCRIPTIONS">COMMON ARGUMENT DESCRIPTIONS</a><br>
<a href="#VARIABLE PREFILLING">VARIABLE PREFILLING</a><br>
<a href="#MPP FUNCTION DESCRIPTIONS">MPP FUNCTION DESCRIPTIONS</a><br>
<a href="#ENVIRONMENT VARIABLES">ENVIRONMENT VARIABLES</a><br>
<a href="#MAILING-LISTS">MAILING-LISTS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">netcdf &minus;
Unidata&rsquo;s Network Common Data Form (netCDF) library
interface</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>include
netcdf.inc</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Most
Systems:</b> <br>
f77 ... -lnetcdf</p>

<p style="margin-left:11%; margin-top: 1em"><b>CRAY PVP
Systems:</b> <br>
f90 -dp -i64 ... -lnetcdf</p>

<p style="margin-left:11%; margin-top: 1em">Complete
documentation for the netCDF libraries can be found at the
netCDF website:
http://www.unidata.ucar.edu/software/netcdf/.</p>

<h2>LIBRARY VERSION
<a name="LIBRARY VERSION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This document
describes version 3</p>

<p style="margin-left:11%; margin-top: 1em">of Unidata
netCDF data-access interface for the FORTRAN programming
language.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="51%">


<p style="margin-top: 1em"><b>character*80
nf_inq_libvers(void)</b></p> </td>
<td width="38%">
</td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Returns a
string identifying the version of the netCDF library, and
when it was built, like: &quot;3.1a of Aug 22 1996 12:57:47
$&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">The RCS
<b>ident(1)</b> command will find a string like &quot;$Id:
@(#) netcdf library version 3.1a of Sep 6 1996 15:56:26
$&quot; in the library. The SCCS <b>what(1)</b> command will
find a string like &quot;netcdf library version 3.1a of Aug
23 1996 16:07:40 $&quot;.</p>

<h2>RETURN VALUES
<a name="RETURN VALUES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">All netCDF
functions (except <b>nf_inq_libvers()</b> and
<b>nf_strerror()</b>) return an integer status.</p>

<p style="margin-left:11%; margin-top: 1em">If this
returned status value is not equal to <b>NF_NOERR</b>
(zero), it indicates that an error occurred. The possible
status values are defined in netcdf.inc.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="61%">


<p style="margin-top: 1em"><b>character*80
nf_strerror(integer</b> <i>status</i><b>)</b></p></td>
<td width="28%">
</td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Returns a
string textual translation of the <i>status</i> value, like
&quot;Attribute or variable name contains illegal
characters&quot; or &quot;No such file or
directory&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<h2>FILE OPERATIONS
<a name="FILE OPERATIONS"></a>
</h2>
<td width="11%"></td>
<td width="89%">


<p><b>integer function nf_create(character*(*)</b>
<i>path</i><b>, integer</b> <i>cmode</i><b>, integer</b>
<i>ncid</i><b>)</b></p> </td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Creates a new
netCDF dataset at <i>path</i>, returning a netCDF ID in
<i>ncid</i>. The argument <i>cmode</i> may include the
bitwise-or of the following flags: <b>NF_NOCLOBBER</b> to
protect existing datasets (default silently blows them
away), <b>NF_SHARE</b> for synchronous dataset updates for
classic format files (default is to buffer accesses),</p>

<p style="margin-left:22%; margin-top: 1em">When a netCDF
dataset is created, is is opened <b>NF_WRITE</b>. The new
netCDF dataset is in define mode. <b>NF_64BIT_OFFSET</b>. to
create a file in the 64-bit offset format (as opposed to
classic format, the default).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf__create(character*(*)</b> <i>path</i><b>, integer</b>
<i>cmode</i><b>, integer</b> <i>initialsize</i><b>,
integer</b> <i>chunksize</i><b>, integer</b>
<i>ncid</i><b>)</b></p> </td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Like
<b>nf_create()</b> but has additional performance tuning
parameters.</p>

<p style="margin-left:22%; margin-top: 1em">The argument
<i>initialsize</i> sets the initial size of the file at
creation time.</p>

<p style="margin-left:22%; margin-top: 1em">See
<b>nf__open()</b> below for an explanation of the
<i>chunksize</i> parameter.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_open(character*(*)</b> <i>path</i><b>, integer</b>
<i>mode</i><b>, integer</b> <i>ncid</i><b>)</b></p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">(Corresponds to
<b>ncopn()</b> in version 2)</p>

<p style="margin-left:22%; margin-top: 1em">Opens a
existing netCDF dataset at <i>path</i> returning a netCDF ID
in <i>ncid</i>. The type of access is described by the
<i>mode</i> parameter, which may include the bitwise-or of
the following flags: <b>NF_WRITE</b> for read-write access
(default read-only), <b>NF_SHARE</b> for synchronous dataset
updates (default is to buffer accesses), and <b>NF_LOCK</b>
(not yet implemented).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf__open(character*(*)</b> <i>path</i><b>, integer</b>
<i>mode</i><b>, integer</b> <i>chunksize</i><b>, integer</b>
<i>ncid</i><b>)</b></p> </td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Like
<b>nf_open()</b> but has an additional performance tuning
parameter.</p>

<p style="margin-left:22%; margin-top: 1em">The argument
referenced by <i>chunksize</i> controls a space versus time
tradeoff, memory allocated in the netcdf library versus
number of system calls. Because of internal requirements,
the value may not be set to exactly the value requested. The
actual value chosen is returned by reference. Using the
value <b>NF_SIZEHINT_DEFAULT</b> causes the library to
choose a default. How the system choses the default depends
on the system. On many systems, the &quot;preferred I/O
block size&quot; is available from the <b>stat()</b> system
call, <b>struct stat</b> member <b>st_blksize</b>. If this
is available it is used. Lacking that, twice the system
pagesize is used. Lacking a call to discover the system
pagesize, we just set default chunksize to 8192.</p>

<p style="margin-left:22%; margin-top: 1em">The chunksize
is a property of a given open netcdf descriptor <i>ncid</i>,
it is not a persistent property of the netcdf dataset.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="60%">


<p style="margin-top: 1em"><b>integer function
nf_redef(integer</b> <i>ncid</i><b>)</b></p></td>
<td width="29%">
</td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">(Corresponds to
<b>ncredf()</b> in version 2)</p>

<p style="margin-left:22%; margin-top: 1em">Puts an open
netCDF dataset into define mode, so dimensions, variables,
and attributes can be added or renamed and attributes can be
deleted.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="61%">


<p style="margin-top: 1em"><b>integer function
nf_enddef(integer</b> <i>ncid</i><b>)</b></p></td>
<td width="28%">
</td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">(Corresponds to
<b>ncendf()</b> in version 2)</p>

<p style="margin-left:22%; margin-top: 1em">Takes an open
netCDF dataset out of define mode. The changes made to the
netCDF dataset while it was in define mode are checked and
committed to disk if no problems occurred. Some data values
may be written as well, see &quot;VARIABLE PREFILLING&quot;
below. After a successful call, variable data can be read or
written to the dataset.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf__enddef(integer</b> <i>ncid</i><b>, integer</b>
<i>h_minfree</i><b>, integer</b> <i>v_align</i><b>,
integer</b> <i>v_minfree</i><b>, integer</b>
<i>r_align</i><b>)</b></p> </td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Like
<b>nf_enddef()</b> but has additional performance tuning
parameters.</p>

<p style="margin-left:22%; margin-top: 1em">Caution: this
function exposes internals of the netcdf version 1 file
format. It may not be available on future netcdf
implementations.</p>

<p style="margin-left:22%; margin-top: 1em">The current
netcdf file format has three sections, the
&quot;header&quot; section, the data section for fixed size
variables, and the data section for variables which have an
unlimited dimension (record variables). The header begins at
the beginning of the file. The index (offset) of the
beginning of the other two sections is contained in the
header. Typically, there is no space between the sections.
This causes copying overhead to accrue if one wishes to
change the size of the sections, as may happen when changing
names of things, text attribute values, adding attributes or
adding variables. Also, for buffered i/o, there may be
advantages to aligning sections in certain ways.</p>

<p style="margin-left:22%; margin-top: 1em">The minfree
parameters allow one to control costs of future calls to
<b>nf_redef()</b>, <b>nf_enddef()</b> by requesting that
<i>minfree</i> bytes be available at the end of the section.
The <i>h_minfree</i> parameter sets the pad at the end of
the &quot;header&quot; section. The <i>v_minfree</i>
parameter sets the pad at the end of the data section for
fixed size variables.</p>

<p style="margin-left:22%; margin-top: 1em">The align
parameters allow one to set the alignment of the beginning
of the corresponding sections. The beginning of the section
is rounded up to an index which is a multiple of the align
parameter. The flag value <b>NF_ALIGN_CHUNK</b> tells the
library to use the chunksize (see above) as the align
parameter. The <i>v_align</i> parameter controls the
alignment of the beginning of the data section for fixed
size variables. The <i>r_align</i> parameter controls the
alignment of the beginning of the data section for variables
which have an unlimited dimension (record variables).</p>

<p style="margin-left:22%; margin-top: 1em">The file format
requires mod 4 alignment, so the align parameters are
silently rounded up to multiples of 4. The usual call,
<b>nf_enddef(</b><i>ncid</i><b>)</b> is equivalent to
<b>nf__enddef(</b><i>ncid</i><b>, 0, 4, 0, 4)</b>.</p>

<p style="margin-left:22%; margin-top: 1em">The file format
does not contain a &quot;record size&quot; value, this is
calculated from the sizes of the record variables. This
unfortunate fact prevents us from providing minfree and
alignment control of the &quot;records&quot; in a netcdf
file. If you add a variable which has an unlimited
dimension, the third section will always be copied with the
new variable added.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="58%">


<p style="margin-top: 1em"><b>integer function
nf_sync(integer</b> <i>ncid</i><b>)</b></p></td>
<td width="31%">
</td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">(Corresponds to
<b>ncsnc()</b> in version 2)</p>

<p style="margin-left:22%; margin-top: 1em">Unless the
<b>NF_SHARE</b> bit is set in <b>nf_open()</b> or
<b>nf_create()</b>, accesses to the underlying netCDF
dataset are buffered by the library. This function
synchronizes the state of the underlying dataset and the
library. This is done automatically by <b>nf_close()</b> and
<b>nf_enddef()</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="60%">


<p style="margin-top: 1em"><b>integer function
nf_abort(integer</b> <i>ncid</i><b>)</b></p></td>
<td width="29%">
</td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">(Corresponds to
<b>ncabor()</b> in version 2)</p>

<p style="margin-left:22%; margin-top: 1em">You don&rsquo;t
need to call this function. This function is called
automatically by <b>nf_close()</b> if the netCDF was in
define mode and something goes wrong with the commit. If the
netCDF dataset isn&rsquo;t in define mode, then this
function is equivalent to <b>nf_close()</b>. If it is called
after <b>nf_redef()</b>, but before <b>nf_enddef()</b>, the
new definitions are not committed and the dataset is closed.
If it is called after <b>nf_create()</b> but before
<b>nf_enddef()</b>, the dataset disappears.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="60%">


<p style="margin-top: 1em"><b>integer function
nf_close(integer</b> <i>ncid</i><b>)</b></p></td>
<td width="29%">
</td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">(Corresponds to
<b>ncclos()</b> in version 2)</p>

<p style="margin-left:22%; margin-top: 1em">Closes an open
netCDF dataset. If the dataset is in define mode,
<b>nf_enddef()</b> will be called before closing. After a
dataset is closed, its ID may be reassigned to another
dataset.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_inq(integer</b> <i>ncid</i><b>, integer</b>
<i>ndims</i><b>, integer</b> <i>nvars</i><b>, integer</b>
<i>natts</i><b>, integer</b> <i>unlimdimid</i><b>)</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_inq_ndims(integer</b> <i>ncid</i><b>, integer</b>
<i>ndims</i><b>)</b></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_inq_nvars(integer</b> <i>ncid</i><b>, integer</b>
<i>nvars</i><b>)</b></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_inq_natts(integer</b> <i>ncid</i><b>, integer</b>
<i>natts</i><b>)</b></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_inq_unlimdim(integer</b> <i>ncid</i><b>, integer</b>
<i>unlimdimid</i><b>)</b></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_inq_format(integer</b> <i>ncid</i><b>, integer</b>
<i>formatn</i><b>)</b></p> </td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Use these
functions to find out what is in a netCDF dataset. Upon
successful return, <i>ndims</i> will contain the number of
dimensions defined for this netCDF dataset, <i>nvars</i>
will contain the number of variables, <i>natts</i> will
contain the number of attributes, and <i>unlimdimid</i> will
contain the dimension ID of the unlimited dimension if one
exists, or 0 otherwise. <i>formatn</i> will contain the
version number of the dataset &lt;format&gt;, one of
<b>NF_FORMAT_CLASSIC</b>, <b>NF_FORMAT_64BIT</b>,
<b>NF_FORMAT_NETCDF4</b>, or
<b>NF_FORMAT_NETCDF4_CLASSIC</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_def_dim(integer</b> <i>ncid</i><b>, character*(*)</b>
<i>name</i><b>, integer</b> <i>len</i><b>, integer</b>
<i>dimid</i><b>)</b></p> </td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">(Corresponds to
<b>ncddef()</b> in version 2)</p>

<p style="margin-left:22%; margin-top: 1em">Adds a new
dimension to an open netCDF dataset, which must be in define
mode. <i>name</i> is the dimension name. <i>dimid</i> will
contain the dimension ID of the newly created dimension.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<h2>DIMENSIONS
<a name="DIMENSIONS"></a>
</h2>
<td width="11%"></td>
<td width="89%">


<p><b>integer function nf_inq_dimid(integer</b>
<i>ncid</i><b>, character*(*)</b> <i>name</i><b>,
integer</b> <i>dimid</i><b>)</b></p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">(Corresponds to
<b>ncdid()</b> in version 2)</p>

<p style="margin-left:22%; margin-top: 1em">Given a
dimension name, returns the ID of a netCDF dimension in
<i>dimid</i>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_inq_dim(integer</b> <i>ncid</i><b>, integer</b>
<i>dimid</i><b>, character*(*)</b> <i>name</i><b>,
integer</b> <i>len</i><b>)</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_inq_dimname(integer</b> <i>ncid</i><b>, integer</b>
<i>dimid</i><b>, character*(*)</b> <i>name</i><b>)</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_inq_dimlen(integer</b> <i>ncid</i><b>, integer</b>
<i>dimid</i><b>, integer</b> <i>len</i><b>)</b></p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Use these
functions to find out about a dimension.</p>

<p style="margin-left:22%; margin-top: 1em"><i>name</i>
should be big enough (<b>NF_MAX_NAME</b>) to hold the
dimension name as the name will be copied into your storage.
The length return parameter, <i>len</i> will contain the
size of the dimension. For the unlimited dimension, the
returned length is the current maximum value used for
writing into any of the variables which use the
dimension.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_rename_dim(integer</b> <i>ncid</i><b>, integer</b>
<i>dimid</i><b>, character*(*)</b> <i>name</i><b>)</b></p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">(Corresponds to
<b>ncdren()</b> in version 2)</p>

<p style="margin-left:22%; margin-top: 1em">Renames an
existing dimension in an open netCDF dataset. If the new
name is longer than the old name, the netCDF dataset must be
in define mode. You cannot rename a dimension to have the
same name as another dimension.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<h2>VARIABLES
<a name="VARIABLES"></a>
</h2>
<td width="11%"></td>
<td width="89%">


<p><b>integer function nf_def_var(integer</b>
<i>ncid</i><b>, character*(*)</b> <i>name</i><b>,
integer</b> <i>xtype</i><b>, integer</b> <i>ndims</i><b>,
integer</b> <i>dimids</i><b>(1), integer</b>
<i>varid</i><b>)</b></p> </td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">(Corresponds to
<b>ncvdef()</b> in version 2)</p>

<p style="margin-left:22%; margin-top: 1em">Adds a new
variable to a netCDF dataset. The netCDF must be in define
mode. <i>varid</i> will be set to the netCDF variable
ID.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_inq_varid(integer</b> <i>ncid</i><b>, character*(*)</b>
<i>name</i><b>, integer</b> <i>varid</i><b>)</b></p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">(Corresponds to
<b>ncvid()</b> in version 2)</p>

<p style="margin-left:22%; margin-top: 1em">Returns the ID
of a netCDF variable in <i>varid</i> given its name.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_inq_var(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, character*(*)</b> <i>name</i><b>,
integer</b> <i>xtype</i><b>, integer</b> <i>ndims</i><b>,
integer</b> <i>dimids</i><b>(1), integer</b>
<i>natts</i><b>)</b></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_inq_varname(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, character*(*)</b> <i>name</i><b>)</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_inq_vartype(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, integer</b> <i>xtype</i><b>)</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_inq_varndims(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, integer</b> <i>ndims</i><b>)</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_inq_vardimid(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, integer</b> <i>dimids</i><b>(1))</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_inq_varnatts(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, integer</b> <i>natts</i><b>)</b></p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Returns
information about a netCDF variable, given its ID.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_rename_var(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, character*(*)</b> <i>name</i><b>)</b></p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">(Corresponds to
<b>ncvren()</b> in version 2)</p>

<p style="margin-left:22%; margin-top: 1em">Changes the
name of a netCDF variable. If the new name is longer than
the old name, the netCDF must be in define mode. You cannot
rename a variable to have the name of any existing
variable.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<h2>WRITING AND READING WHOLE VARIABLES
<a name="WRITING AND READING WHOLE VARIABLES"></a>
</h2>
<td width="11%"></td>
<td width="89%">


<p><b>integer function nf_put_var_text(integer</b>
<i>ncid</i><b>, integer</b> <i>varid</i><b>,
character*(*)</b> <i>out</i><b>)</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p><b>integer function nf_put_var_int1(integer</b>
<i>ncid</i><b>, integer</b> <i>varid</i><b>, integer*1</b>
<i>out</i><b>(1))</b></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p><b>integer function nf_put_var_int2(integer</b>
<i>ncid</i><b>, integer</b> <i>varid</i><b>, integer*2</b>
<i>out</i><b>(1))</b></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p><b>integer function nf_put_var_int(integer</b>
<i>ncid</i><b>, integer</b> <i>varid</i><b>, integer</b>
<i>out</i><b>(1))</b></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p><b>integer function nf_put_var_real(integer</b>
<i>ncid</i><b>, integer</b> <i>varid</i><b>, real</b>
<i>out</i><b>(1))</b></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p><b>integer function nf_put_var_double(integer</b>
<i>ncid</i><b>, integer</b> <i>varid</i><b>,
doubleprecision</b> <i>out</i><b>(1))</b></p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Writes an
entire netCDF variable (i.e. all the values). The netCDF
dataset must be open and in data mode. The type of the data
is specified in the function name, and it is converted to
the external type of the specified variable, if possible,
otherwise an <b>NF_ERANGE</b> error is returned. Note that
rounding is not performed during the conversion. Floating
point numbers are truncated when converted to integers.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_get_var_text(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, character*(*)</b> <i>in</i><b>)</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_get_var_int1(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, integer*1</b> <i>in</i><b>(1))</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_get_var_int2(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, integer*2</b> <i>in</i><b>(1))</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_get_var_int(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, integer</b> <i>in</i><b>(1))</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_get_var_real(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, real</b> <i>in</i><b>(1))</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_get_var_double(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, doubleprecision</b>
<i>in</i><b>(1))</b></p> </td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Reads an entire
netCDF variable (i.e. all the values). The netCDF dataset
must be open and in data mode. The data is converted from
the external type of the specified variable, if necessary,
to the type specified in the function name. If conversion is
not possible, an <b>NF_ERANGE</b> error is returned.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<h2>WRITING AND READING ONE DATUM
<a name="WRITING AND READING ONE DATUM"></a>
</h2>
<td width="11%"></td>
<td width="89%">


<p><b>integer function nf_put_var1_text(integer</b>
<i>ncid</i><b>, integer</b> <i>varid</i><b>, integer</b>
<i>index</i><b>(1), character*1</b> <i>*out</i><b>)</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p><b>integer function nf_put_var1_int1(integer</b>
<i>ncid</i><b>, integer</b> <i>varid</i><b>, integer</b>
<i>index</i><b>(1), integer*1</b> <i>*out</i><b>)</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p><b>integer function nf_put_var1_int2(integer</b>
<i>ncid</i><b>, integer</b> <i>varid</i><b>, integer</b>
<i>index</i><b>(1), integer*2</b> <i>*out</i><b>)</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p><b>integer function nf_put_var1_int(integer</b>
<i>ncid</i><b>, integer</b> <i>varid</i><b>, integer</b>
<i>index</i><b>(1), integer</b> <i>*out</i><b>)</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p><b>integer function nf_put_var1_real(integer</b>
<i>ncid</i><b>, integer</b> <i>varid</i><b>, integer</b>
<i>index</i><b>(1), real</b> <i>*out</i><b>)</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p><b>integer function nf_put_var1_double(integer</b>
<i>ncid</i><b>, integer</b> <i>varid</i><b>, integer</b>
<i>index</i><b>(1), doubleprecision</b>
<i>*out</i><b>)</b></p> </td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Puts a single
data value into a variable at the position <i>index</i> of
an open netCDF dataset that is in data mode. The type of the
data is specified in the function name, and it is converted
to the external type of the specified variable, if possible,
otherwise an <b>NF_ERANGE</b> error is returned.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_get_var1_text(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, integer</b> <i>index</i><b>(1),
character*1</b> <i>in</i><b>)</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_get_var1_int1(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, integer</b> <i>index</i><b>(1),
integer*1</b> <i>in</i><b>)</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_get_var1_int2(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, integer</b> <i>index</i><b>(1),
integer*2</b> <i>in</i><b>)</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_get_var1_int(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, integer</b> <i>index</i><b>(1), integer</b>
<i>in</i><b>)</b></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_get_var1_real(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, integer</b> <i>index</i><b>(1), real</b>
<i>in</i><b>)</b></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_get_var1_double(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, integer</b> <i>index</i><b>(1),
doubleprecision</b> <i>in</i><b>)</b></p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Gets a single
data value from a variable at the position <i>index</i> of
an open netCDF dataset that is in data mode. The data is
converted from the external type of the specified variable,
if necessary, to the type specified in the function name. If
conversion is not possible, an <b>NF_ERANGE</b> error is
returned.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<h2>WRITING AND READING AN ARRAY
<a name="WRITING AND READING AN ARRAY"></a>
</h2>
<td width="11%"></td>
<td width="89%">


<p><b>integer function nf_put_vara_text(integer</b>
<i>ncid</i><b>, integer</b> <i>varid</i><b>, integer</b>
<i>start</i><b>(1), integer</b> <i>count</i><b>(1),
character*(*)</b> <i>out</i><b>)</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p><b>integer function nf_put_vara_int1(integer</b>
<i>ncid</i><b>, integer</b> <i>varid</i><b>, integer</b>
<i>start</i><b>(1), integer</b> <i>count</i><b>(1),
integer*1</b> <i>out</i><b>(1))</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p><b>integer function nf_put_vara_int2(integer</b>
<i>ncid</i><b>, integer</b> <i>varid</i><b>, integer</b>
<i>start</i><b>(1), integer</b> <i>count</i><b>(1),
integer*2</b> <i>out</i><b>(1))</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p><b>integer function nf_put_vara_int(integer</b>
<i>ncid</i><b>, integer</b> <i>varid</i><b>, integer</b>
<i>start</i><b>(1), integer</b> <i>count</i><b>(1),
integer</b> <i>out</i><b>(1))</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p><b>integer function nf_put_vara_real(integer</b>
<i>ncid</i><b>, integer</b> <i>varid</i><b>, integer</b>
<i>start</i><b>(1), integer</b> <i>count</i><b>(1), real</b>
<i>out</i><b>(1))</b></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p><b>integer function nf_put_vara_double(integer</b>
<i>ncid</i><b>, integer</b> <i>varid</i><b>, integer</b>
<i>start</i><b>(1), integer</b> <i>count</i><b>(1),
doubleprecision</b> <i>out</i><b>(1))</b></p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Writes an array
section of values into a netCDF variable of an open netCDF
dataset, which must be in data mode. The array section is
specified by the <i>start</i> and <i>count</i> vectors,
which give the starting index and count of values along each
dimension of the specified variable. The type of the data is
specified in the function name and is converted to the
external type of the specified variable, if possible,
otherwise an <b>NF_ERANGE</b> error is returned.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_get_vara_text(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, integer</b> <i>start</i><b>(1), integer</b>
<i>count</i><b>(1), character*(*)</b> <i>in</i><b>)</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_get_vara_int1(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, integer</b> <i>start</i><b>(1), integer</b>
<i>count</i><b>(1), integer*1</b> <i>in</i><b>(1))</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_get_vara_int2(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, integer</b> <i>start</i><b>(1), integer</b>
<i>count</i><b>(1), integer*2</b> <i>in</i><b>(1))</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_get_vara_int(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, integer</b> <i>start</i><b>(1), integer</b>
<i>count</i><b>(1), integer</b> <i>in</i><b>(1))</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_get_vara_real(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, integer</b> <i>start</i><b>(1), integer</b>
<i>count</i><b>(1), real</b> <i>in</i><b>(1))</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_get_vara_double(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, integer</b> <i>start</i><b>(1), integer</b>
<i>count</i><b>(1), doubleprecision</b>
<i>in</i><b>(1))</b></p> </td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Reads an array
section of values from a netCDF variable of an open netCDF
dataset, which must be in data mode. The array section is
specified by the <i>start</i> and <i>count</i> vectors,
which give the starting index and count of values along each
dimension of the specified variable. The data is converted
from the external type of the specified variable, if
necessary, to the type specified in the function name. If
conversion is not possible, an <b>NF_ERANGE</b> error is
returned.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<h2>WRITING AND READING A SLICED ARRAY
<a name="WRITING AND READING A SLICED ARRAY"></a>
</h2>
<td width="11%"></td>
<td width="89%">


<p><b>integer function nf_put_vars_text(integer</b>
<i>ncid</i><b>, integer</b> <i>varid</i><b>, integer</b>
<i>start</i><b>(1), integer</b> <i>count</i><b>(1),
integer</b> <i>stride</i><b>(1), character*(*)</b>
<i>out</i><b>)</b></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p><b>integer function nf_put_vars_int1(integer</b>
<i>ncid</i><b>, integer</b> <i>varid</i><b>, integer</b>
<i>start</i><b>(1), integer</b> <i>count</i><b>(1),
integer</b> <i>stride</i><b>(1), integer*1</b>
<i>out</i><b>(1))</b></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p><b>integer function nf_put_vars_int2(integer</b>
<i>ncid</i><b>, integer</b> <i>varid</i><b>, integer</b>
<i>start</i><b>(1), integer</b> <i>count</i><b>(1),
integer</b> <i>stride</i><b>(1), integer*2</b>
<i>out</i><b>(1))</b></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p><b>integer function nf_put_vars_int(integer</b>
<i>ncid</i><b>, integer</b> <i>varid</i><b>, integer</b>
<i>start</i><b>(1), integer</b> <i>count</i><b>(1),
integer</b> <i>stride</i><b>(1), integer</b>
<i>out</i><b>(1))</b></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p><b>integer function nf_put_vars_real(integer</b>
<i>ncid</i><b>, integer</b> <i>varid</i><b>, integer</b>
<i>start</i><b>(1), integer</b> <i>count</i><b>(1),
integer</b> <i>stride</i><b>(1), real</b>
<i>out</i><b>(1))</b></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p><b>integer function nf_put_vars_double(integer</b>
<i>ncid</i><b>, integer</b> <i>varid</i><b>, integer</b>
<i>start</i><b>(1), integer</b> <i>count</i><b>(1),
integer</b> <i>stride</i><b>(1), doubleprecision</b>
<i>out</i><b>(1))</b></p> </td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">These functions
are used for <i>strided output</i>, which is like the array
section output described above, except that the sampling
stride (the interval between accessed values) is specified
for each dimension. For an explanation of the sampling
stride vector, see COMMON ARGUMENTS DESCRIPTIONS below.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_get_vars_text(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, integer</b> <i>start</i><b>(1), integer</b>
<i>count</i><b>(1), integer</b> <i>stride</i><b>(1),
character*(*)</b> <i>in</i><b>)</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_get_vars_int1(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, integer</b> <i>start</i><b>(1), integer</b>
<i>count</i><b>(1), integer</b> <i>stride</i><b>(1),
integer*1</b> <i>in</i><b>(1))</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_get_vars_int2(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, integer</b> <i>start</i><b>(1), integer</b>
<i>count</i><b>(1), integer</b> <i>stride</i><b>(1),
integer*2</b> <i>in</i><b>(1))</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_get_vars_int(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, integer</b> <i>start</i><b>(1), integer</b>
<i>count</i><b>(1), integer</b> <i>stride</i><b>(1),
integer</b> <i>in</i><b>(1))</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_get_vars_real(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, integer</b> <i>start</i><b>(1), integer</b>
<i>count</i><b>(1), integer</b> <i>stride</i><b>(1),
real</b> <i>in</i><b>(1))</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_get_vars_double(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, integer</b> <i>start</i><b>(1), integer</b>
<i>count</i><b>(1), integer</b> <i>stride</i><b>(1),
doubleprecision</b> <i>in</i><b>(1))</b></p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">These functions
are used for <i>strided input</i>, which is like the array
section input described above, except that the sampling
stride (the interval between accessed values) is specified
for each dimension. For an explanation of the sampling
stride vector, see COMMON ARGUMENTS DESCRIPTIONS below.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<h2>WRITING AND READING A MAPPED ARRAY
<a name="WRITING AND READING A MAPPED ARRAY"></a>
</h2>
<td width="11%"></td>
<td width="89%">


<p><b>integer function nf_put_varm_text(integer</b>
<i>ncid</i><b>, integer</b> <i>varid</i><b>, integer</b>
<i>start</i><b>(1), integer</b> <i>count</i><b>(1),
integer</b> <i>stride</i><b>(1),</b> <i>imap</i><b>,
character*(*)</b> <i>out</i><b>)</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p><b>integer function nf_put_varm_int1(integer</b>
<i>ncid</i><b>, integer</b> <i>varid</i><b>, integer</b>
<i>start</i><b>(1), integer</b> <i>count</i><b>(1),
integer</b> <i>stride</i><b>(1),</b> <i>imap</i><b>,
integer*1</b> <i>out</i><b>(1))</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p><b>integer function nf_put_varm_int2(integer</b>
<i>ncid</i><b>, integer</b> <i>varid</i><b>, integer</b>
<i>start</i><b>(1), integer</b> <i>count</i><b>(1),
integer</b> <i>stride</i><b>(1),</b> <i>imap</i><b>,
integer*2</b> <i>out</i><b>(1))</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p><b>integer function nf_put_varm_int(integer</b>
<i>ncid</i><b>, integer</b> <i>varid</i><b>, integer</b>
<i>start</i><b>(1), integer</b> <i>count</i><b>(1),
integer</b> <i>stride</i><b>(1),</b> <i>imap</i><b>,
integer</b> <i>out</i><b>(1))</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p><b>integer function nf_put_varm_real(integer</b>
<i>ncid</i><b>, integer</b> <i>varid</i><b>, integer</b>
<i>start</i><b>(1), integer</b> <i>count</i><b>(1),
integer</b> <i>stride</i><b>(1),</b> <i>imap</i><b>,
real</b> <i>out</i><b>(1))</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p><b>integer function nf_put_varm_double(integer</b>
<i>ncid</i><b>, integer</b> <i>varid</i><b>, integer</b>
<i>start</i><b>(1), integer</b> <i>count</i><b>(1),
integer</b> <i>stride</i><b>(1),</b> <i>imap</i><b>,
doubleprecision</b> <i>out</i><b>(1))</b></p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">These functions
are used for <i>mapped output</i>, which is like strided
output described above, except that an additional index
mapping vector is provided to specify the in-memory
arrangement of the data values. For an explanation of the
index mapping vector, see COMMON ARGUMENTS DESCRIPTIONS
below.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_get_varm_text(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, integer</b> <i>start</i><b>(1), integer</b>
<i>count</i><b>(1), integer</b> <i>stride</i><b>(1),</b>
<i>imap</i><b>, character*(*)</b> <i>in</i><b>)</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_get_varm_int1(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, integer</b> <i>start</i><b>(1), integer</b>
<i>count</i><b>(1), integer</b> <i>stride</i><b>(1),</b>
<i>imap</i><b>, integer*1</b> <i>in</i><b>(1))</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_get_varm_int2(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, integer</b> <i>start</i><b>(1), integer</b>
<i>count</i><b>(1), integer</b> <i>stride</i><b>(1),</b>
<i>imap</i><b>, integer*2</b> <i>in</i><b>(1))</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_get_varm_int(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, integer</b> <i>start</i><b>(1), integer</b>
<i>count</i><b>(1), integer</b> <i>stride</i><b>(1),</b>
<i>imap</i><b>, integer</b> <i>in</i><b>(1))</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_get_varm_real(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, integer</b> <i>start</i><b>(1), integer</b>
<i>count</i><b>(1), integer</b> <i>stride</i><b>(1),</b>
<i>imap</i><b>, real</b> <i>in</i><b>(1))</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_get_varm_double(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, integer</b> <i>start</i><b>(1), integer</b>
<i>count</i><b>(1), integer</b> <i>stride</i><b>(1),</b>
<i>imap</i><b>, doubleprecision</b> <i>in</i><b>(1))</b></p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">These functions
are used for <i>mapped input</i>, which is like strided
input described above, except that an additional index
mapping vector is provided to specify the in-memory
arrangement of the data values. For an explanation of the
index mapping vector, see COMMON ARGUMENTS DESCRIPTIONS
below.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<h2>ATTRIBUTES
<a name="ATTRIBUTES"></a>
</h2>
<td width="11%"></td>
<td width="89%">


<p><b>integer function nf_put_att_text(integer</b>
<i>ncid</i><b>, integer</b> <i>varid</i><b>,
character*(*)</b> <i>name</i><b>, integer</b>
<i>xtype</i><b>, integer</b> <i>len</i><b>,
character*(*)</b> <i>out</i><b>)</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p><b>integer function nf_put_att_int1(integer</b>
<i>ncid</i><b>, integer</b> <i>varid</i><b>,
character*(*)</b> <i>name</i><b>, integer</b>
<i>xtype</i><b>, integer</b> <i>len</i><b>, integer*1</b>
<i>out</i><b>(1))</b></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p><b>integer function nf_put_att_int2(integer</b>
<i>ncid</i><b>, integer</b> <i>varid</i><b>,
character*(*)</b> <i>name</i><b>, integer</b>
<i>xtype</i><b>, integer</b> <i>len</i><b>, integer*2</b>
<i>out</i><b>(1))</b></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p><b>integer function nf_put_att_int(integer</b>
<i>ncid</i><b>, integer</b> <i>varid</i><b>,
character*(*)</b> <i>name</i><b>, integer</b>
<i>xtype</i><b>, integer</b> <i>len</i><b>, integer</b>
<i>out</i><b>(1))</b></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p><b>integer function nf_put_att_real(integer</b>
<i>ncid</i><b>, integer</b> <i>varid</i><b>,
character*(*)</b> <i>name</i><b>, integer</b>
<i>xtype</i><b>, integer</b> <i>len</i><b>, real</b>
<i>out</i><b>(1))</b></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p><b>integer function nf_put_att_double(integer</b>
<i>ncid</i><b>, integer</b> <i>varid</i><b>,
character*(*)</b> <i>name</i><b>, integer</b>
<i>xtype</i><b>, integer</b> <i>len</i><b>,
doubleprecision</b> <i>out</i><b>(1))</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p><b>integer function nf_put_att(integer</b>
<i>ncid</i><b>, integer</b> <i>varid</i><b>,
character*(*)</b> <i>name</i><b>, integer</b>
<i>xtype</i><b>, integer</b> <i>len</i><b>, void *</b>
<i>ip</i><b>)</b></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p><b>integer function nf_get_att(integer</b>
<i>ncid</i><b>, integer</b> <i>varid</i><b>,
character*(*)</b> <i>name</i><b>, void *</b>
<i>ip</i><b>)</b></p> </td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Unlike
variables, attributes do not have separate functions for
defining and writing values. This family of functions
defines a new attribute with a value or changes the value of
an existing attribute. If the attribute is new, or if the
space required to store the attribute value is greater than
before, the netCDF dataset must be in define mode. The
parameter <i>len</i> is the number of values from <i>out</i>
to transfer. It is often one, except that for
<b>nf_put_att_text()</b> it will usually be
<b>len_trim(</b><i>out</i><b>)</b>.</p>

<p style="margin-left:22%; margin-top: 1em">For these
functions, the type component of the function name refers to
the in-memory type of the value, whereas the <i>xtype</i>
argument refers to the external type for storing the value.
An <b>NF_ERANGE</b> error results if a conversion between
these types is not possible. In this case the value is
represented with the appropriate fill-value for the
associated external type.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_inq_attname(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, integer</b> <i>attnum</i><b>,
character*(*)</b> <i>name</i><b>)</b></p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Gets the name
of an attribute, given its variable ID and attribute number.
This function is useful in generic applications that need to
get the names of all the attributes associated with a
variable, since attributes are accessed by name rather than
number in all other attribute functions. The number of an
attribute is more volatile than the name, since it can
change when other attributes of the same variable are
deleted. The attributes for each variable are numbered from
1 (the first attribute) to <i>nvatts</i>, where
<i>nvatts</i> is the number of attributes for the variable,
as returned from a call to <b>nf_inq_varnatts()</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_inq_att(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, character*(*)</b> <i>name</i><b>,
integer</b> <i>xtype</i><b>, integer</b>
<i>len</i><b>)</b></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_inq_attid(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, character*(*)</b> <i>name</i><b>,
integer</b> <i>attnum</i><b>)</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_inq_atttype(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, character*(*)</b> <i>name</i><b>,
integer</b> <i>xtype</i><b>)</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_inq_attlen(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, character*(*)</b> <i>name</i><b>,
integer</b> <i>len</i><b>)</b></p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">These functions
return information about a netCDF attribute, given its
variable ID and name. The information returned is the
external type in <i>xtype</i> and the number of elements in
the attribute as <i>len</i>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_copy_att(integer</b> <i>ncid</i><b>, integer</b>
<i>varid_in</i><b>, character*(*)</b> <i>name</i><b>,
integer</b> <i>ncid_out</i><b>, integer</b>
<i>varid_out</i><b>)</b></p> </td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Copies an
attribute from one netCDF dataset to another. It can also be
used to copy an attribute from one variable to another
within the same netCDF. <i>ncid_in</i> is the netCDF ID of
an input netCDF dataset from which the attribute will be
copied. <i>varid_in</i> is the ID of the variable in the
input netCDF dataset from which the attribute will be
copied, or <b>NF_GLOBAL</b> for a global attribute.
<i>name</i> is the name of the attribute in the input netCDF
dataset to be copied. <i>ncid_out</i> is the netCDF ID of
the output netCDF dataset to which the attribute will be
copied. It is permissible for the input and output netCDF
ID&rsquo;s to be the same. The output netCDF dataset should
be in define mode if the attribute to be copied does not
already exist for the target variable, or if it would cause
an existing target attribute to grow. <i>varid_out</i> is
the ID of the variable in the output netCDF dataset to which
the attribute will be copied, or <b>NF_GLOBAL</b> to copy to
a global attribute.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_rename_att(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, character*(*)</b> <i>name</i><b>,
character*(*)</b> <i>newname</i><b>)</b></p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Changes the
name of an attribute. If the new name is longer than the
original name, the netCDF must be in define mode. You cannot
rename an attribute to have the same name as another
attribute of the same variable. <i>name</i> is the original
attribute name. <i>newname</i> is the new name to be
assigned to the specified attribute. If the new name is
longer than the old name, the netCDF dataset must be in
define mode.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_del_att(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, character*(*)</b> <i>name</i><b>)</b></p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Deletes an
attribute from a netCDF dataset. The dataset must be in
define mode.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_get_att_text(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, character*(*)</b> <i>name</i><b>,
character*(*)</b> <i>in</i><b>)</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_get_att_int1(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, character*(*)</b> <i>name</i><b>,
integer*1</b> <i>in</i><b>(1))</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_get_att_int2(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, character*(*)</b> <i>name</i><b>,
integer*2</b> <i>in</i><b>(1))</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_get_att_int(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, character*(*)</b> <i>name</i><b>,
integer</b> <i>in</i><b>(1))</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_get_att_real(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, character*(*)</b> <i>name</i><b>, real</b>
<i>in</i><b>(1))</b></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_get_att_double(integer</b> <i>ncid</i><b>, integer</b>
<i>varid</i><b>, character*(*)</b> <i>name</i><b>,
doubleprecision</b> <i>in</i><b>(1))</b></p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Gets the
value(s) of a netCDF attribute, given its variable ID and
name. Converts from the external type to the type specified
in the function name, if possible, otherwise returns an
<b>NF_ERANGE</b> error. All elements of the vector of
attribute values are returned, so you must allocate enough
space to hold them. If you don&rsquo;t know how much space
to reserve, call <b>nf_inq_attlen()</b> first to find out
the length of the attribute.</p>

<h2>COMMON ARGUMENT DESCRIPTIONS
<a name="COMMON ARGUMENT DESCRIPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">In this section
we define some common arguments which are used in the
&quot;FUNCTION DESCRIPTIONS&quot; section. <br>
integer <i>ncid</i></p>

<p style="margin-left:22%;">is the netCDF ID returned from
a previous, successful call to <b>nf_open()</b> or
<b>nf_create()</b></p>

<p style="margin-left:11%;">character*(*) <i>name</i></p>

<p style="margin-left:22%;">is the name of a dimension,
variable, or attribute. The names of dimensions, variables
and attributes consist of arbitrary sequences of
alphanumeric characters (as well as underscore
&rsquo;_&rsquo;, period &rsquo;.&rsquo; and hyphen
&rsquo;-&rsquo;), beginning with a letter or underscore.
(However names commencing with underscore are reserved for
system use.) Case is significant in netCDF names. A
zero-length name is not allowed.</p>

<p style="margin-left:22%; margin-top: 1em">The maximum
allowable number of characters <br>
is <b>NF_MAX_NAME</b>.</p>

<p style="margin-left:11%;">integer <i>xtype</i></p>

<p style="margin-left:22%;">specifies the external data
type of a netCDF variable or attribute and is one of the
following: <b>NF_BYTE</b>, <b>NF_CHAR</b>, <b>NF_SHORT</b>,
<b>NF_INT</b>, <b>NF_FLOAT</b>, or <b>NF_DOUBLE</b>. These
are used to specify 8-bit integers, characters, 16-bit
integers, 32-bit integers, 32-bit IEEE floating point
numbers, and 64-bit IEEE floating-point numbers,
respectively.</p>

<p style="margin-left:11%;">integer <i>dimids</i>(1)</p>

<p style="margin-left:22%;">is a vector of dimension
ID&rsquo;s and defines the shape of a netCDF variable. The
size of the vector shall be greater than or equal to the
rank (i.e. the number of dimensions) of the variable
(<i>ndims</i>). The vector shall be ordered by the speed
with which a dimension varies: <i>dimids</i>(1) shall be the
dimension ID of the most rapidly varying dimension and
<i>dimids</i>(<i>ndims</i>) shall be the dimension ID of the
most slowly varying dimension. The maximum possible number
of dimensions for a variable is given by the symbolic
constant <b>NF_MAX_VAR_DIMS</b>.</p>

<p style="margin-left:11%;">integer <i>dimid</i></p>

<p style="margin-left:22%;">is the ID of a netCDF
dimension. netCDF dimension ID&rsquo;s are allocated
sequentially from the positive integers beginning with
1.</p>

<p style="margin-left:11%;">integer <i>ndims</i></p>

<p style="margin-left:22%;">is either the total number of
dimensions in a netCDF dataset or the rank (i.e. the number
of dimensions) of a netCDF variable. The value shall not be
negative or greater than the symbolic constant
<b>NF_MAX_VAR_DIMS</b>.</p>

<p style="margin-left:11%;">integer <i>varid</i></p>

<p style="margin-left:22%;">is the ID of a netCDF variable
or (for the attribute-access functions) the symbolic
constant <b>NF_GLOBAL</b>, which is used to reference global
attributes. netCDF variable ID&rsquo;s are allocated
sequentially from the positive integers beginning with
1.</p>

<p style="margin-left:11%;">integer <i>natts</i></p>

<p style="margin-left:22%;">is the number of global
attributes in a netCDF dataset for the <b>nf_inquire()</b>
function or the number of attributes associated with a
netCDF variable for the <b>nf_varinq()</b> function.</p>

<p style="margin-left:11%;">integer <i>index</i>(1)</p>

<p style="margin-left:22%;">specifies the indicial
coordinates of the netCDF data value to be accessed. The
indices start at 1; thus, for example, the first data value
of a two-dimensional variable is (1,1). The size of the
vector shall be at least the rank of the associated netCDF
variable and its elements shall correspond, in order, to the
variable&rsquo;s dimensions.</p>

<p style="margin-left:11%;">integer <i>start</i>(1)</p>

<p style="margin-left:22%;">specifies the starting point
for accessing a netCDF variable&rsquo;s data values in terms
of the indicial coordinates of the corner of the array
section. The indices start at 1; thus, the first data value
of a variable is (1, 1, ..., 1). The size of the vector
shall be at least the rank of the associated netCDF variable
and its elements shall correspond, in order, to the
variable&rsquo;s dimensions.</p>

<p style="margin-left:11%;">integer <i>count</i>(1)</p>

<p style="margin-left:22%;">specifies the number of indices
selected along each dimension of the array section. Thus, to
access a single value, for example, specify <i>count</i> as
(1, 1, ..., 1). Note that, for strided I/O, this argument
must be adjusted to be compatible with the <i>stride</i> and
<i>start</i> arguments so that the interaction of the three
does not attempt to access an invalid data co-ordinate. The
elements of the <i>count</i> vector correspond, in order, to
the variable&rsquo;s dimensions.</p>

<p style="margin-left:11%;">integer <i>stride</i>(1)</p>

<p style="margin-left:22%;">specifies the sampling interval
along each dimension of the netCDF variable. The elements of
the stride vector correspond, in order, to the netCDF
variable&rsquo;s dimensions (<i>stride</i>(1)) gives the
sampling interval along the most rapidly varying dimension
of the netCDF variable). Sampling intervals are specified in
type-independent units of elements (a value of 1 selects
consecutive elements of the netCDF variable along the
corresponding dimension, a value of 2 selects every other
element, etc.).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><i>imap</i></p></td>
<td width="5%"></td>
<td width="78%">


<p>specifies the mapping between the dimensions of a netCDF
variable and the in-memory structure of the internal data
array. The elements of the index mapping vector correspond,
in order, to the netCDF variable&rsquo;s dimensions
(<i>imap</i>(1) gives the distance between elements of the
internal array corresponding to the most rapidly varying
dimension of the netCDF variable). Distances between
elements are specified in type-independent units of elements
(the distance between internal elements that occupy adjacent
memory locations is 1 and not the element&rsquo;s
byte-length as in netCDF 2).</p></td></tr>
</table>

<h2>VARIABLE PREFILLING
<a name="VARIABLE PREFILLING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">By default, the
netCDF interface sets the values of all newly-defined
variables of finite length (i.e. those that do not have an
unlimited, dimension) to the type-dependent fill-value
associated with each variable. This is done when
<b>nf_enddef()</b> is called. The fill-value for a variable
may be changed from the default value by defining the
attribute &lsquo;<b>_FillValue</b>&rsquo; for the variable.
This attribute must have the same type as the variable and
be of length one.</p>

<p style="margin-left:11%; margin-top: 1em">Variables with
an unlimited dimension are also prefilled, but on an
&lsquo;as needed&rsquo; basis. For example, if the first
write of such a variable is to position 5, then positions 1
through 4 (and no others) would be set to the fill-value at
the same time.</p>

<p style="margin-left:11%; margin-top: 1em">This default
prefilling of data values may be disabled by or&rsquo;ing
the <b>NF_NOFILL</b> flag into the mode parameter of
<b>nf_open()</b> or <b>nf_create()</b>, or, by calling the
function <b>nf_set_fill()</b> with the argument
<b>NF_NOFILL</b>. For variables that do not use the
unlimited dimension, this call must be made before
<b>nf_enddef()</b>. For variables that use the unlimited
dimension, this call may be made at any time.</p>

<p style="margin-left:11%; margin-top: 1em">One can obtain
increased performance of the netCDF interface by using this
feature, but only at the expense of requiring the
application to set every single data value. The performance
enhancing behavior of this function is dependent on the
particulars of the implementation and dataset format. The
flag value controlled by <b>nf_set_fill()</b> is per netCDF
ID, not per variable or per write. Allowing this to change
affects the degree to which a program can be effectively
parallelized. Given all of this, we state that the use of
this feature may not be available (or even needed) in future
releases. Programmers are cautioned against heavy reliance
upon this feature.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf_setfill(integer</b> <i>ncid</i><b>, integer</b>
<i>fillmode</i><b>, integer</b>
<i>old_fillemode</i><b>)</b></p> </td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Determines
whether or not variable prefilling will be done (see above).
The netCDF dataset shall be writable. <i>fillmode</i> is
either <b>NF_FILL</b> to enable prefilling (the default) or
<b>NF_NOFILL</b> to disable prefilling. This function
returns the previous setting in <i>old_fillmode</i>.</p>

<h2>MPP FUNCTION DESCRIPTIONS
<a name="MPP FUNCTION DESCRIPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Additional
functions for use on SGI/Cray MPP machines (_CRAYMPP). These
are used to set and inquire which PE is the base for MPP for
a particular netCDF. These are only relevant when using the
SGI/Cray &lsquo;&lsquo;global&rsquo;&rsquo; Flexible File
I/O layer and desire to have only a subset of PEs to open
the specific netCDF file. For technical reasons, these
functions are available on all platforms. On a platform
other than SGI/Cray MPP, it is as if only processor
available were processor 0.</p>

<p style="margin-left:11%; margin-top: 1em">To use this
feature, you need to specify a communicator group and call
<b>glio_group_mpi()</b> or <b>glio_group_shmem()</b> prior
to the netCDF <b>nf_open()</b> and <b>nf_create()</b>
calls.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf__create_mp(character*(*)</b> <i>path</i><b>, integer</b>
<i>cmode</i><b>, integer</b> <i>initialsize</i><b>,
integer</b> <i>pe</i><b>, integer</b> <i>chunksize</i><b>,
integer</b> <i>ncid</i><b>)</b></p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Like
<b>nf__create()</b> but allows the base PE to be set.</p>

<p style="margin-left:22%; margin-top: 1em">The argument
<i>pe</i> sets the base PE at creation time. In the MPP
environment, <b>nf__create()</b> and <b>nf_create()</b> set
the base PE to processor zero by default.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>integer function
nf__open_mp(character*(*)</b> <i>path</i><b>, integer</b>
<i>mode</i><b>, integer</b> <i>pe</i><b>, integer</b>
<i>chunksize</i><b>, integer</b> <i>ncid</i><b>)</b></p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Like
<b>nf__open()</b> but allows the base PE to be set. The
argument <i>pe</i> sets the base PE at creation time. In the
MPP environment, <b>nf__open()</b> and <b>nf_open()</b> set
the base PE to processor zero by default.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="87%">


<p style="margin-top: 1em"><b>integer function
nf_inq_base_pe(integer</b> <i>ncid</i><b>, integer</b>
<i>pe</i><b>)</b></p> </td>
<td width="2%">
</td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Inquires of the
netCDF dataset which PE is being used as the base for MPP
use. This is safe to use at any time.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="87%">


<p style="margin-top: 1em"><b>integer function
nf_set_base_pe(integer</b> <i>ncid</i><b>, integer</b>
<i>pe</i><b>)</b></p> </td>
<td width="2%">
</td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Resets the base
PE for the netCDF dataset. Only perform this operation when
the affected communicator group synchronizes before and
after the call. This operation is very risky and should only
be contemplated under only the most extreme cases.</p>

<h2>ENVIRONMENT VARIABLES
<a name="ENVIRONMENT VARIABLES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>NETCDF_FFIOSPEC</b></p>

<p style="margin-left:17%;">Specifies the Flexible File I/O
buffers for netCDF I/O when executing under the UNICOS
operating system (the variable is ignored on other operating
systems). An appropriate specification can greatly increase
the efficiency of netCDF I/O -- to the extent that it can
actually surpass FORTRAN binary I/O. This environment
variable has been made a little more generalized, such that
other FFIO option specifications can now be added. The
default specification is <b>bufa:336:2</b>, unless a current
FFIO specification is in operation, which will be honored.
See UNICOS Flexible File I/O for more information.</p>

<h2>MAILING-LISTS
<a name="MAILING-LISTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Both a mailing
list and a digest are available for discussion of the netCDF
interface and announcements about netCDF bugs, fixes, and
enhancements. To begin or change your subscription to either
the mailing-list or the digest, send one of the following in
the body (not the subject line) of an email message to
&quot;majordomo@unidata.ucar.edu&quot;. Use your email
address in place of <i>jdoe@host.inst.domain</i>.</p>

<p style="margin-left:11%; margin-top: 1em">To subscribe to
the netCDF mailing list:</p>

<p style="margin-left:22%;"><b>subscribe netcdfgroup</b>
<i>jdoe@host.inst.domain</i></p>

<p style="margin-left:11%;">To unsubscribe from the netCDF
mailing list:</p>

<p style="margin-left:22%;"><b>unsubscribe netcdfgroup</b>
<i>jdoe@host.inst.domain</i></p>

<p style="margin-left:11%;">To subscribe to the netCDF
digest:</p>

<p style="margin-left:22%;"><b>subscribe netcdfdigest</b>
<i>jdoe@host.inst.domain</i></p>

<p style="margin-left:11%;">To unsubscribe from the netCDF
digest:</p>

<p style="margin-left:22%;"><b>unsubscribe netcdfdigest</b>
<i>jdoe@host.inst.domain</i></p>

<p style="margin-left:11%;">To retrieve the general
introductory information for the mailing list:</p>

<p style="margin-left:22%;"><b>info netcdfgroup</b></p>

<p style="margin-left:11%;">To get a synopsis of other
majordomo commands:</p>

<p style="margin-left:22%;"><b>help</b></p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>ncdump</b>(1),
<b>ncgen</b>(1), <b>netcdf</b>(3f).</p>

<p style="margin-left:11%; margin-top: 1em"><i>netCDF
User&rsquo;s Guide</i>, published by the Unidata Program
Center, University Corporation for Atmospheric Research,
located in Boulder, Colorado.</p>

<p style="margin-left:11%; margin-top: 1em">NetCDF home
page at http:/www.unidata.ucar.edu/netcdf.</p>
<hr>
</body>
</html>
