%------------------------------------------
%       $Id$
%
%       The GMT Documentation Project
%       Copyright (c) 2000-2013.
%       P. Wessel, W. H. F. Smith, R. Scharroo, J. Luis and F. Wobbe
%------------------------------------------
%
\documentclass[11pt]{report}
\newcommand{\GMTTITLE}{C/C++ Application Programming Interface}
\input{GMT_macros}
\usepackage{arydshln}
\makeindex

%--------------------------------------------------------------------------
\begin{document}

\pagenumbering{roman}
\input{GMT_Cover}
\addcontentsline{toc}{chapter}{Front page}
\clearpage

\tableofcontents

\pagestyle{headings}

\chapter{Introduction}
\index{Introduction}
\pagenumbering{arabic}
\index{Purpose of the GMT API}
\index{GMT API!Purpose}

\section{Preamble}
\index{Preamble}

\begin{figure}[h]
	\centering
	\includegraphics[width=10cm,bb=0 0 485 255]{GMT4_mode.png}
	\caption{GMT 4 programs contain all the high-level functionality.}
\end{figure}
Prior to version 5, the bulk of \GMT\ functionality was coded directly
in the standard \GMT\ C program modules (e.g., \filename{surface.c}, \filename{psxy.c}, \filename{grdimage.c}, etc.).
The \GMT\ library only offered access to low-level functions from which those
high-level \GMT\ programs were built.  The standard \GMT\ programs have been very successful,
with tens of thousands of users world-wide.  However, the design of the main programs
prevented developers from leveraging \GMT\ functionality from within other
programming environments since access to \GMT\ tools could only be achieved
via system calls\footnote{or via a very confusing and ever-changing myriad of
low-level library functions for bold programmers.}.
Consequently, all data i/o had to be done via temporary files.
The design also prevented the \GMT\ developers themselves from taking advantage of these
modules directly.  For instance, the tool \GMTprog{pslegend} needed to make extensive use of system calls
to \GMTprog{psxy} and \GMTprog{pstext} in order to plot the lines, symbols and text
that make up a map legend, making it a very awkward program to maintain.

\begin{figure}[h]
	\centering
	\includegraphics[width=10cm,bb=0 0 485 255]{GMT5_mode.png}
	\caption{GMT 4 programs contain all the high-level functionality.}
\end{figure}
Starting with \GMT\ version 5, all standard \GMT\ programs have been split into a short driver
program (the ``new'' \GMT\  programs) and a function ``module''.  The drivers simply call the corresponding \GMT\ modules;
it is these modules that do all the work.  These new functions have been placed
in a new \GMT\ high-level API library and can be called from a variety of environments
(C/C++, Fortran, Python, Matlab, Visual Basic, Julia, R, etc.)\footnote{Currently, only C/C++ and Matlab are being tested.}.
For example, the main program
\filename{blockmean.c} has been reconfigured as a high-level function \GMTfunc{GMT\_blockmean()},
which does the actual spatial averaging and can pass the result back to the calling program (or write it to file).
The previous behavior of \filename{blockmean.c} is replicated by a short driver program
that simply collects user arguments and then calls \GMTfunc{GMT\_blockmean()}.  Indeed, the driver
programs for all the standard \GMT\ programs are identical so that the makefile generates them
on-the-fly when it compiles and links them with the \GMT\ library into executables.
Thus, \filename{blockmean.c} and others do in fact no longer exist.

\section{The i/o abstraction layer}

In order for this interface to be as flexible as possible we have generalized the notion of input
and output. Data that already reside in an application's memory may serve as
input to a \GMT\ function.  Other sources of input may be file pointers
and file descriptors (as well as the already-supported mechanism for passing file names).
For standard data table i/o, the \GMT\ API takes care of the task of assembling any combination
of files, pointers, and memory locations into \emph{a single virtual data set} from which the \GMT\
function may read (a) all records at once into memory, or (b) read one record at a time.
Likewise, \GMT\ functions may write their output to a virtual destination, which
might be a memory location in the user's application, a file pointer or descriptor, or
an output file.  The \GMT\ functions are unaware of these details and simply
read from a ``source'' and write to a ``destination''.

\section{Our audience}

Here, we document the new functions in the \GMT\ API library for application developers
who wish to call these functions from their own custom programs.  At this point,
only the new high-level \GMT\ API is fully documented and intended for public use.
The structure and documentation of the under-lying lower-level \GMT\ library is not finalized.
Developers using these functions may risk disruption to their programs due to changes we may
make in the library in support of the \GMT\ API.  However, developers who wish to make supplemental
packages to be distributed as part of \GMT\ will (other than talk to us) probably want to access
the entire low-level \GMT\ library as well.  It is unlikely that the low-level library will ever be fully
documented.

\section{Definitions}

For the purpose of this documentation a few definitions are needed:

\begin{enumerate}
\item ``Standard \GMT\ program'' refers to one of the traditional stand-alone command-line
executables known to all \GMT\ users, e.g., \GMTprog{blockmean}, \GMTprog{psxy},
\GMTprog{grdimage}, etc.  Prior to version 5, these were the only \GMT\ executables available.
\item ``\GMT\ module'' refers to the function in the \GMT\ API
library that is responsible for all the action taken by the corresponding \GMT\ program.  All
such modules are given the same name as the corresponding program but carry the
prefix \texttt{GMT\_}, e.g., \texttt{GMT\_blockmean}.
\item ``\GMT\ application'' refers to a new application written by any developer
and may call one or more \GMT\ functions to create a new \GMT-compatible executable.
\item In the API description that follows we will use the type \texttt{int} to mean
a 4-byte integer.  All integers used in the API are 4-byte integers with the exception
of one function where a longer integer is used.  Since different operating systems have their
own way of defining 8-byte integers we use C99's \texttt{int64\_t} for this purpose; it is guaranteed to yield
the correct type that the \GMT\ function expect.
\end{enumerate}
In version 5, the standard \GMT\ programs are themselves specific but overly simple examples
of \GMT\ applications that only call the single \GMT\ function they are associated with.
However, some programs such as \GMTprog{pslegend}, \GMTprog{gmtconvert}, \GMTprog{grdblend},
\GMTprog{grdfilter} and others call several modules.

\section{Recognized resources}
\index{Recognized resources}
\index{Resources!Recognized by GMT}

The \GMT\ API knows how to read and write five types of data common to \GMT\ operations:
CPT palette tables, data tables (ASCII or binary), text tables, \GMT\ grids and images (reading only).
In addition, we present two data types to facilitate the passing of simple user arrays (one or more equal-length data columns
of any data type, e.g., double, char) and 2-D or 3-D user matrices (of any data type and column/row
organization\footnote{At the moment, GMT does not have native support for 3-D grids.}). We
refer to these data types as \GMT\ \emph{resources}.
There are many attributes for each of these resources and therefore we use a top-level structure for each type
to keep them all in one container.  These containers are given or returned by the \GMT\ API
functions using opaque pointers (\texttt{void *}).  Below we discuss these containers in some detail; we
will later present how they are used when importing or exporting them to or from files,
memory locations, or streams.  The first five are the standard \GMT\ objects, while the latter two are the
special user data containers to facilitate converting user data into \GMT\ resources. These resources
are defined in the include file \filename{gmt\_resources.h}; please consult this file to ensure correctness
as it is difficult to keep the documentation up-to-date.

\subsection{Data tables}
\index{Data tables}
\index{Resources!Data tables}

Much data processed in \GMT\ come in the form of ASCII, netCDF, or native binary data tables.  These may
have any number of header records (ASCII files only) and perhaps segment headers.  \GMT\ programs will
read one or more such tables when importing data.  However, to avoid memory duplication or limitations
some programs may prefer to read
records one at the time.  The \GMT\ API has functions that let you read record-by-record
by presenting a virtual data set that combines all the data tables specified as input.
This simplifies record processing considerably.  A \texttt{struct GMT\_DATASET} may contain
any number of tables, each with any number of segments, each segment with any number of records,
and each record with any number of columns.   Thus, the
arguments to \GMT\ API functions that handle such data sets expect this type of variable.  All segments
are expected to have the same number of columns.

\subsection{Text tables}
\index{Text tables}
\index{Resources!Text tables}

Some data needed by \GMT\ are simply free-form ASCII text tables.  These are handled
similarly to data tables.  E.g., they may have any number of header records and even segment headers,
and \GMT\ programs can read one or more tables or get text records one at the time.
A \texttt{struct GMT\_TEXTSET} may contain
any number of tables, each with any number of segments, and each segment with any number of records.   Thus, the
arguments to \GMT\ API functions that handle such data sets expect this type of variable.  The user's
program may then parse and process such text records as required.  This resources is particularly useful
when your data consist of a mix or data coordinates and ordinary text since regular data tables will be
parsed for floating-point columns only.

\subsection{GMT grids}
\index{GMT grids}
\index{Resources!GMT grids}

\GMT\ grids are used to represent equidistant and organized 2-D surfaces.  These can be
plotted as contour maps, color images, or as perspective surfaces.  Because the native
\GMT\ grid is simply a 1-D float array with all the metadata kept in a separate header, we
pass this information via a \texttt{struct GMT\_GRID}, which is a container that holds both items.
Thus, the arguments to \GMT\ API functions that handle such \GMT\ grids expect this type
of variable.

\subsection{CPT palette tables}
\index{CPT palette tables}
\index{Resources!CPT palette tables}

The color palette table files, or just CPT tables, contain colors and patterns used for plotting
data such as surfaces (i.e., \GMT\ grids) or symbols, lines and polygons (i.e., \GMT\ tables).
\GMT\ programs will generally read in a CPT
palette table, make it the current palette, do the plotting, and destroy the table when done.
The information is referred to via a pointer to \texttt{struct GMT\_PALETTE}.  Thus, the
arguments to \GMT\ API functions that handle palettes expect this type of variable. It is not expected
that users will wish to manipulate a CPT table directly, but rather use this mechanism to hold them
in memory and pass as arguments to \GMT\ modules.

\subsection{GMT images}
\index{GMT images}
\index{Resources!GMT images}

\GMT\ images are used to represent bit-mapped images typically obtained via the GDAL bridge.  These can be
reprojected internally, such as when used in grdimage.  Since images and grids share the concept
of a header, we use the same header structure for grids as for images; however, some additional
metadata attributes are also needed.  Finally, the image itself may be of any data type and have more than one band (channel).
Both image and header information are passed via a \texttt{struct GMT\_IMAGE}, which is a container that holds both items.
Thus, the arguments to \GMT\ API functions that handle \GMT\ images expect this type
of variable.  Unlike the other objects, images can only be read and not written\footnote{This may change in later releases.}.

\subsection{User data columns (GMT vectors)}
\index{User data columns}
\index{GMT vectors}
\index{Resources!User data columns}

Programs that wish to call \GMT\ modules may hold data in their own particular data
structures.  For instance, the user's program may have three column arrays of type float
and wishes to use these as the input source to the \texttt{GMT\_surface} module, which normally
expects double precision triplets via a \texttt{struct GMT\_DATASET} read from a file or given by memory reference.
Simply create a new \texttt{struct GMT\_VECTOR} (see section~\ref{sec:create}) and assign the union
array pointers (see Table~\ref{tbl:univector}) to your data columns and provide
the required information on length, data types, and optionally range (see Table~\ref{tbl:vector}).
By letting the \GMT\ module know you are passing a data set \emph{via} a \texttt{struct GMT\_VECTOR} it
will know how to read the data correctly.

\begin{table}[h]
\small
\centering
\begin{tabular}{ll} \hline
\verb!union GMT_UNIVECTOR {! & \\
\verb!  uint8_t *uc1;!  & /* \emph{Pointer for unsigned 1-byte array} */ \\
\verb!  int8_t *sc1;!   & /* \emph{Pointer for signed 1-byte array} */ \\
\verb!  uint16_t *ui2;! & /* \emph{Pointer for unsigned 2-byte array} */ \\
\verb!  int16_t *si2;!  & /* \emph{Pointer for signed 2-byte array} */ \\
\verb!  uint32_t *ui4;! & /* \emph{Pointer for unsigned 4-byte array} */ \\
\verb!  int32_t *si4;!  & /* \emph{Pointer for signed 4-byte array} */ \\
\verb!  uint64_t *ui8;! & /* \emph{Pointer for unsigned 8-byte array} */ \\
\verb!  int64_t *si8;!  & /* \emph{Pointer for signed 8-byte array} */ \\
\verb!  float *f4;!     & /* \emph{Pointer for float array} */ \\
\verb!  double *f8;!    & /* \emph{Pointer for double array} */ \\
\verb!};!               & \\
\hline
\end{tabular}
\caption{Definition of the GMT\_UNIVECTOR union that holds a pointer to any array type.}
\label{tbl:univector}
\index{Vectors!Structure}
\end{table}

\begin{table}[h]
\small
\centering
\begin{tabular}{ll} \hline
\verb!struct GMT_VECTOR {!               & \\
\verb!  unsigned int n_columns;!         & /* \emph{Number of vectors} */\\
\verb!  uint64_t n_rows;!                & /* \emph{Number of rows in each vector} */ \\
\verb!  enum GMT_enum_type *type;!       & /* \emph{Array with data type for each vector} */\\
\verb!  double range[2];!                & /* \emph{The min and max limits on t-range (or 0,0) } */\\
\verb!  union GMT_UNIVECTOR *data;!      & /* \emph{Array with unions for each column} */\\ \hdashline
\verb!  unsigned int id;!                & /* \emph{An identification number} */ \\
\verb!  enum GMT_enum_alloc alloc_mode;! & /* \emph{Determines if we may free the vectors or not} */\\
\verb!};!                                & \\
\hline
\end{tabular}
\caption{Definition of the GMT\_VECTOR structure used to pass user data columns.  Items below the dashed
line are not meant to be accessed by developers.}
\label{tbl:vector}
\index{Vectors!Structure}
\end{table}
\noindent

\subsection{User data matrices (GMT matrices)}
\index{User data matrices}
\index{GMT matrices}
\index{Resources!User data matrices}

\begin{table}[h]
\small
\centering
\begin{tabular}{ll} \hline
\verb!struct GMT_MATRIX {!               & \\
\verb!  unsigned int n_rows;!            & /* \emph{Number of rows in the matrix} */ \\
\verb!  unsigned int n_columns;!         & /* \emph{Number of columns in the matrix} */\\
\verb!  unsigned int n_layers;!          & /* \emph{Number of layers in a 3-D matrix} */\\
\verb!  unsigned int shape;!             & /* \emph{0 = C (rows) and 1 = Fortran (cols)} */\\
\verb!  unsigned int registration;!      & /* \emph{0 for gridline and 1 for pixel registration} */\\
\verb!  size_t dim;!                     & /* \emph{Length of dimension for row (C) or column (Fortran)} */\\
\verb!  size_t size;!                    & /* \emph{Byte length of data} */\\
\verb!  enum GMT_enum_alloc alloc_mode;! & /* \emph{Determines if we may free the vectors or not} */\\
\verb!  double range[6];!                & /* \emph{The min and max limits on x-, y-, and z-ranges} */\\
\verb!  union GMT_UNIVECTOR data;!       & /* \emph{Union with pointers a data matrix of any type} */\\ \hdashline
\verb!  unsigned int id;!                & /* \emph{An identification number} */ \\
\verb!  enum GMT_enum_type type;!        & /* \emph{The matrix data type} */\\
\verb!};!                              & \\ \hline
\end{tabular}
\caption{Definition of the GMT\_MATRIX structure used to pass a user data matrix. Items below the dashed
line are not meant to be accessed by developers.}
\label{tbl:matrix}
\index{Matrix!Structure}
\end{table}
\noindent
Likewise, programs may have an integer 2-D matrix in memory 
and wish to use that as the input grid to the \texttt{GMT\_grdfilter} module, which normally
expects a \texttt{struct GMT\_GRID} with floating point data via a file or provided by memory reference.  As for user vectors, we create a
\texttt{struct GMT\_MATRIX} (see section~\ref{sec:create}), assign the appropriate union pointer to your data
matrix and provide information on dimensions and data type (see Table~\ref{tbl:matrix}).
Let the \GMT\ module know you are passing a grid via a
\texttt{struct GMT\_MATRIX} and it will know how to read the matrix properly.

The \texttt{enum} types referenced in Table~\ref{tbl:vector} and Table~\ref{tbl:matrix} and summarized in Table~\ref{tbl:enums}
and Table~\ref{tbl:types}.
\begin{table}[h]
\small
\centering
\begin{tabular}{|l|l|l|} \hline
\multicolumn{1}{|c|}{\emph{constant}} & \multicolumn{1}{c|}{\emph{value}}  & \multicolumn{1}{c|}{\emph{Description}} \\ \hline
GMT\_ALLOCATED		&      0	& Normal case; free item when done \\ \hline
GMT\_REFERENCE		&      1	& Item was \emph{not} allocated so do not free, but reallocate is ok \\ \hline
GMT\_READONLY		&      2	& Do not allocate or reallocate \\ \hline
GMT\_CLOBBER		&      3	& Free item no matter what its allocation status \\ \hline
\end{tabular}
\caption{Enumeration constants defined for decoding allocation modes.}
\label{tbl:enums}
\index{Resources!Parameters!Allocation constants}
\end{table}

\begin{table}[h]
\small
\centering
\begin{tabular}{|l|l|l|} \hline
\multicolumn{1}{|c|}{\emph{constant}} & \multicolumn{1}{c|}{\emph{value}}  & \multicolumn{1}{c|}{\emph{Description}} \\ \hline
GMT\_CHAR	&      0	& int8\_t, 1-byte signed integer type \\ \hline
GMT\_UCHAR	&      1	& int8\_t, 1-byte unsigned integer type \\ \hline
GMT\_SHORT	&      2	& int16\_t, 2-byte signed integer type \\ \hline
GMT\_USHORT	&      3	& uint16\_t, 2-byte unsigned integer type \\ \hline
GMT\_INT	&      4	& int32\_t, 4-byte signed integer type \\ \hline
GMT\_UINT	&      5	& uint32\_t, 4-byte unsigned integer type \\ \hline
GMT\_LONG	&      6	& int64\_t, 8-byte signed integer type \\ \hline
GMT\_ULONG	&      7	& uint64\_t, 8-byte unsigned integer type \\ \hline
GMT\_FLOAT	&      8	& 4-byte data float type \\ \hline
GMT\_DOUBLE	&      9	& 8-byte data float type \\ \hline
\end{tabular}
\caption{Enumeration constants defined for decoding data types.}
\label{tbl:types}
\index{Resources!Parameters!Data types}
\end{table}

\chapter{Overview of the GMT C Application Program Interface}
\index{Overview of interface}
\index{C Interface!Overview}
\label{ch:overview}

Users who wish to create their own \GMT\ application based on the API
must make sure their program goes through the steps below; details
for each step will be revealed in the following chapter.  We have kept the
API simple: In addition to the \GMT\ modules, there are only 20 public functions to become familiar with,
but most applications will only use a small subset of this selection.
Functions either return an integer error code (when things go wrong; otherwise it is set to GMT\_OK (0)),
or they return a void pointer to a \GMT\ resources (or NULL if things go wrong).  In either case
the API will report what the error is.
The layout here assumes you wish to use data in memory as input sources; if the data are simply
command-line files then things simplify considerably.

\begin{enumerate}
\item Initialize a new \GMT\ session with \texttt{GMT\_Create\_Session}, which
allocates a hidden \GMT\ API control structure and returns an opaque pointer to it.  This pointer is
the first argument to all subsequent \GMT\ API function calls within the session.
\item For each intended call to a \GMT\ module, several steps are involved:
\begin{enumerate}
\item Register input sources and output destination with \texttt{GMT\_Register\_IO}.
\item Each resource registration generates a unique ID number.  For memory resources, we embed these numbers
in unique filenames of the form ``@GMTAPI@-\#\#\#\#\#\#''.  When
\GMT\ i/o library functions encounter such filenames they extract the ID and make a connection
to the corresponding resource.  Multiple table data or text sources
are combined into a single virtual source for \GMT\ modules to operate on.
In contrast, CPT, Grid, and Image resources are operated on individually.
\item Enable data import once all registrations are complete.
\item Read data into memory. You may choose to read everything at once or read record-by-record (tables only).
\item Prepare required arguments and call the \GMT\ module you wish to use.
\item Process any results returned to memory via pointers rather than written to files.
\item Destroy the resources allocated by \GMT\ modules to hold results, or let the
garbage collector do this automatically at the end of the module and at the end of the session.
\end{enumerate}
\item Repeat steps a--f as many times as your application requires.
\item We terminate the GMT session by calling \texttt{GMT\_Destroy\_Session}.
\end{enumerate}

The steps a--d collapse into a single step if data are simply read from files.

Advanced programs may be calling more than one \GMT\ session and thus run several
sessions, perhaps concurrently as different threads on multi-core machines.
We will now discuss these steps in more detail.  Throughout, we will introduce upper-case \GMT\ C enum
constants \emph{in lieu} of simple integer constants.  These are considered part of the API
and are available for developers via the \filename{gmt\_resources.h} include file.

The C/C++ API is deliberately kept small to make it easy to use.  Table~\ref{tbl:API} gives a list
of all the functions and their purpose.

\begin{table}[h]
\small
\centering
\begin{tabular}{|l|l|} \hline
\multicolumn{1}{|c|}{\emph{constant}} & \multicolumn{1}{c|}{\emph{Description}} \\ \hline
GMT\_Append\_Option     & Append new option structure to linked list \\ \hline
GMT\_Begin\_IO     	& Enable record-by-record i/o \\ \hline
GMT\_Create\_Args     	& Convert linked list of options to text array \\ \hline
GMT\_Create\_Cmd     	& Convert linked list of options to command line \\ \hline
GMT\_Create\_Data     	& Create an empty data resource\\ \hline
GMT\_Create\_Session	& Initialize a new GMT session \\ \hline
GMT\_Delete\_Option	& Delete an option structure from the linked list \\ \hline
GMT\_Destroy\_Args	& Delete text array of arguments \\ \hline
GMT\_Destroy\_Data	& Delete a data resource \\ \hline
GMT\_Destroy\_Options	& Delete the linked list of option structures \\ \hline
GMT\_Destroy\_Session	& Terminate a GMT session \\ \hline
GMT\_Duplicate\_Data    & Make an identical copy of a data resources \\ \hline
GMT\_Encode\_ID      	& Encode a resources ID as a special filename \\ \hline
GMT\_End\_IO		& Disable further record-by-record i/o \\ \hline
GMT\_FFT		& Take the Fast Fourier Transform of data \\ \hline
GMT\_FFT\_Create	& Initialize the FFT machinery \\ \hline
GMT\_FFT\_Destroy	& Terminate the FFT machinery \\ \hline
GMT\_FFT\_Option	& Explain the FFT options and modifiers \\ \hline
GMT\_FFT\_Parse		& Parse argument with FFT options and modifiers \\ \hline
GMT\_FFT\_Wavenumber	& Return wavenumber given data index \\ \hline
GMT\_Find\_Option	& Find an option in the linked list \\ \hline
GMT\_Get\_Common	& Determine if a GMT common option was set \\ \hline
GMT\_Get\_Coord		& Create a coordinate array \\ \hline
GMT\_Get\_Data		& Import a registered data resources \\ \hline
GMT\_Get\_Index		& Convert row, col into a grid or image index \\ \hline
GMT\_Get\_Record	& Import a single data record \\ \hline
GMT\_Get\_Row		& Import a single grid row \\ \hline
GMT\_Init\_IO		& Initialize i/o given registered resources \\ \hline
GMT\_Make\_Option	& Create an option structure \\ \hline
GMT\_Message		& Issue a message, optionally with time stamp \\ \hline
GMT\_Option		& Explain one or more GMT common options \\ \hline
GMT\_Parse\_Common	& Parse the GMT common options \\ \hline
GMT\_Prep\_Options	& Convert command line options to linked list \\ \hline
GMT\_Put\_Data		& Export to a registered data resource \\ \hline
GMT\_Put\_Record	& Export a data record \\ \hline
GMT\_Put\_Row		& Export a grid row \\ \hline
GMT\_Read\_Data		& Import a data resource or file \\ \hline
GMT\_Register\_IO	& Register a resources for i/o \\ \hline
GMT\_Report		& Issue a message contingent upon verbosity level \\ \hline
GMT\_Retrieve\_Data	& Obtained link to data in memory \\ \hline
GMT\_Set\_Comment	& Assign a comment to a data resource \\ \hline
GMT\_Status\_IO		& Check status of record-by-record i/o \\ \hline
GMT\_Update\_Option	& Modify an option structure \\ \hline
GMT\_Write\_Data	& Export a data resource \\ \hline
\end{tabular}
\caption{Alphabetical listing of all 44 API functions.}
\label{tbl:API}
\index{API!functions}
\end{table}

\chapter{The GMT C Application Program Interface}
\index{C interface}
\index{Interface!C}

\section{Initialize a new GMT\ session}
\index{Initialize a new GMT session}
\index{GMT session!Initialize}

Most applications will need to initialize only a single \GMT\ session.  This is true of all
the standard \GMT\ programs since they only call one \GMT\ module and then exit.  Most
user-developed \GMT\ applications are likely to only initialize one session even though
they may call many \GMT\ modules.  However, the \GMT\ API supports any number of
simultaneous sessions should the programmer wish to take advantage of it.  This
might be useful when you have access to several CPUs and want to spread the computing
load\footnote{However, there is no thread-support yet.}.  In the following discussion we
will simplify our treatment to the use of a single session only.

To initiate the new session we use

\index{GMT\_Create\_Session}
\begin{verbatim}
void * GMT_Create_Session (char *tag, unsigned int pad, unsigned int mode);
\end{verbatim}
and you will typically call it thus:
\begin{verbatim}
void *API = NULL;
API = GMT_Create_Session ("Session name", 2, 0);
\end{verbatim}
where \texttt{API} is an opaque pointer to the hidden \GMT\ API control structure.  You will need to
pass this pointer to \emph{all} subsequent \GMT\ API functions; this is how essential internal information
is passed from module to module.  The key task of this initialization
is to set up the \GMT\ machinery and its internal variables used for map projections, plotting, i/o,
etc.  The initialization also allocates space for internal structures used to register resources.
The \texttt{pad} argument sets how many rows and columns should be used for padding for grids and images
so that boundary conditions can be applied. \GMT\ uses 2 so we recommend that value. 
The \texttt{mode} argument is currently unused and reserved for future expansion. 
Should something go wrong then \texttt{API} will be returned as \texttt{NULL}.

\section{Register input or output resources}
\index{Register input or output resources}
\index{Resources!Register}
\index{Resources!Input}
\index{Resources!Output}
\index{Sources!Register Input}
\index{Sources!Register Output}

When using the standard \GMT\ programs, you specify input files on
the command line or via special program options (e.g., \Opt{I}\emph{intensity.nc}). The output of
the programs are either written to standard output (which you redirect to files or pipe to other programs)
or to files specified by specific program options (e.g., \Opt{G}\emph{output.nc}).  Alternatively, the
\GMT\ API allows you to specify input (and output) to be associated with open file handles
or program variables.  We will examine this more closely below.  Registering a
resource is a required step before attempting to import or export data that \emph{do not} come from files
or standard input/output.

\subsection{Resource registration}
Registration involves a direct or indirect call to
\index{GMT\_Register\_IO}

\begin{verbatim}
int GMT_Register_IO (void *API, unsigned int family, \
    unsigned int method, unsigned int geometry, \
    unsigned int direction, double wesn[], void *ptr);
\end{verbatim}
where \texttt{family} specifies what kind of resource is to be registered
(see Table \ref{tbl:family} for list of all families), \texttt{method} specifies
how we to access this resource (see Table \ref{tbl:methods} for recognized methods,
as well as modifiers you can add; these are listed in Table \ref{tbl:via}),
\texttt{geometry} specifies the geometry of the data (see Table \ref{tbl:geometry} for recognized geometries),
\texttt{ptr} is the address of the pointer to the named resource.  If \texttt{direction}
is GMT\_OUT and the \texttt{method} is not related to a file (filename, stream, or handle),
then \texttt{ptr} must be NULL.  After the \GMT\ module has written the data you can use
\texttt{GMT\_Retrieve\_Data} to assign a pointer to the memory location (variable) where the output was allocated.
For grid (and image) resources you may request to obtain a subset via the \texttt{wesn}
array (see Table~\ref{tbl:wesn} for information); otherwise, pass NULL to obtain the entire grid (or image).
The \texttt{direction} indicates input or output and is either GMT\_IN (0) or GMT\_OUT (1).
Finally, the function returns a unique resource ID, or GMTAPI\_NOTSET (-1) if there was an
error.

\subsection{Object ID encoding}
To use registered resources as program input or output arguments you must pass them via
a text string that acts as a special file name (Chapter~\ref{ch:overview}).  The proper filename
formatting is guaranteed by using the function
\index{GMT\_Encode\_ID}

\begin{verbatim}
int GMT_Encode_ID (void *API, char *filename, int ID);
\end{verbatim}
which accepts the unique \texttt{ID} and writes the corresponding \texttt{filename}.
The variable \texttt{filename} must have enough space to hold 16 bytes.
The function returns TRUE (1) if there is an error; otherwise it returns FALSE (0).

\begin{table}[h]
\small
\centering
\begin{tabular}{|l|l|l|} \hline
\multicolumn{1}{|c|}{\emph{family}} & \multicolumn{1}{c|}{\emph{value}} & \multicolumn{1}{c|}{\emph{source points to}} \\ \hline
GMT\_IS\_DATASET	&	0	&	A [multi-segment] table file \\ \hline
GMT\_IS\_TEXTSET	&	1	&	A [multi-segment] text file \\ \hline
GMT\_IS\_GRID		&	2	&	A \GMT\ grid file \\ \hline
GMT\_IS\_CPT		&	3	&	A CPT file \\ \hline
GMT\_IS\_IMAGE		&	4	&	A \GMT\ image \\ \hline
\end{tabular}
\caption{API constants for specifying input or output data families.}
\label{tbl:family}
\index{Resources!Parameters!Floating point}
\end{table}


\begin{table}[h]
\small
\centering
\begin{tabular}{|l|l|l|} \hline
\multicolumn{1}{|c|}{\emph{method}} & \multicolumn{1}{c|}{\emph{value}} & \multicolumn{1}{c|}{\emph{how to read/write data}} \\ \hline
GMT\_IS\_FILE		&	0	&       Pointer to name of a file \\ \hline
GMT\_IS\_STREAM		&	1	&       Pointer to open stream (or process)  \\ \hline
GMT\_IS\_FDESC		&	2	&       Pointer to integer file descriptor \\ \hline
GMT\_IS\_DUPLICATE	&	3	&       Pointer to memory we may \emph{duplicate} data from \\ \hline
GMT\_IS\_REFERENCE	&	4	&       Pointer to memory we may \emph{reference} data from (realloc OK) \\ \hline
GMT\_IS\_READONLY	&	5	&       Pointer to memory we may \emph{read} data from (no realloc) \\ \hline
\end{tabular}
\caption{API constants used when specifying input or output methods.}
\label{tbl:methods}
\index{Resources!Methods}
\end{table}

\begin{table}[h]
\small
\centering
\begin{tabular}{|l|l|l|} \hline
\multicolumn{1}{|c|}{\emph{approach}} & \multicolumn{1}{c|}{\emph{value}} & \multicolumn{1}{c|}{\emph{how method is modified}} \\ \hline
GMT\_VIA\_VECTOR	&	100	&       User's data columns are accessed via a GMT\_VECTOR structure \\ \hline
GMT\_VIA\_MATRIX	&	200	&       User's matrix is accessed via a GMT\_MATRIX structure \\ \hline
\end{tabular}
\caption{API constants used when user data forms are involved.  These are added
to the \emph{method} value used when registering the resource.}
\label{tbl:via}
\index{Resources!Conversions}
\end{table}

\begin{table}[h]
\small
\centering
\begin{tabular}{|l|l|l|} \hline
\multicolumn{1}{|c|}{\emph{geometry}} & \multicolumn{1}{c|}{\emph{value}} & \multicolumn{1}{c|}{\emph{description}} \\ \hline
GMT\_IS\_TEXT		&	0	&       Not a geographic item \\ \hline
GMT\_IS\_POINT		&	1	&       Multi-dimensional point data \\ \hline
GMT\_IS\_LINE		&	2	&       Geographic or Cartesian line segments \\ \hline
GMT\_IS\_POLYGON	&	3	&       Geographic or Cartesian closed polygons \\ \hline
GMT\_IS\_SURFACE	&	4	&       2-D gridded surface \\ \hline
\end{tabular}
\caption{API constants defined to register different geometries.}
\label{tbl:geometry}
\index{Resources!Geometries}
\end{table}

\begin{table}[h]
\small
\centering
\begin{tabular}{|c|l|l|} \hline
\multicolumn{2}{|c|}{\emph{Index}} & \multicolumn{1}{c|}{\emph{content}} \\ \hline
0 & GMT\_XLO	&       x\_min (west) boundary of grid subset  \\ \hline
1 & GMT\_XHI	&       x\_max (east) boundary of grid subset  \\ \hline
2 & GMT\_YLO	&       y\_min (south) boundary of grid subset  \\ \hline
3 & GMT\_YHI	&       y\_max (north) boundary of grid subset  \\ \hline
4 & GMT\_ZLO	&       z\_min (bottom) boundary of 3-D matrix subset  \\ \hline
5 & GMT\_ZHI	&       z\_max (top) boundary of 3-D matrix subset  \\ \hline
\end{tabular}
\caption{Domain boundaries (\texttt{wesn}) used when selecting subsets of grids.  The indices for
the 3rd dimension can be used with GMT\_MATRIX resources.}
\label{tbl:wesn}
\index{Resources!Parameters!Domain}
\end{table}

\subsection{Resource initialization}
\index{Resources!Initialization}
\index{Initialization!Resources}
All \GMT\ programs dealing with input or output files given on the command line, and perhaps defaulting to
the standard input or output streams if no files are given, must call the i/o initializer function
\texttt{GMT\_Init\_IO} once for each direction required (i.e., input and output separately).
For input it determines how many input sources have already been registered.
If none has been registered then it scans the program arguments for any filenames given on the command line and register
these input resources.  Finally, if we still have found no input sources we assign the standard input stream
as the single input source.  For output it is similar: If no single destination has been registered we specify the standard output stream
as the output destination.  Only one main output destination is allowed to be active when a module writes data (some
modules also write additional output via program-specific options).
The prototype for this function is
\index{GMT\_Init\_IO}

\begin{verbatim}
int GMT_Init_IO (void *API, unsigned int family, unsigned int geometry, \
    unsigned int direction, unsigned int mode, unsigned int n_args, \
    void *args);
\end{verbatim}
where \texttt{family} specifies what kind of resource is to be registered,
\texttt{geometry} specifies the geometry of the data,
\texttt{direction} is either \texttt{GMT\_IN} or \texttt{GMT\_OUT}, and
\texttt{mode} is a bit flag that determines what we do if no resources have been
registered. The choices are
\begin{description}
	\item [1] (or GMT\_ADD\_FILES\_IF\_NONE) means ``add command line (option) files if none have been registered already''
	\item [2] (or GMT\_ADD\_FILES\_ALWAYS) means ``always add any command line files''
	\item [4] (or GMT\_ADD\_STDIO\_IF\_NONE) means ``add std* if no other input/output have been specified''
	\item [8] (or GMT\_ADD\_STDIO\_ALWAYS) means ``always add std* even if resources have been registered''.
\end{description}
\index{GMT\_ADD\_FILES\_IF\_NONE}
\index{GMT\_ADD\_FILES\_ALWAYS}
\index{GMT\_ADD\_STDIO\_IF\_NONE}
\index{GMT\_ADD\_STDIO\_ALWAYS}
\index{GMT\_REG\_DEFAULT}
The standard behavior is 5 (or GMT\_REG\_DEFAULT).
Next, \texttt{n\_args} is 0 if \texttt{args} is the head of a linked list of options (further discussed in Section~\ref{sec:func});
otherwise \texttt{args} is an array of \texttt{n\_args} strings (i.e., the int argc, char *argv[] model)

Many programs will register an export location where results of a \GMT\ function (say,
a filtered grid) should be returned, but may then wish to use that variable as an \emph{input}
resource in a subsequent module call.  This is accomplished by re-registering the resource
as an \emph{input} source, thereby changing the \emph{direction} of the data set.
The function returns TRUE (1) if there is an error; otherwise it returns FALSE (0).

\subsection{Dimension parameters for user 1-D column vectors}
We refer to Table~\ref{tbl:vector}.  The \texttt{type} array must hold the
data type of each data column in the user's program.  All types other than GMT\_DOUBLE will
be converted internally in \GMT\ to \texttt{double}, thus possibly increasing memory requirements.
If the type is GMT\_DOUBLE then \GMT\ will be able to use the column directly by reference.  The \texttt{n\_columns}
and \texttt{n\_rows} parameters indicate the number of vectors and their common length.  If these
are not yet known you may pass 0 for these values
and set \texttt{alloc\_mode} to GMT\_REFERENCE (1); this will make
sure \GMT\ will allocate the necessary memory to the variable you specify.

\subsection{Dimension parameters for user 2-D table arrays}

We refer to Table~\ref{tbl:matrix}.  The \texttt{type} parameter specifies the
data type used for the array in the user's program.  All types other than GMT\_FLOAT will
be converted internally in \GMT\ to \texttt{float}, thus possibly increasing memory requirements.
If the type is GMT\_FLOAT then \GMT\ may be able to use the matrix directly by reference.  The \texttt{n\_rows}
and \texttt{n\_columns} parameters indicate the dimensions of the matrix.  If these
are not yet known you may pass 0 for these values and set \texttt{alloc\_mode} to GMT\_REFERENCE 1; this will make
sure \GMT\ will allocate the necessary memory at the location you specify.  Fortran users
will instead have to specify a size large enough to hold the anticipated output data.
The \texttt{registration} and \texttt{range} gives the grid registration and domain.
Finally, use \texttt{dim} to indicate if the memory matrix has a dimension that
exceeds that of the leading row (or column) dimension. Note: For GMT\_IS\_TEXTSET
the user matrix is expected to be a 2-D character array with a fixed row length of \texttt{dim}
but we only consider the first \texttt{n\_columns} characters.  For data grids you will
also need to specify the \texttt{registration}  (see the \GMT\ Cookbook and Reference,
Appendix B for description of the two forms of registration) and data domain \texttt{range}.

\section{Create empty resources}
\index{Create empty resources}
\index{Resources!Create}
\label{sec:create}

If your application needs to build and populate \GMT\ resources in ways that do
not depend on external resources (files, memory locations, etc.), then you
can obtain a ``blank slate'' by calling

\begin{verbatim}
void * GMT_Create_Data (void *API, unsigned int family, \
    unsigned int geometry, unsigned int mode, uint64_t par[], \
    double *wesn, double *inc, unsigned int registration, int pad, void *data
\end{verbatim}
\index{GMT\_Create\_Data}
which returns a pointer to the allocated resource.
Pass \texttt{family} as one of GMT\_IS\_GRID, GMT\_IS\_IMAGE, GMT\_IS\_DATASET, GMT\_IS\_TEXTSET, or GMT\_IS\_CPT,
or via the modifiers GMT\_IS\_VECTOR or GMT\_IS\_MATRIX when handling user data.  Also pass
a compatible \texttt{geometry}.
Depending on the family and your particular way of representing dimensions you may pass
the additional parameters in one of two ways:
\begin{enumerate}
	\item Actual integer dimensions of items needed.
	\item Physical distances and increments of each dimension.
\end{enumerate}

For method (1), pass the \texttt{par} array, as indicated below:
\begin{description}
	\item [GMT\_IS\_GRID]: An empty GMT\_GRID structure with a header is
	allocated; the data array is NULL.  The \texttt{par} argument is not used.
	\item [GMT\_IS\_IMAGE]: An empty GMT\_GRID structure with a header is
	allocated; the image array is NULL.  The \texttt{par} argument is not used.
	\item [GMT\_IS\_DATASET]: An empty GMT\_DATASET structure consisting of
	\texttt{par[0]} tables, each with \texttt{par[1]} segments, each with
	\texttt{par[2]} columns, all with \texttt{par[3]} rows, is allocated.
	\item [GMT\_IS\_TEXTSET]: An empty GMT\_TEXTSET structure consisting of
	\texttt{par[0]} tables, each with \texttt{par[1]} segments,
	all with \texttt{par[2]} text record, is allocated.
	\item [GMT\_IS\_CPT]: An empty GMT\_PALETTE structure with \texttt{par[0]}
	palette entries is allocated.
	\item [GMT\_IS\_VECTOR]: An empty GMT\_VECTOR structure with \texttt{par[0]}
	column entries is allocated.
	\item [GMT\_IS\_MATRIX]: An empty GMT\_MATRIX structure is allocated.
	\texttt{par[0]} indicates the number of layers for a 3-D matrix, or pass 0, 1, or
	NULL for a 2-D matrix.
	
\end{description}
In this case, pass \texttt{wesn}, \texttt{inc} as NULL.
For method (2), you instead pass \texttt{wesn}, \texttt{inc}, and \texttt{registration}
and leave \textt{par} as NULL.  For grids and images you may
pass \texttt{pad} to set the padding, or -1 to accept the \GMT\ default.
The \texttt{mode} determines what is actually allocated when you have chosen grids or
images.  As for \texttt{GMT\_Read\_Data} you can pass \texttt{GMT\_GRID\_ALL} to
initialize the header and allocate space for the array.  Alternatively, you can
pass \texttt{GMT\_GRID\_HEADER\_ONLY} to just initialize the grid or image header, and
call \textt{GMT\_Create\_Data} a second time, passing \texttt{GMT\_GRID\_DATA\_ONLY}, to allocate space for the array.
In that second call you pass the pointer returned by the first call as \texttt{data}
and specify the family; all other arguments should be NULL or 0.
The function returns a pointer to the data container. In case of an error we return a
NULL pointer and pass an error code via \texttt{API->error}.
\index{GMT\_GRID\_ALL}
\index{GMT\_GRID\_HEADER\_ONLY}
\index{GMT\_GRID\_DATA\_ONLY}

\section{Duplicate resources}
\index{Duplicate resources}
\index{Resources!Duplicate}
\label{sec:duplicate}
\index{Duplicate!Data}
\index{Data!Duplicate}

Often you have read or created a data resource and then need an identical copy, presumably
to make modifications to.  Or, you want a copy with the same dimensions and allocated memory,
except data values should not be duplicated. Alternatively, perhaps you just want to duplicate
the header and skip the allocation and duplication of the data.  These tasks are addressed by

\begin{verbatim}
void * GMT_Duplicate_Data (void *API, unsigned int family, \
    unsigned int mode, void *data);
\end{verbatim}
\index{GMT\_Duplicate\_Data}
which returns a pointer to the allocated resource.  Specify which \texttt{family} and
select \texttt{mode} from \texttt{GMT\_DUPLICATE\_DATA}, \texttt{GMT\_DUPLICATE\_ALLOC},
and \texttt{GMT\_DUPLICATE\_NONE}, as discussed above.  The \texttt{data} is a pointer
to the resource you wish to duplicate.  In case of an error we return a
NULL pointer and pass an error code via \texttt{API->error}.
\index{GMT\_DUPLICATE\_DATA}
\index{GMT\_DUPLICATE\_ALLOC}
\index{GMT\_DUPLICATE\_NONE}

\section{Import Data}
\index{Import!Data}
\index{Data!Import}
\index{Resources!Import data}

If your main program needs to read any of the five recognized data types (CPT files, data tables, text tables, \GMT\ grids, or images)
you will use the \texttt{GMT\_Get\_Data} or \texttt{GMT\_Read\_Data} functions, which both return entire data sets.
In the case of data and text tables you may also select record-by-record reading using the \texttt{GMT\_Get\_Record} function.
As a general rule, your program development simplifies if you can read entire resources into memory with
\texttt{GMT\_Get\_Data} or \texttt{GMT\_Read\_Data}.  However, if this leads to unacceptable memory usage or if the program logic is particularly simple,
you may obtain one data record at the time via \texttt{GMT\_Get\_Record}.

All input functions takes a parameter called \texttt{mode}.  The \texttt{mode} parameter generally
has different meanings for the different data types and will be discussed below.
However, one bit setting is common to all types: By default, you are only allowed to read a
data source once; the source is then flagged as having been read and subsequent attempts to read
from the same source will result in a warning and no reading takes place.  In the unlikely event you need to re-read a
source you can override this default behavior by adding GMT\_IO\_RESET to your \texttt{mode} parameter.
Note that this override does not apply to sources that are streams or file handles, as it may not be
possible to re-read their contents.

\subsection{Enable Data Import}
\index{Import!Enable}
\index{Data!Import}
\index{Resources!Import data}

Once all input resources have been registered, we signal the API that we are done with the registration
phase and are ready to start the actual data import.  This step is only required when reading one record at the
time.  We initialize record-by-record reading by calling \texttt{GMT\_Begin\_IO}.  This function enables dataset
and textset record-by-record reading and prepares the registered sources for the upcoming import.
The prototype is

\begin{verbatim}
int GMT_Begin_IO (void *API, unsigned int family, unsigned int direction, \
    unsigned int mode, unsigned int header);
\end{verbatim}
where \texttt{family} specifies the resource type to be read or written (see Table \ref{tbl:family};
only GMT\_IS\_DATASET and GMT\_IS\_TEXTSET are available for record-by-record handling).
The \texttt{direction} is either GMT\_IN or GMT\_out, so for import we obviously use GMT\_IN.
The function determines the first input source and sets up procedures for skipping to the next input source in a virtual data set.
The \texttt{GMT\_Get\_Record} function will not be able to read any data before \texttt{GMT\_Begin\_IO} has been called.  As you might
guess, there is a companion \texttt{GMT\_End\_IO} function that completes, then disables record-by-record data access.  You can use these several
times to switch modes between registering data resources, doing the importing/exporting, and disabling further
data access, perhaps to do more registration.  We will discuss \texttt{GMT\_End\_IO} once we are done with the data import.
The \texttt{mode} option is used to allow output to write table header information (\texttt{GMT\_HEADER\_ON}) or not (\texttt{GMT\_HEADER\_OFF}).
This is usually on unless you are writing messages and other non-data.
The final \texttt{header} argument determines if the common header-block should be written during initialization; choose
between \texttt{GMT\_HEADER\_ON} (1) and \texttt{GMT\_HEADER\_OFF} (0).
The function returns TRUE (1) if there is an error; otherwise it returns FALSE (0).

\subsection{Import a data set}
\index{Import!Data set}
\index{Data!Import data}
\index{Resources!Import data set}

If your program needs to import any of the five recognized data types (CPT table, data table, text table, \GMT\ grid, or image)
you will use either the \texttt{GMT\_Read\_Data} or \texttt{GMT\_Get\_Data} functions.  The former is typically used when
reading from files, streams (e.g., \texttt{stdin}), or an open file handle, while the latter is only used with a registered
resource via its unique ID.  Because of the similarities of these five import functions we use an generic form that covers all of them.

\subsubsection{Import from a file, stream, or handle}
\index{GMT\_Read\_Data}
To read an entire resource from a file, stream, or file handle, use
\begin{verbatim}
void * GMT_Read_Data (void *API, unsigned int family, \
    unsigned int method, unsigned int geometry, unsigned int mode, \
    double wesn[], char *input, void *ptr);
\end{verbatim}
where \texttt{ptr} is NULL except when reading grids in two steps
(i.e., first get a grid structure with a header, then read the data).
Most of these arguments have been discussed earlier.  This function can
be called in three different situations:
\begin{enumerate}
\item If you have a single source (filename, stream pointer, etc.) you can call
\texttt{GMT\_Read\_Data} directly; there is no need to first register the source
with \texttt{GMT\_Register\_IO} or gather the sources with \texttt{GMT\_Init\_IO}.
However, if you did register a single source you can still pass it via an encoded
filename (see \texttt{GMT\_Encode\_ID}) or you can instead use \texttt{GMT\_Get\_Data}
using the integer ID directly (see next section).
\item If you want to specify \texttt{stdin} as source then use \texttt{input} as NULL.
\item If you already registered all desired sources with \texttt{GMT\_Init\_IO} then
you indicate this by passing \texttt{geometry} = 0.
\end{enumerate}
Space will be allocated to hold the results, if needed, and a pointer to the object is returned.
If there are errors we simply return NULL and report the error.
The \texttt{mode} parameter has different meanings for different data types.
\begin{description}
\item [CPT table]:  \texttt{mode} contains bit-flags that control how the CPT file's back-, fore-, and NaN-colors
should be initialized.  Select 0 to use the CPT file's back-, fore-, and NaN-colors, 2
to replace these with the \GMT\ default values, or 4 to replace them with the color table's
entries for highest and lowest value.
\item [Data table]:  \texttt{mode} is currently not used.
\item [Text table]:  \texttt{mode} is currently not used.
\item [GMT grid]:  Here, \texttt{mode} determines how we read the grid:
\index{GMT\_GRID\_ALL}
\index{GMT\_GRID\_HEADER\_ONLY}
\index{GMT\_GRID\_DATA\_ONLY}
\index{GMT\_GRID\_IS\_COMPLEX\_REAL}
\index{GMT\_GRID\_IS\_COMPLEX\_IMAG}
\index{GMT\_GRID\_ROW\_BY\_ROW}
\index{GMT\_GRID\_ROW\_BY\_ROW\_MANUAL}
To read the entire grid and its header, pass GMT\_GRID\_ALL.  However, if you
need to extract a sub-region you must first read the header by passing
GMT\_GRID\_HEADER\_ONLY, then examine the header structure range attributes and
to specify a subset via the array \texttt{wesn}, and finally call
\texttt{GMT\_Read\_Data} a second time, now with \texttt{mode} = GMT\_GRID\_DATA\_ONLY and passing your \texttt{wesn} array
and the grid structure returned from the first call as \texttt{ptr}.
In the event your data array should be allocated to hold both the real and imaginary parts of a
complex data set you must add either GMT\_GRID\_IS\_COMPLEX\_REAL or GMT\_GRID\_IS\_COMPLEX\_IMAG to \texttt{mode}
so as to allow for the extra memory needed and to stride the input values correctly.
If your grid is huge and you must read it row-by-row, set \texttt{mode} to
GMT\_GRID\_HEADER\_ONLY | GMT\_GRID\_ROW\_BY\_ROW.  You can then access the grid row-by-row
using \texttt{GMT\_Get\_Row}.  By default the rows will be automatically
processed in order.  To completely specify which row to be read, use GMT\_GRID\_ROW\_BY\_ROW\_MANUAL
instead.
\end{description}

\subsubsection{Import from a memory location}

If you are importing via variables or prefer to first register the source, then you
should use \texttt{GMT\_Get\_Data} instead.  This function requires fewer arguments since you simply
pass the unique ID number of the resource.  The function is described as follows:

\index{GMT\_Get\_Data}

\begin{verbatim}
void * GMT_Get_Data (void *API, int ID, unsigned int mode, void *ptr);
\end{verbatim}
The \texttt{ID} is the unique object ID you received when registering the resource,
\texttt{mode} controls some aspects of the import (see \texttt{GMT\_Read\_Data} above),
while \texttt{ptr} is NULL except when reading grids in two steps
(i.e., first get a grid structure with a header, then read the data).
Other arguments have been discussed earlier.  
Space will be allocated to hold the results, if needed, and a pointer to the object is returned.
If there are errors we simply return NULL and report the error.

\subsubsection{Retrieve an allocated result}

Finally, if you need to access the result that a GMT\ module wrote to a memory location,
then you must register an output destination with \texttt{GMT\_Register\_IO} first (passing \texttt{ptr} == NULL).
The GMT\ module will then allocate space to hold the output and let the API know where this memory resides.
You can then use \texttt{GMT\_Retrieve\_Data} to get a pointer to the container where the data set was stored.
This function requires fewer arguments since you simply
pass the unique ID number of the resource.  The function is described as follows:

\index{GMT\_Retrieve\_Data}

\begin{verbatim}
void * GMT_Retrieve_Data (void *API, int ID);
\end{verbatim}
The \texttt{ID} is the unique object ID you received when registering the NULL resource earlier,
Since this container has already been created, a pointer to the object is returned.
If there are errors we simply return NULL and report the error.

\subsection{Importing a data record}
\index{Importing a data record}
\index{Data!Import data record}
\index{Resources!Import data record}

If your program will read data table records one-by-one you must first
enable this input mechanism with \texttt{GMT\_Begin\_IO} and then read
the records in a loop using
\index{GMT\_Get\_Record}

\begin{verbatim}
void * GMT_Get_Record (void *API, unsigned int mode, int *nfields);
\end{verbatim}
where the returned value is either a pointer to a double array with the current row values
or to a character string with the current row, depending on \texttt{mode}.
In either case these pointers point to memory internal to \GMT\ and should be considered read-only.
When we reach end-of-file, encounter conversion problems, read header comments, or identify
segment headers we return a NULL pointer.
The \texttt{nfields} pointer will return the number of fields returned; pass NULL if your program
should ignore this information.

Normally (\texttt{mode} == GMT\_READ\_DOUBLE or 0), we return a pointer to the double array.
\index{GMT\_READ\_DOUBLE}
\index{GMT\_READ\_TEXT}
To read text records, supply instead \texttt{mode} == GMT\_READ\_TEXT (or 1) and we
instead return a pointer to the text record.
However, if you have input records that mixes organized floating-point columns with text
items you could pass \texttt{mode} == GMT\_READ\_MIXED (2).  Then, \GMT\ will attempt to extract the
floating-point values; you can still access the record string, as discussed below.
Finally, if your application needs to be notified when \GMT\ closes one file and opens the next,
add GMT\_FILE\_BREAK to \texttt{mode} and check for the status code GMT\_IO\_NEXT\_FILE (by
default, we treat the concatenation of many input files as a single virtual file).
Using \texttt{GMT\_Get\_Record} requires you to first initialize the source(s)
with \texttt{GMT\_Init\_IO}.
For certain records, \texttt{GMT\_Get\_Record} will return NULL and sets status codes that your
program will need to examine to take appropriate response.  Table~\ref{tbl:iostatus}
list the various status codes you can check for, using \texttt{GMT\_Status\_IO} (see next section).

\subsection{Examining record status}
\index{Examining record status}
\index{Data!Record status}
\index{Resources!Examining record status}

Programs that read record-by-record must be aware of what the current record represents.
Given the presence of headers, data gaps, NaN-record, etc. the developer will want to
check the status after reading the next record.  The internal i/o status mode can be
interrogated with the function

\begin{verbatim}
int GMT_Status_IO (void *API, unsigned int mode);
\end{verbatim}

which returns 0 (false) or 1 (true) if the current status is reflected by the specified \texttt{mode}.
There are 11 different modes available to programmers; for a list see Table~\ref{tbl:iostatus}.
For an example of how these may be used, see the test program \filename{testgmtio.c}.
Developers who plan to import data on a record-by-record basis may also consult the source
code of, say, \filename{blockmean.c} or \filename{pstext.c}, to see examples of working code.

\begin{table}[h]
\small
\centering
\begin{tabular}{|l|l|} \hline
\multicolumn{1}{|c|}{\emph{mode}} & \multicolumn{1}{c|}{\emph{description}} \\ \hline
\texttt{GMT\_IO\_DATA\_RECORD}	&       1 if we read a data record \\ \hline
\texttt{GMT\_IO\_TABLE\_HEADER}	&       1 if we read a table header \\ \hline
\texttt{GMT\_IO\_SEGMENT\_HEADER}	&       1 if we read a segment header \\ \hline
\texttt{GMT\_IO\_ANY\_HEADER}	&       1 if we read either header record \\ \hline
\texttt{GMT\_IO\_MISMATCH}	&       1 if we read incorrect number of columns \\ \hline
\texttt{GMT\_IO\_EOF}		&       1 if we reached the end of the file (EOF) \\ \hline
\texttt{GMT\_IO\_NAN}		&       1 if we only read NaNs \\ \hline
\texttt{GMT\_IO\_GAP}		&       1 if this record implies a data gap \\ \hline
\texttt{GMT\_IO\_NEW\_SEGMENT}	&       1 if we enter a new segment \\ \hline
\texttt{GMT\_IO\_LINE\_BREAK}	&       1 if we encountered a segment header, EOF, NaNs or gap \\ \hline
\texttt{GMT\_IO\_NEXT\_FILE}	&       1 if we finished one file but not the last \\ \hline
\end{tabular}
\caption{Modes used to determine status of current data record.  The \texttt{GMT\_IO\_GAP} mode depends
on the current \Opt{g} settings.  The function returns false (0) unless the status is true (1).}
\label{tbl:iostatus}
\index{Record!Status}
\end{table}
\index{GMT\_IO\_DATA\_RECORD}
\index{GMT\_IO\_TABLE\_HEADER}
\index{GMT\_IO\_SEGMENT\_HEADER}
\index{GMT\_IO\_ANY\_HEADER}
\index{GMT\_IO\_MISMATCH}
\index{GMT\_IO\_EOF}
\index{GMT\_IO\_NAN}
\index{GMT\_IO\_GAP}
\index{GMT\_IO\_NEW\_SEGMENT}
\index{GMT\_IO\_LINE\_BREAK}
\index{GMT\_IO\_NEXT\_FILE}

\subsection{Importing a grid row}
\index{Importing a grid row}
\index{Data!Import grid row}
\index{Resources!Import grid row}

If your program must read a grid file row-by-row you must first enable row-by-row
reading with \texttt{GMT\_Read\_Data} and then use the \texttt{GMT\_Get\_Row} function in a loop;
the prototype is
\index{GMT\_Get\_Row}

\begin{verbatim}
int GMT_Get_Row (void *API, int row_no, struct GMT_GRID *G, float *row);
\end{verbatim}
where \texttt{row} is a pointer to a single-precision array to receive the current row,
\texttt{G} is the grid in question, and \texttt{row\_no} is the number of the current
row to be read.  Note this value is only considered if the row-by-row mode was
initialized with GMT\_GRID\_ROW\_BY\_ROW\_MANUAL.  The user must allocate enough
space to hold the entire row in memory. 

\subsection{Disable Data Import}
\index{Import!Disable}
\index{Data!Import}
\index{Resources!Import data}

Once the record-by-record input processing has completed we disable further input to prevent accidental
reading from occurring (due to poor program structure, bugs, etc.).  We do so by calling \texttt{GMT\_End\_IO}.  This
function disables further record-by-record data import; its prototype is

\begin{verbatim}
int GMT_End_IO (void *API, unsigned int direction, unsigned int mode);
\end{verbatim}

\noindent
and we specify \texttt{direction} = GMT\_IN.  At the moment, \texttt{mode} is not used.  This call
will also reallocate any arrays obtained into their proper lengths.
The function returns TRUE (1) if there is an error (which is passed back with \texttt{API->error}),
otherwise it returns FALSE (0).

\section{Manipulate data}
\index{Data!Manipulate}
\label{sec:manipulate}

Once you have created and allocated and empty resources, or read in resources from the outside, you
will wish to manipulate their contents.  This section discusses how to set up loops and access
the important variables for the various data families.

\subsection{Manipulate grids}
\index{Grids!Manipulate}

Most applications wishing to manipulate grids will want to loop over all the nodes, typically
in a manner organized by rows and columns.  In doing so, the coordinates at each node may also
be required for a calculation.  Below is a snippet of code that shows how to do
visit all nodes in a grid and assign each node the product x * y:

\begin{verbatim}
int row, col, node;
double *x_coord = NULL, *y_coord = NULL;
< ... create a grid G or read one ... >
x_coord = GMT_Get_Coord (API, GMT_IS_GRID, GMT_X, G);
y_coord = GMT_Get_Coord (API, GMT_IS_GRID, GMT_Y, G);
for (row = 0; row < G->header->ny) {
    for (col = 0; col < G->header->nx; col++) {
        node = GMT_Get_Index (G->header, row, col);
        G->data[node] = x_coord[col] * y_coord[row];
    }
}
\end{verbatim}

Note the use of \texttt{GMT\_Get\_Index} to get the grid node number associated
with the \texttt{row} and \texttt{col} we are visiting.  Because \GMT\ grids have
padding (for boundary conditions) the relationship between rows, columns, and
node indices is more complicated and hence we hide that complexity in \texttt{GMT\_Get\_Index}.
Note that for trivial procedures such setting all grid nodes to a constant (e.g., -9999.0)
where the row and column does not enter you can instead do a single loop:

\begin{verbatim}
int node;
< ... create a grid G or read one ... >
for (node = 0; node < G->header->size) G->data[node] = -9999.0;
\end{verbatim}

Note we must use \texttt{G->header->size} (size of allocated array) and not
\texttt{G->header->nm} (number of nodes in grid) since the latter is smaller
due to the padding and a single loop like the above treats the pad as part of
the ``inside'' grid.

\subsection{Manipulate data tables}
\index{Data tables!Manipulate}

Another common application is to process the records in a data table.
Because \GMT\ consider the GMT\_DATASET resources to contain one or
more tables, each of which may contain one or more segments, all of
which may contain one or more columns, you will need to have multiple
loops to visit all entries.  The following code snippet will visit
all data records and add 1 to all columns beyond the first two (x and y):

\begin{verbatim}
int tbl, seg, row, col;
struct GMT_DATATABLE *T = NULL;
struct GMT_DATASEGMENT *S = NULL;

< ... create a dataset D or read one ... >
for (tbl = 0; tbl < D->n_tables; tbl++) {	/* For each table */
  T = D->table[tbl];       /* Convenient shorthand for current table */
  for (seg = 0; seg < T->n_segments; seg++) {	/* For all segments */
    S = T->segment[seg];   /* Convenient shorthand for current segment */
    for (row = 0; row < S->n_rows; row++) {
      for (col = 2; col < T->n_columns; col++) {
        S->coord[col][row] += 1.0;
      }
    }
  }
}
\end{verbatim}

\subsection{Manipulate text tables}
\index{Text tables!Manipulate}

When data file contain text mixed in with numbers you must open the
file as a GMT\_TEXTSET and do your own parsing of the data records.
The following code snippet will visit all text records and print
them out:

\begin{verbatim}
int tbl, seg, row, col;
struct GMT_TEXTTABLE *T = NULL;
struct GMT_TEXTSEGMENT *S = NULL;

< ... create a textset D or read one ... >
for (tbl = 0; tbl < D->n_tables; tbl++) {	/* For each table */
  T = D->table[tbl];        /* Convenient shorthand for current table */
  for (seg = 0; seg < T->n_segments; seg++) {	/* For all segments */
    S = T->segment[seg];    /* Convenient shorthand for current segment */
    for (row = 0; row < S->n_rows; row++) {
      printf ("T=%d S=%d R=%d : %s\n", tbl, seg, row, S->record[row]);
    }
  }
}
\end{verbatim}

\section{Message and Verbose Reporting}
\index{Messages}
\index{Verbose Reporting}
\label{sec:messages}

The API provides two functions for your program to present information to the user
during the run of the program.  One is used for messages that are always written
while the other is used for reports that must exceed the verbosity settings
specified via \Opt{V}.

\begin{verbatim}
int GMT_Report (void *API, unsigned int level, char *message, ...);
\end{verbatim}
This function takes a verbosity level and a multi-part message (e.g., a format statement
and zero or more variables).  The verbosity \texttt{level} is an integer in the 0--5
range; these are listed in Table~\ref{tbl:verbosity}.  You assign an appropriate
verbosity level to your message, and depending on the chosen run-time verbosity level
set via \Opt{V} your message may or may not be reported.  Only messages whose stated
verbosity level is lower or equal to the \Opt{V}{\it level} will be printed.
\begin{table}[h]
\small
\centering
\begin{tabular}{|l|c|l|} \hline
\multicolumn{1}{|c|}{\emph{constant}} & \multicolumn{1}{c|}{\emph{value}}  & \multicolumn{1}{c|}{\emph{Description}} \\ \hline
GMT\_MSG\_QUIET		&      0	& No messages whatsoever \\ \hline
GMT\_MSG\_NORMAL	&      1	& Default output, e.g., warnings and errors only \\ \hline
GMT\_MSG\_COMPAT	&      2	& Compatibility warnings \\ \hline
GMT\_MSG\_VERBOSE	&      3	& Verbose level \\ \hline
GMT\_MSG\_LONG\_VERBOSE	&      4	& Longer verbose \\ \hline
GMT\_MSG\_DEBUG		&      5	& Debug messages for developers mostly \\ \hline
\end{tabular}
\caption{Enumeration constants defined for time message formatting.  The last two may be
combined to reset the elapsed time and display it.  The GMT\_TIME\_CLOCK formatting is
controlled by the \GMT\ defaults {\bf FORMAT\_TIME\_STAMP}.}
\label{tbl:verbosity}
\index{Verbosity levels}
\end{table}

\begin{verbatim}
int GMT_Message (void *API, unsigned int mode, char *format, ...);
\end{verbatim}
This function always prints its message to the standard output.  Use the \texttt{mode} value
to control if a time stamp should preface the message. and if selected how the time information should be formatted.
See Table~\ref{tbl:timemodes} for the various modes.

\begin{table}[h]
\small
\centering
\begin{tabular}{|l|l|l|} \hline
\multicolumn{1}{|c|}{\emph{constant}} & \multicolumn{1}{c|}{\emph{value}}  & \multicolumn{1}{c|}{\emph{Description}} \\ \hline
GMT\_TIME\_NONE		&      0	& Display no time information \\ \hline
GMT\_TIME\_CLOCK	&      1	& Display current local time \\ \hline
GMT\_TIME\_ELAPSED	&      2	& Display elapsed time since last reset \\ \hline
GMT\_TIME\_RESET	&      3	& Reset the elapsed time to 0 \\ \hline
\end{tabular}
\caption{Enumeration constants defined for time message formatting.  The last two may be
combined to reset the elapsed time and display it.  The GMT\_TIME\_CLOCK formatting is
controlled by the \GMT\ defaults {\bf FORMAT\_TIME\_STAMP}.}
\label{tbl:timemodes}
\index{Time formatting}
\end{table}


\section{Presenting and accessing GMT options}
\index{GMT options!Presenting and Accessing}
\label{sec:parsopt}
As you develop a program you may need to rely on some of the \GMT\ common options.
For instance, you may wish to have your program present the \Opt{R} option to the user, let \GMT\
handle the parsing, and examine the values.  You may also wish to encode your own custom options
that may require you to parse user text into the corresponding floating point dimensions, length, coordinates, time, etc. The API
provides several functions to simplify these tedious parsing tasks.  This section is
intended to show how the programmer will obtain information from the user that is necessary
to do the task at hand (e.g., special options to provide values and settings for the program).
In the following section we will concern ourselves with preparing arguments for calling
any of the \GMT\ modules.

\subsection{Display usage syntax for GMT common options}

You can have your program menu display the standard usage message for a \GMT\ common option
by calling the function

\begin{verbatim}
void GMT_Option (void *API, char *options);
\end{verbatim}
where \texttt{options} is a comma-separated list of \GMT\ common options (e.g., ``R,J,O,X'').
You can repeat this function with different sets of options in order to intersperse your
own custom options with \textttt{GMT\_Message} in an overall alphabetical order; see any
\GMT\ module for examples of typical layouts.

\subsection{Parsing the GMT common options}

The parsing of all \GMT\ common option is done by 

\index{GMT\_Parse\_Common}

\begin{verbatim}
int GMT_Parse_Common (void *API, char *args, struct GMT_OPTION *list);
\end{verbatim}
where \texttt{args} is a string of the common \GMT\ options your program may use.
An error will be reported if any of the common \GMT\ options fail to parse,
and if so we return TRUE; if not errors we return FALSE.  All other options,
including file names, will be silently ignored.  The parsing will update the internal \GMT\
information structure that affects program operations.

\subsection{Inquiring about the GMT common options}

The API provide only a limited window into the full \GMT\ machinery accessible to the modules.
You can determine if a particular common option has been parsed and in some cases determine the
values that was set with

\begin{verbatim}
int GMT_Get_Common (void *API, unsigned int option, double *par);
\end{verbatim}
where \texttt{option} is a single option character (e.g., `R') and
\texttt{par} is a double array with at least a length of 6.  If the
particular option has been parsed then the function returns the number
of parameters passed back via \texttt{par}; otherwise we return -1.
For instance, to determine if the \Opt{R} was set and what the resulting
region was set to you may call

\begin{verbatim}
if (GMT_Get_Common (API, 'R', wesn)) != -1) {
	/* wesn now contains the boundary information */
}
\end{verbatim}
The \texttt{wesn} array could now be passed to the various read and create functions
for \GMT\ resources.

\subsection{Parsing text values}

Your program may need to request values from the user, such as distances,
plot dimensions, coordinates, and other data.  The conversion from such text
to actual distances, taking units into account, is tedious to program.  You
can simplify this by using

\begin{verbatim}
int GMT_Get_Value (void *API, char *arg, double par[]);
\end{verbatim}
where \texttt{arg} is the text item with one or more values that are
separated by commas, space, or slashes, and \texttt{par} is an array
long enough to hold all the items you are parsing.  The function returns
the number of items parsed, or -1 if there is an error.  For instance,
assume the character string \texttt{origin} was given by the user as
two geographic coordinates separated by a slash (e.g., \texttt{"35:45W/19:30:55.3S"}).
We obtain the two coordinates as decimal degrees by calling

\begin{verbatim}
n = GMT_Get_Value (API, origin, pair);
\end{verbatim}
Your program can now check that \texttt{n} equals 2 and then use the values
in \texttt{pairs}.   Note: Dimensions given with units of inches, cm, or points are converted to the
\GMT\ default length unit ({\bf GMT\_PROJ\_LENGTH}) [cm], while distances
given in km, nautical miles, miles, feet, or survey feet are returned in meters.
Arc lengths in minutes and seconds are returned in decimal degrees, and
date/time values are returned in seconds since the epoch (1970).

\subsection{Inquiring about a GMT default parameter}

If your program needs to determine one or more of the current \GMT\ default settings
you can do so via

\begin{verbatim}
int GMT_Get_Default (void *API, char *keyword, char *value);
\end{verbatim}
where \texttt{keyword} is one such keyword (e.g., {\bf GMT\_PROJ\_LENGTH}) and
\texttt{value} must be a character array long enough to hold the answer.
Depending on what parameter you selected you could further convert it to a numerical value
with \texttt{GMT\_Get\_Value} or just use it in a text comparison.


\section{Prepare module options}
\index{Module options!Prepare}
\label{sec:func}
One of the advantages of programming with the API is that you have access to the high-level
\GMT\ modules.  For example, if your program must compute the distance from a point to all other
points on the node you can simply set up options and call \texttt{GMT\_grdmath} to do it for
you and accept the result back as an input grid. All the module interfaces are identical are looks like

\begin{verbatim}
int GMT_module (void *API, int mode, void *args);
\end{verbatim}
All GMT modules may be called with one of three sets of \texttt{args} depending on \texttt{mode}.
The three modes differ in how the options are passed to the module:
\begin{description}
\item [$mode > 0$]: Expects \texttt{args} to be an array of text options and \texttt{mode} to be a count of
how many options are passed (i.e., the \texttt{argc, argv[]} model used by the \GMT\ programs themselves).
\item [$mode < 0$]: Expects \texttt{args} to be a pointer to a doubly-linked list of objects with individual options
for the current program.  We will see how API functions can help prepare such lists.
\item [$mode == 0$]: Expects \texttt{args} to be a single text string with all required options.
\end{description}
Here, \texttt{GMT\_module} stands for any of the \GMT\ modules, such as \texttt{GMT\_psxy} or \texttt{GMT\_grdvolume}.
All modules returns FALSE (0) if they completed successfully; otherwise they produce error messages and return an error code
back to the calling environment.

\subsection{Set program options via text array arguments}
\index{Set program options via text array arguments}
\index{Program options!Text array arguments}

When \texttt{mode} $> 0$ we expect an array \texttt{args} of character strings that each
holds a single command line options (e.g., ``-R120:30/134:45/8S/3N'') and interpret \texttt{mode}
to be the count of how many options are passed.  This, of course, is almost exactly how the stand-alone \GMT\
programs are called (and reflects how they themselves are activated internally).  We call this the ``argc--argv'' mode.
Depending on how your program obtains the necessary options you may find that this interface offers all you need.

\subsection{Set program options via text command}
\index{Set program options via text command}
\index{Program options!Text command argument}

If \texttt{mode} == 0 then \texttt{args} will be examined to see if it contains several options within a single command string.
If so we will break these into separate options.  This is useful if you wish to pass a single string such as
``-R120:30/134:45/8S/3N -JM6i mydata.txt -Sc0.2c''.  We call this the ``command'' mode.

\subsection{Set program options via linked structures}
\index{Set program options via linked structures}
\index{Program options!Linked structures}

The third, linked-list interface allows developers using higher-level programming languages to pass all command
options via a pointer to a NULL-terminated, doubly-linked list of option structures, each containing
information about a single option.  Here, instead of text arguments we pass the pointer to the linked list of
options mentioned above, and \texttt{mode} must be passed as -1 (or any negative value).  Using
this interface can be more involved since you need to generate the linked
list of program options; however, utility functions exist to simplify its use.
This interface is intended for programs whose internal workings are better suited to
generate such arguments -- we call this the ``options'' mode.  The order in the list is not important as \GMT\ will sort it internally
according to need.  The option structure is defined in Table \ref{tbl:options}.
\begin{table}[h]
\small
\centering
\begin{tabular}{ll} \hline
\verb!struct GMT_OPTION {!        & \\
\verb!  char option;!             & /* \emph{Single character of the option (e.g.,'G' for} \Opt{G} */ \\
\verb!  char *arg;!               & /* \emph{String pointer with arguments (NULL if not used)} */ \\
\verb!  struct GMT_OPTION *next;! & /* \emph{Pointer to next option (NULL for last option)} */\\
\verb!  struct GMT_OPTION *prev;! & /* \emph{Pointer to previous option (NULL for first option)} */\\
\verb!};!                         & \\
\hline
\end{tabular}
\caption{Definition of the structure used to hold a single program option.}
\label{tbl:options}
\index{Option!Structure}
\end{table}

\subsection{Convert between text and linked structures}
\index{Convert between text and linked structures}
\index{Linked structures!Convert to text}
\index{Text options!Convert to linked structures}

To assist programmers there are also two convenience functions that
allow you to convert between the two argument formats.  They are

\begin{verbatim}
struct GMT_OPTIONS * GMT_Create_Options (void *API, int argc, void *args);
\end{verbatim}
\index{GMT\_Create\_Options}
This function accepts your array of text arguments (cast via a void pointer), allocates the necessary
space, performs the conversion, and returns a pointer to the
head of the linked list of program options.  However, in case of an error
we return a NULL pointer and set \texttt{API->error} to indicate the nature of the problem.
Otherwise, the pointer may now be passed to the
relevant \texttt{GMT\_module}.  Note that if your list of text arguments
were obtained from a C \texttt{main()} function then \texttt{argv[0]} will
contain the name of the calling program.  To avoid passing this as a file
name option, call \texttt{GMT\_Create\_Options} with \texttt{argc-1}
and \texttt{argv+1}.  If you wish to pass a single text string with
multiple options (in lieu of an array of text strings), then pass \texttt{arg} = 0.
When no longer needed you can remove the entire list by calling
\begin{verbatim}
int GMT_Destroy_Options (void *API, struct GMT_OPTION **list);
\end{verbatim}
\index{GMT\_Destroy\_Options}
The function returns TRUE (1) if there is an error (which is passed back with \texttt{API->error}),
otherwise it returns FALSE (0).

The inverse function prototype is
\begin{verbatim}
char ** GMT_Create_Args (void *API, int *argc, struct GMT_OPTIONS *list);
\end{verbatim}
\index{GMT\_Create\_Args}
which allocates space for the text strings and performs the conversion;
it passes back the count of the arguments via \texttt{argc} and returns a pointer to the text array.
In the case of an error we return a NULL pointer and set \texttt{API->error} to reflect the error type.
Note that \texttt{argv[0]} will not contain the name of the program as
is the case the arguments presented by a C \texttt{main()} function.
When you no longer have any use for the text array, call
\begin{verbatim}
int GMT_Destroy_Args (void *API, int argc, char *argv[]);
\end{verbatim}
\index{GMT\_Destroy\_Args}
to deallocate the space used.  This function returns TRUE (1) if there is an error
(which is passed back with \texttt{API->error}),
otherwise it returns FALSE (0).

Finally, to convert the linked list of option structures to a single
text string command, use
\begin{verbatim}
char * GMT_Create_Cmd (void *API, struct GMT_OPTION *list);
\end{verbatim}
\index{GMT\_Create\_Cmd}
Developers who plan to import and export \GMT\ shell scripts might find it
convenient to use these functions.  In case of an error we return a NULL pointer
and set \texttt{API->error}, otherwise a pointer to an allocated string is returned.
It 

\subsection{Manage the linked list of options}
\index{Manage the linked list of options}
\index{Option!Manage}
\index{Linked options!Manage}

Several additional utility functions are available for programmers who wish to manipulate
program option structures within their own programs.  These allow you to create new
option structures, append them to the linked list, replace existing options with new
values, find a particular option, and remove options from the list.  Note: The
order in which the options appear in the linked list is of no consequence to \GMT.
Internally, \GMT\ will sort and process the options in the manner required.
Externally, you are free to maintain your own order.

\subsubsection{Make a new option structure}
\index{Make a new option structure}
\index{Option!Make}

\texttt{GMT\_Make\_Option} will allocate a new option structure, assign it values
given the \texttt{option} and \texttt{arg} parameter (pass NULL if there is no
argument for this option), and returns a pointer
to the allocated structure.  The prototype is
\index{GMT\_Make\_Option}

\begin{verbatim}
struct GMT_OPTION *GMT_Make_Option (void *API, char option, char *arg);
\end{verbatim}
Should memory allocation fail the function will print an error message
set an error code via \texttt{API->error}, and return NULL.

\subsubsection{Append an option to the linked list}
\index{Append an option to the linked list}
\index{Option!Append}

\texttt{GMT\_Append\_Option} will append the specified \texttt{option} to the end
of the doubly-linked \texttt{list}.  The prototype is
\index{GMT\_Append\_Option}

\begin{verbatim}
struct GMT_OPTION * GMT_Append_Option (void *API, \
    struct GMT_OPTION *option, struct GMT_OPTION *list);
\end{verbatim}
We return the list back, and if \texttt{list} is given as NULL we return \texttt{option} as the start of the new list.
Any errors results in a NULL pointer with \texttt{API->error} holding the error type.

\subsubsection{Find an option in the linked list}
\index{Find an option in the linked list}
\index{Option!Find}

\texttt{GMT\_Find\_Option} will return a pointer \texttt{ptr} to the first option in the linked list starting
at \texttt{list} whose option character equals \texttt{option}.  If not found we return NULL.  While this is
not necessarily an error we still set \texttt{API->error} accordingly.
The prototype is
\index{GMT\_Find\_Option}

\begin{verbatim}
struct GMT_OPTION *GMT_Find_Option (void *API, \
    char option, struct GMT_OPTION *list);
\end{verbatim}
If you need to look for multiple occurrences of a certain option you will need to
call \texttt{GMT\_Find\_Option} again, passing the option following the
previously found option as the \texttt{list} entry, i.e.,

\begin{verbatim}
list = *ptr->next;
\end{verbatim}

\subsubsection{Update an existing option in the list}
\index{Update an existing option in the list}
\index{Option!Update}

\texttt{GMT\_Update\_Option} will first determine if \texttt{option} exists;
if so it will delete it. Then, it will make a new option from the arguments
and append it to the end of the linked \texttt{list}.  The prototype is
\index{GMT\_Update\_Option}

\begin{verbatim}
int GMT_Update_Option (void *API, char option, \
    char *arg, struct GMT_OPTION *list);
\end{verbatim}
An error will be reported if (a) \texttt{list} is NULL or (b) the option is not found.
The function returns TRUE (1) if there is an error (i.e., \texttt{list} is NULL or the
option is not found); the error code is passed back via \texttt{API->error}.
Otherwise it returns FALSE (0).

\subsubsection{Delete an existing option in the linked list}
\index{Delete an existing option in the linked list}
\index{Option!Delete}

You may use \texttt{GMT\_Delete\_Option} to remove \texttt{option} from
the linked \texttt{list}.  The prototype is
\index{GMT\_Delete\_Option}

\begin{verbatim}
int GMT_Delete_Option (void *API, struct GMT_OPTION *current);
\end{verbatim}
We return TRUE if the option is not found in the list and set \texttt{API->error} accordingly.
Note: Only the first occurrence of the specified option will be deleted.  If you need to delete all such
options you will need to call this function in a loop until it returns a non-zero
status.

\subsubsection{Specify a file via an linked option}
\index{Specify a file via an linked option}
\index{Option!Files}

To specify an input file name via an option, simply use $<$ as the option (this is what
\texttt{GMT\_Create\_Options} does when it finds filenames on the command line).
Likewise, $>$ can be used to explicitly indicate an output file.  In order to append to
an existing file, use $>>$.  For example the following command would read from file.A
and append to file.B:

\begin{verbatim}
gmtconvert -<file.A ->>file.B
\end{verbatim}

These options also work on the command line but usually one would have to escape the
special characters $<$ and $>$ as they are used for file redirection.

\section{Calling a GMT module}
\index{Calling a GMT module}

Given your linked list of program options (or text array) and possibly some registered resources, you
can now call the required \GMT\ module using one of the two flavors discussed in section {\ref{sec:func}}.
All modules return an error or status code that your program should consider before processing the results.

\section{Adjusting headers and comments}
\index{Adjusting headers and comments}
\index{Headers}
\index{Comments}

All header records in incoming datasets are stored in memory.  You may wish to replace these records with
new information, or append new information to the existing headers.  This is achieved with

\index{GMT\_Set\_Comment}

\begin{verbatim}
int GMT_Set_Comment (void *API, unsigned int family, unsigned int mode \
    void *arg, void *data)
\end{verbatim}
Again, \texttt{family} selects which kind of resource is passed via \texttt{data}. The \texttt{mode}
determines what kind of comment is being considered, how it should be included, and in what form the comment
passed via \texttt{arg} is.  Table~\ref{tbl:comments} lists the available options, which may be combined
by adding (bitwise ``or'').  The \texttt{GMT\_Set\_Comment} does not actually output anything but sets the
relevant comment and header records in the relevant structure.  When a file is written out the information
will be output as well (Note: Users can always decide if they wish to turn header output on or off via the
common \GMT\ option \Opt{h}.  For record-by-record writing you must enable the header block output when
you call \texttt{GMT\_Begin\_IO}.
\index{GMT\_Begin\_IO}

\begin{table}[h]
\small
\centering
\begin{tabular}{|l|l|l|} \hline
\multicolumn{1}{|c|}{\emph{constant}} & \multicolumn{1}{c|}{\emph{value}}  & \multicolumn{1}{c|}{\emph{Description}} \\ \hline
GMT\_COMMENT\_IS\_TEXT		&      0	& Comment is a text string \\ \hline
GMT\_COMMENT\_IS\_OPTION	&      1	& Comment is a linked list of GMT\_OPTION structures \\ \hline
GMT\_COMMENT\_IS\_COMMAND	&      2	& Comment is the command \\ \hline
GMT\_COMMENT\_IS\_REMARK	&      4	& Comment is the remark \\ \hline
GMT\_COMMENT\_IS\_TITLE		&      4	& Comment is the title \\ \hline
GMT\_COMMENT\_IS\_NAME\_X	&      4	& Comment is the x variable name (grids only) \\ \hline
GMT\_COMMENT\_IS\_NAME\_Y	&      4	& Comment is the y variable name (grids only) \\ \hline
GMT\_COMMENT\_IS\_NAME\_Z	&      4	& Comment is the z variable name (grids only) \\ \hline
GMT\_COMMENT\_IS\_COLNAMES	&      4	& Comment is the column names header \\ \hline
GMT\_COMMENT\_IS\_RESET		&      8	& Comment replaces existing information \\ \hline
\end{tabular}
\caption{Enumeration constants as bit-flags defined for specifying different types of comments.}
\label{tbl:comments}
\index{Resources!Comments!types}
\end{table}
\index{GMT\_COMMENT\_IS\_TEXT}
\index{GMT\_COMMENT\_IS\_OPTION}
\index{GMT\_COMMENT\_IS\_COMMAND}
\index{GMT\_COMMENT\_IS\_REMARK}
\index{GMT\_COMMENT\_IS\_RESET}
The named modes (\emph{command}, \emph{remark}, \emph{title}, \emph{name\_x,y,z} and \emph{colnames} are used
to distinguish regular text comments from specific fields in the
header structures of the data resources, such as \texttt{GMT\_GRID}.  For the various table resources (e.g., \texttt{GMT\_DATASET})
these modifiers result in a specially formatted comments beginning with ``Command: '' or ``Remark: '', reflecting how this
type of information is encoded in the headers.

\section{Exporting Data}
\index{Exporting Data}
\index{Data!Export data}
\index{Resources!Export data}

If your program needs to write any of the four recognized data types (CPT files, data tables, text tables, or \GMT\ grids)
you can use the \texttt{GMT\_Put\_Data}. In the case of data and text tables, you may also consider the
\texttt{GMT\_Put\_Record} function.
As a general rule, your program organization may simplify if you can write the export the entire resource with
\texttt{GMT\_Put\_Data}.  However, if the program logic is simple or already involves using \texttt{GMT\_Get\_Record},
it may be better to export one data record at the time via \texttt{GMT\_Put\_Record}.


Both of these output functions takes a parameter called \texttt{mode}.  The \texttt{mode} parameter generally
takes on different meanings for the different data types and will be discussed below.
However, one bit setting is common to all types: By default, you are only allowed to write a
data resource once; the resource is then flagged to have been written and subsequent attempts to write
to the same resource will quietly be ignored.  In the unlikely event you need to re-write a
resource you can override this default behavior by adding GMT\_IO\_RESET to your \texttt{mode} parameter.

\subsection{Enable Data Export}
\index{Export!Enable}
\index{Data!Export}
\index{Resources!Export data}

Similar to the data import procedures, once all output destinations have been registered, we signal the API that we are done with the registration
phase and are ready to start the actual data export.  As for input, this step is only needed when dealing with record-by-record writing.
Again, we enable record-by-record writing by calling \texttt{GMT\_Begin\_IO}, this time with \texttt{direction} = GMT\_OUT.
This function enables data export and prepares the registered destinations for the upcoming writing.  


\subsection{Exporting a data set}
\index{Exporting a data set}
\index{Data!Export data set}
\index{Resources!Export data set}

To have your program accept results from \GMT\ modules and write them
separately requires you to use the \texttt{GMT\_Write\_Data} or \texttt{GMT\_Put\_Data} functions.  They are
very similar to the \texttt{GMT\_Read\_Data} and \texttt{GMT\_Get\_Data} functions encountered earlier.

\subsubsection{Exporting a data set to a file, stream, or handle}
\index{GMT\_Write\_Data}
The prototype for writing to a file (via name, stream, or file handle) is

\begin{verbatim}
int GMT_Write_Data (void *API, unsigned int family, \
    unsigned int method, unsigned int geometry, unsigned int mode, \
    double wesn[], void *output, void *data);
\end{verbatim}
where \texttt{data} is a pointer to any of the four structures
discussed previously.  Again, the \texttt{mode} parameter is specific to
each data type:

\begin{description}
\item [CPT table]: \texttt{mode} controls if the CPT table's back-, fore-, and NaN-colors
should be written (1) or not (0).
\item [Data table]: If \texttt{method} is GMT\_IS\_FILE, then the value of
\texttt{mode} affects how the data set is written:
\begin{description}
\item [GMT\_WRITE\_SET]: The entire data set will be written to the single file [0].
\index{GMT\_WRITE\_SET}
\item [GMT\_WRITE\_TABLE]: Each table in the data set is written to individual files [1].
You can either specify an output file name that \emph{must} contain one C-style
format specifier for a int variable (e.g., ``New\_Table\_\%06d.txt''), which will be
replaced with the table number (a running number from 0) \emph{or} you must assign
to each table \emph{i} a unique output file name via the \texttt{D->table[i]->file[GMT\_OUT]}
variables prior to calling the function.
\index{GMT\_WRITE\_TABLE}
\item [GMT\_WRITE\_SEGMENT]: Each segment in the data set is written to an individual file [2].
Same setup as for GMT\_WRITE\_TABLE except we use sequential segment numbers to build the file names.
\index{GMT\_WRITE\_SEGMENT}
\item [GMT\_WRITE\_TABLE\_SEGMENT]: Each segment in the data set is written to an individual file [3].
You can either specify an output file name that \emph{must} contain two C-style
format specifiers for two int variables (e.g., ``New\_Table\_\%06d\_Segment\_\%03d.txt''),
which will be replaced with the table and segment numbers, \emph{or}
you must assign to each segment \emph{j} in each table \emph{i} a unique output file name
via the \texttt{D->table[i]->segment[j]->file[GMT\_OUT]} variables prior to calling the function.
\index{GMT\_WRITE\_TABLE\_SEGMENT}
\index{GMT\_WRITE\_OGR}
\item [GMT\_WRITE\_OGR]: Writes the dataset in OGR/GMT format in conjunction with the \Opt{a} setting [4].
\end{description}
\item [Text table]: The \texttt{mode} is used the same way as for data tables.
\item [GMT grid]: Here, \texttt{mode} may be GMT\_GRID\_HEADER\_ONLY to only update a file's header
structure, but normally it is simply GMT\_GRID\_ALL (0) so the entire
grid and its header will be exported (a subset is not allowed during export).
However, in the event your data array holds both the real and imaginary parts of a
complex data set you must add either GMT\_GRID\_IS\_COMPLEX\_REAL (4) or GMT\_GRID\_IS\_COMPLEX\_IMAG (16) to \texttt{mode}
so as to export the corresponding grid values correctly.  Finally, for native binary grids you may skip writing
the grid header by adding GMT\_GRID\_NO\_HEADER (16); this setting is ignored for other grid formats.
If your output grid is huge and you are building it row-by-row, set \texttt{mode} to
GMT\_GRID\_HEADER\_ONLY | GMT\_GRID\_ROW\_BY\_ROW.  You can then write the grid row-by-row
using \texttt{GMT\_Put\_Row}.  By default the rows will be automatically
processed in order.  To completely specify which row to be written, use GMT\_GRID\_ROW\_BY\_ROW\_MANUAL
instead.
\index{GMT\_GRID\_HEADER\_ONLY}
\index{GMT\_GRID\_ALL}
\index{GMT\_GRID\_IS\_COMPLEX\_REAL}
\index{GMT\_GRID\_IS\_COMPLEX\_IMAG}
\index{GMT\_GRID\_NO\_HEADER}
\index{GMT\_GRID\_ROW\_BY\_ROW}
\index{GMT\_GRID\_ROW\_BY\_ROW\_MANUAL}
\end{description}
If successful the function returns FALSE (0); otherwise we return TRUE (1) and set \texttt{API->error} to reflect to cause.

\subsubsection{Exporting a data set to memory}
\index{GMT\_Put\_Data}

If writing to a memory destination you will want to first register that destination and then use the returned ID with
\texttt{GMT\_Put\_Data} instead:

\begin{verbatim}
int GMT_Put_Data (void *API, int ID, unsigned int mode, void *data);
\end{verbatim}
where \texttt{ID} is the unique ID of the registered destination, \texttt{mode}
is specific to each data type (and controls aspects of the output structuring),
and \texttt{data} is a pointer to any of the four structures
discussed previously.  For more detail, see \texttt{GMT\_Write\_Data} above.
If successful the function returns FALSE (0); otherwise we return TRUE (1) and set \texttt{API->error} to reflect to cause.


\subsection{Exporting a data record}
\index{Exporting a data record}
\index{Data!Export data record}
\index{Resources!Export data record}

If your program must write data table records one-by-one you must first enable record-by-record
writing with \texttt{GMT\_Begin\_IO} and then use the \texttt{GMT\_Put\_Record} function in a loop;
the prototype is
\index{GMT\_Put\_Record}

\begin{verbatim}
int GMT_Put_Record (void *API, unsigned int mode, void *rec);
\end{verbatim}
where \texttt{rec} is a pointer to either (a) a double-precision array with the current row.
Then, \texttt{rec} is expected to hold at least as many items as the current setting of
\texttt{n\_col[GMT\_OUT]}, which represents the number of columns in the output destination.
Alternatively (b), \texttt{rec} points to a text string.
The \texttt{mode} parameter must be set to reflect what is passed.  Using \texttt{GMT\_Put\_Record}
requires you to first initialize the destination with \texttt{GMT\_Init\_IO}.
Note that for families GMT\_IS\_DATASET and GMT\_IS\_TEXTSET the methods GMT\_IS\_DUPLICATE and GMT\_IS\_REFERENCE are not supported since
you can simply populate the GMT\_DATASET structure directly.
As mentioned, \texttt{mode} affects what is actually written:
\begin{description}
\item [GMT\_WRITE\_DOUBLE]: Normal operation that builds the current output record from
the values in \texttt{rec} [0].
\index{GMT\_WRITE\_DOUBLE}
\item [GMT\_WRITE\_TEXT]: For ASCII output mode we write the text string \texttt{rec}.
If \texttt{rec} is NULL then we use the current (last imported) text record.
If binary output mode we quietly skip writing this record [1].
\index{GMT\_WRITE\_TEXT}
\item [GMT\_WRITE\_TABLE\_HEADER]: For ASCII output mode we write the text string \texttt{rec}.
If \texttt{rec} is NULL then we write the last read
header record (and ensures it starts with \#). If binary output mode we quietly skip writing this record [2].
\index{GMT\_WRITE\_TABLE\_HEADER}
\item [GMT\_WRITE\_SEGMENT\_HEADER]: For ASCII output mode we use the text string \texttt{rec} as the segment header.
If \texttt{rec} is NULL then we use the current (last read) segment header record.
If binary output mode instead we write a record composed of NaNs [1].
\index{GMT\_WRITE\_SEGMENT\_HEADER}
\end{description}
The function returns TRUE (1) if there was an error associated with the writing (which is passed back with \texttt{API->error}),
otherwise it returns FALSE (0).

\subsection{Exporting a grid row}
\index{Exporting a grid row}
\index{Data!Export grid row}
\index{Resources!Export grid row}

If your program must write a grid file row-by-row you must first enable row-by-row
writing with \texttt{GMT\_Read\_Data} and then use the \texttt{GMT\_Put\_Row} function in a loop;
the prototype is
\index{GMT\_Put\_Row}

\begin{verbatim}
int GMT_Put_Row (void *API, int row_no, struct GMT_GRID *G, float *row);
\end{verbatim}
where \texttt{row} is a pointer to a single-precision array with the current row,
\texttt{G} is the grid in question, and \texttt{row\_no} is the number of the current
row to be written.  Note this value is only considered if the row-by-row mode was
initialized with GMT\_GRID\_ROW\_BY\_ROW\_MANUAL.

\subsection{Disable Data Export}
\index{Export!Disable}
\index{Data!Export}
\index{Resources!Export data}

Once the record-by-record output has completed we disable further output to prevent accidental
writing from occurring (due to poor program structure, bugs, etc.).  We do so by calling \texttt{GMT\_End\_IO}.  This
function disables further record-by-record data export; here, we obviously pass \texttt{direction} as GMT\_OUT.

\section{Destroy allocated resources}
\index{Destroy allocated resources}
\index{Resources!Destroy}

If your session imported any data sets into memory then you may explicitly free this
memory once it is no longer needed and before terminating the session.
This is done with the \texttt{GMT\_Destroy\_Data} function, whose prototype is
\index{GMT\_Destroy\_Data}

\begin{verbatim}
int GMT_Destroy_Data (void *API, unsigned int mode, void *data);
\end{verbatim}
where \texttt{data} is the address of the pointer to a data container.
Pass \texttt{mode} either as GMT\_ALLOCATED or GMT\_REFERENCE.  The former
is used internally by the \GMT\ modules since they can only free resources that are
not destined to live on in the memory of their calling program.  The latter mode is used
to free resources in your calling program.  Note that when each module completes it will
automatically free memory created by the API; similarly, when the session is destroyed
we also automatically free up memory.  Thus, \texttt{GMT\_Destroy\_Data} is therefore
generally only needed when you wish to directly free up memory to avoid running out of it.
\index{GMT\_ALLOCATED}
\index{GMT\_REFERENCE}
The function returns TRUE (1) if there is an error when trying to free the memory
(the error code is passed back with \texttt{API->error}), otherwise it returns FALSE (0).

\section{Terminate a GMT session}
\index{Terminate a GMT session}
\index{GMT session!Terminate}

Before your program exits it should properly terminate the \GMT\ session, which involves a call to

\begin{verbatim}
int GMT_Destroy_Session (void *API);
\end{verbatim}
\index{GMT\_Destroy\_Session}
which simply takes the pointer to the \GMT\ API control structure as its only arguments.  It 
terminates the \GMT\ machinery and deallocates all memory used by the \GMT\ API book-keeping.
It also unregisters any remaining resources previously registered with the session.
The \GMT\ API will only close files that it was responsible for opening in the first place.
Finally, the API structure itself is freed so your main program does not need to do so.
The function returns TRUE (1) if there is an error when trying to free the memory
(the error code is passed back with \texttt{API->error}), otherwise it returns FALSE (0).

\chapter{The GMT FFT Interface} 
\index{FFT interface}

While the i/o options presented so far lets you easily read in a data table or grid and manipulated them,
if you need to do so in the wavenumber domain then this chapter is for you.  Here we outline how to
take the Fourier transform of such data, perform calculations in the wavenumber domain, and take the
inverse transform before writing the results.  To assist programmers we also distribute fully functioning demonstration
programs that takes you through the steps we are about to discuss; these demo programs may be used
as your starting point for further development.

\section{Presenting and Parsing the FFT options}
\index{FFT options}

Several \GMT\ programs using FFTs present the same unified option and modifier sets to the user.
The API makes these available as well.  If your program needs to present the option usage you can call
\begin{verbatim}
unsigned int GMT_FFT_Option (void *API, char option, unsigned int dim, \
    char *string);
\end{verbatim}
\index{GMT\_FFT\_Option}
Here, \texttt{option} is the unique character used for this particular program option (most \GMT\ programs
have standardized on using `N' but you are free to choose whatever you want except existing \GMT\ common options).
The \texttt{dim} sets the dimension of the transform, currently you must choose 1 or 2,
while the \texttt{string} is a one-line message that states what the option does; you should tailor this to
your program.  If NULL then a generic message is placed instead.

To parse the user's selection you call

\begin{verbatim}
void * GMT_FFT_Parse (void *API, char option, unsigned int dim, char *args);
\end{verbatim}
\index{GMT\_FFT\_Option}
which accepts the user's string option via \texttt{args}; the other arguments are the same as those above.
The function returns an opaque pointer to a structure with the chosen parameters.

\section{Initializing the FFT machinery}
\index{FFT initialization}

Before your can take any transforms you must initialize the FFT machinery. This process involves a series of
preparatory steps that are conveniently performed for you by

\begin{verbatim}
void * GMT_FFT_Create (void *API, void *X, unsigned int dim, \
    unsigned int subdivide, unsigned int mode, void *F);
\end{verbatim}
\index{GMT\_FFT\_Create}
Here, \texttt{X} is either your dataset or grid pointer, \texttt{dim} is the dimension of the transform
(1 or 2 only), \texttt{subdivide} is not yet used by the API, \texttt{mode} passes various flags to the setup,
such as whether the data is real, imaginary, or complex,
and \texttt{F} is the opaque pointer returned by \texttt{GMT\_FFT\_Parse}.  Depending on the options
you chose to pass to \texttt{GMT\_FFT\_Parse}, the data may have a constant or a trend removed, reflected and
extended by various symmetries, padded and tapered to desired transform dimensions, and possibly
there are temporary files written out before the transform takes place.  See the \Gmtprog{grdfft} man
page for a full explanation of the options presented by \texttt{GMT\_FFT\_Option}.

\section{Taking the FFT}
\index{FFT}

Now that everything has been set up you can perform the transform with

\begin{verbatim}
void * GMT_FFT (void *API, void *X, int direction, unsigned int mode, \
    void *K);
\end{verbatim}
\index{GMT\_FFT}
which takes as \texttt{direction} either GMT\_FFT\_FWD or GMT\_FFT\_INV.  The mode is used to
specify if we pass a real (GMT\_FFT\_REAL) or complex (GMT\_FFT\_COMPLEX) data set, and \texttt{K} is the opaque pointer returned
by \texttt{GMT\_FFT\_Create}.  The transform is performed in place and returned via \texttt{X}.
When done with your manipulations (below) you can call it again with the inverse flag to recover
the corresponding space-domain version of your data.  The FFT is fully normalized so that calling
forward followed by inverse yields the original data set.

\section{Wavenumber calculations}
\index{Wavenumber calculations}

As your data have been transformed to the wavenumber domain you may wish to operate on the various
values as a function of wavenumber.  We will show how this is done for datasets and grids separately.
First, we present the function that returns an individual wavenumber:

\begin{verbatim}
double GMT_FFT_Wavenumber (void *API, uint64_t k, unsigned int mode, \
    void *K);
\end{verbatim}
\index{GMT\_FFT}
where \texttt{k} is the index into the array or grid, \texttt{mode} specifies which wavenumber
we want (it is not used for 1-D transform but for the 2-D transform we can select either the
x-wavenumber (0), the y-wavenumber (1), or the radial wavenumber (2)), and finally the opaque
vector used earlier.

\subsection{1-D FFT manipulation}

To be added later.

\subsection{2-D FFT manipulation}

The number of complex pairs in the grid is given by the header's \texttt{nm} variable, while \texttt{size}
will be twice that value as it holds the number of components.  To visit all the complex values and obtain
the corresponding wavenumber we simply need to loop over \texttt{size} and call \texttt{GMT\_FFT\_Wavenumber}.
This code snippet multiples the complex grid by the radial wavenumber:

\begin{verbatim}
uint64_t k;
for (k = 0; k < Grid->header->size; k++) {
    wave = GMT_FFT_Wavenumber (API, k, 2, K);
    Grid->data[k] *= wave;
}
\end{verbatim}
Alternatively, you may choose to be more specific about which components are real and imaginary (especially
if they are to be treated differently), and set up the loop this way:
\begin{verbatim}
uint64_t re, im;
for (re = 0, im = 1; re < Grid->header->size; re += 2, im += 2) {
    wave = GMT_FFT_Wavenumber (API, re, 2, K);
    Grid->data[re] *= wave;
    Grid->data[im] *= 2.0 * wave;
}
\end{verbatim}

\section{Destroying the FFT machinery}
\index{Destroy FFT machinery}

When done you terminate the FFT machinery with

\begin{verbatim}
double GMT_FFT_Destroy (void *API, void *K);
\end{verbatim}
\index{GMT\_FFT\_Destroy}
which simply frees up the memory allocated by the FFT machinery.

\chapter{FORTRAN 77 interface} 
\index{FORTRAN 77 interface}
\index{Interface!FORTRAN 77}

FORTRAN 77 developers who wish to use the \GMT\ API may use the same 22 API functions as discussed in Chapter 2.
However, as pointers to structures and such are not available, the FORTRAN bindings provided simplifies the
interface in that the first argument to the functions (the GMTAPI Control structure pointer) is not provided.
Instead, the bindings use a hidden, global external structure for this purpose and pass the pointer to it down to
the C version of the functions.  See Table~\ref{tbl:API} for the list of functions available.

\clearpage
%\addcontentsline{toc}{chapter}{INDEX}
\printindex

\end{document}
